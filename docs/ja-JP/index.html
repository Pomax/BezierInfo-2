<!DOCTYPE html>
<html lang="ja-JP">
	<head>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1" />
		<title>ベジェ曲線入門</title>

		<base href=".." />

		<link rel="icon" href="images/favicon.png" type="image/png" />

		<link rel="alternate" type="application/rss+xml" title="RSS" href="news/rss.xml" />

		<!-- page styling -->
		<link rel="preload" href="images/paper.png" as="image" />
		<style>
			:root[lang="ja-JP"] {
				font-family: "ヒラギノ角ゴ Pro W3", "Hiragino Kaku Gothic Pro", "Osaka", "メイリオ", "Meiryo", "ＭＳ Ｐゴシック", "MS PGothic",
					"Helvetica Neue", Helvetica, Arial, sans-serif;
				font-size: 15.6px;
			}
		</style>

		<link rel="stylesheet" href="style.css" />

		<!-- And a slew of SEO related meta elements, because being discoverable is important -->
		<meta
			name="description"
			content="A detailed explanation of Bézier curves, and how to do the many things that we commonly want to do with them."
		/>

		<!-- opengraph information -->
		<meta property="og:title" content="ベジェ曲線入門" />
		<meta property="og:image" content="https://pomax.github.io/bezierinfo/images/og-image.png" />
		<meta property="og:type" content="text" />
		<meta property="og:url" content="https://pomax.github.io/bezierinfo/ja-JP" />
		<meta
			property="og:description"
			content="A detailed explanation of Bézier curves, and how to do the many things that we commonly want to do with them."
		/>
		<meta property="og:locale" content="ja-JP" />
		<meta property="og:type" content="article" />
		<meta property="og:published_time" content="2013-06-13T12:00:00+00:00" />
		<meta property="og:updated_time" content="2020-10-28T01:54:22+00:00" />
		<meta property="og:author" content="Mike 'Pomax' Kamermans" />
		<meta property="og:section" content="Bézier Curves" />
		<meta property="og:tag" content="Bézier Curves" />

		<!-- twitter card information -->
		<meta name="twitter:card" content="summary" />
		<meta name="twitter:site" content="@TheRealPomax" />
		<meta name="twitter:creator" content="@TheRealPomax" />
		<meta name="twitter:image" content="https://pomax.github.io/bezierinfo/images/og-image.png" />
		<meta name="twitter:url" content="https://pomax.github.io/bezierinfo/ja-JP" />
		<meta
			name="twitter:description"
			content="A detailed explanation of Bézier curves, and how to do the many things that we commonly want to do with them."
		/>

		<!-- my own referral/page hit tracker, because Google knows enough -->
		<script src="./js/site/referrer.js" type="module" async></script>

		<!--
          The part that makes interactive graphics work: an HTML5 <graphics-element> custom element.
          Note that we're not defering this: we just want it to kick in as soon as possible, and
          given how much HTML there is, that means this can, and thus should, kick in before the
          document is done even transferring.
        -->
		<script src="./js/custom-element/graphics-element.js" type="module" async></script>
		<link rel="stylesheet" href="./js/custom-element/graphics-element.css" />

		<!-- make images lazy load much earlier  -->
		<script src="./js/site/better-lazy-loading.js" type="module" async defer></script>
	</head>

	<body>
		<div class="dev" style="display: none;">
			DEV PREVIEW ONLY
			<script>
				(function () {
					var loc = window.location.toString();
					if (loc.includes("localhost") || loc.includes("BezierInfo-2")) {
						var e = document.querySelector("div.dev");
						e.removeAttribute("style");
					}
				})();
			</script>
		</div>

		<div class="github">
			<img src="images/ribbon.png" alt="This page on GitHub" style="border: none;" usemap="#githubmap" width="200" height="149" />
			<map name="githubmap">
				<area shape="poly" coords="30,0, 200,0, 200,114" href="http://github.com/pomax/BezierInfo-2" alt="This page on GitHub" />
			</map>
		</div>

		<div class="notforprint scl">
			<img src="images/icons.gif" usemap="#rhtimap" title="Share this on social media" />
			<map name="rhtimap">
				<area
					class="sclnk-rdt"
					shape="rect"
					coords="0, 0, 19, 15"
					href="https://www.reddit.com/submit?url=https://pomax.github.io/bezierinfo&title=A Primer on Bézier Curves&text=A free, online book for when you really need to know how to do Bézier things."
					alt="submit to reddit"
					title="submit to reddit"
				/>
				<area
					class="sclnk-hn"
					shape="rect"
					coords="0, 20, 19, 35"
					href="https://news.ycombinator.com/submitlink?u=https://pomax.github.io/bezierinfo&t=A Primer on Bézier Curves"
					alt="submit to hacker news"
					title="submit to hacker news"
				/>
				<area
					class="sclnk-twt"
					shape="rect"
					coords="0, 40, 19, 55"
					href="https://twitter.com/intent/tweet?hashtags=bezier,curves,maths&original_referer=https://pomax.github.io/bezierinfo&text=Reading “A Primer on Bezier Curves” by @TheRealPomax over on https://pomax.github.io/bezierinfo"
					alt="tweet your read"
					title="tweet your read"
				/>
			</map>
		</div>

		<script src="./js/site/social-updater.js" async defer></script>

		<header>
			<h1>
				ベジェ曲線入門<a class="rss-link" href="news/rss.xml"><img src="images/rss.png" /></a>
			</h1>
			<h2>A free, online book for when you really need to know how to do Bézier things.</h2>
			<div>
				<span>Read this in your own language:</span>
				<ul class="lang-switcher">
					<li><a href="./index.html">English</a> <span class="localisation-progress">(100%)</span></li>
					<li><a href="./ja-JP/index.html">日本語</a> <span class="localisation-progress">(24%)</span></li>
					<li><a href="./zh-CN/index.html">中文</a> <span class="localisation-progress">(22%)</span></li>
				</ul>
				<p>
					(Don't see your language listed, or want to see it reach 100%?
					<a href="https://github.com/Pomax/BezierInfo-2/wiki/help-localize-the-primer-on-bezier-curves">Help translate this content!</a>)
				</p>
			</div>

			<p>
				Welcome to the Primer on Bezier Curves. This is a free website/ebook dealing with both the maths and programming aspects of Bezier Curves,
				covering a wide range of topics relating to drawing and working with that curve that seems to pop up everywhere, from Photoshop paths to CSS
				easing functions to Font outline descriptions.
			</p>
			<p>
				If this is your first time here: welcome! Let me know if you were looking for anything in particular that the primer doesn't cover over on the
				<a href="https://github.com/Pomax/BezierInfo-2/issues">issue tracker</a>!
			</p>

			<p>
				If this is a resource that you're using for research, or writing your own software, please consider
				<a href="https://www.paypal.com/donate/?cmd=_s-xclick&hosted_button_id=3BNHGHZAS3DP6&locale.x=en_CA">donating</a> (any amount helps) or
				signing up as <a href="https://www.patreon.com/bezierinfo">a patron on Patreon</a>. I don't get paid to work on this, so if you find this site
				valuable, and you'd like it to stick around for a long time to come, a lot of coffee went into writing this over the years, and a lot more
				coffee will need to go into it yet: if you can spare a coffee, you'd be helping keep a resource alive and well!
			</p>

			<p>— <a href="https://twitter.com/TheRealPomax">Pomax</a></p>
			<noscript>
				<div class="note">
					<header>
						<h2>This site (obviously) works best with JS enabled</h2>
						<h3>But it's not required.</h3>
					</header>

					<p>
						If you're reading this text block, then you have scripts disabled: thankfully, that's perfectly fine, and this site is not going to punish
						you for making smart choices around privacy and security in your browser. All the content will show just fine, you can still read the
						text, navigate to sections, and see the graphics that are used to illustrate the concepts that individual sections talk about.
					</p>

					<p>
						<strong>However</strong>, a big part of this primer's experience is the fact that all graphics are interactive, and for that to work, HTML
						Custom Elements need to work, which requires Javascript to be enabled. If anything, you'll probably want to allow scripts to run just for
						this site, and keep blocking everything else. Although that does mean you won't see comments, which use Disqus's comment system, and you
						won't get convenient "share a link to the section you're reading right now" buttons, if that's something you like to do.
					</p>
				</div>
			</noscript>
			<nav aria-labelledby="toc">
				<h1 id="toc">目次</h1>
				<h4>前文</h4>
				<ol class="preamble">
					<li><a href="ja-JP/index.html#preface">まえがき </a></li>
					<li><a href="ja-JP/index.html#changelog">What's new</a></li>
				</ol>
				<h4>Main content</h4>
				<ol>
					<li><a href="ja-JP/index.html#introduction">バッとした導入</a></li>
					<li><a href="ja-JP/index.html#whatis">ではベジエ曲線はどうやってできるのでしょう？</a></li>
					<li><a href="ja-JP/index.html#explanation">ベジエ曲線の数学</a></li>
					<li><a href="ja-JP/index.html#control">ベジエ曲線の曲率の制御</a></li>
					<li><a href="ja-JP/index.html#weightcontrol">Controlling Bézier curvatures, part 2: Rational Béziers</a></li>
					<li><a href="ja-JP/index.html#extended">ベジエ曲線の区間 [0,1]</a></li>
					<li><a href="ja-JP/index.html#matrix">行列演算としてのベジエ曲線の曲率</a></li>
					<li><a href="ja-JP/index.html#decasteljau">ド・カステリョのアルゴリズム</a></li>
					<li><a href="ja-JP/index.html#flattening">簡略化した描画</a></li>
					<li><a href="ja-JP/index.html#splitting">曲線の分割</a></li>
					<li><a href="ja-JP/index.html#matrixsplit">行列による曲線の分割</a></li>
					<li><a href="ja-JP/index.html#reordering">Lowering and elevating curve order</a></li>
					<li><a href="ja-JP/index.html#derivatives">Derivatives</a></li>
					<li><a href="ja-JP/index.html#pointvectors">Tangents and normals</a></li>
					<li><a href="ja-JP/index.html#pointvectors3d">Working with 3D normals</a></li>
					<li><a href="ja-JP/index.html#components">Component functions</a></li>
					<li><a href="ja-JP/index.html#extremities">Finding extremities: root finding</a></li>
					<li><a href="ja-JP/index.html#boundingbox">Bounding boxes</a></li>
					<li><a href="ja-JP/index.html#aligning">Aligning curves</a></li>
					<li><a href="ja-JP/index.html#tightbounds">Tight bounding boxes</a></li>
					<li><a href="ja-JP/index.html#inflections">Curve inflections</a></li>
					<li><a href="ja-JP/index.html#canonical">The canonical form (for cubic curves)</a></li>
					<li><a href="ja-JP/index.html#yforx">Finding Y, given X</a></li>
					<li><a href="ja-JP/index.html#arclength">Arc length</a></li>
					<li><a href="ja-JP/index.html#arclengthapprox">Approximated arc length</a></li>
					<li><a href="ja-JP/index.html#curvature">Curvature of a curve</a></li>
					<li><a href="ja-JP/index.html#tracing">Tracing a curve at fixed distance intervals</a></li>
					<li><a href="ja-JP/index.html#intersections">Intersections</a></li>
					<li><a href="ja-JP/index.html#curveintersection">Curve/curve intersection</a></li>
					<li><a href="ja-JP/index.html#abc">The projection identity</a></li>
					<li><a href="ja-JP/index.html#pointcurves">Creating a curve from three points</a></li>
					<li><a href="ja-JP/index.html#projections">Projecting a point onto a Bézier curve</a></li>
					<li><a href="ja-JP/index.html#molding">Molding a curve</a></li>
					<li><a href="ja-JP/index.html#curvefitting">Curve fitting</a></li>
					<li><a href="ja-JP/index.html#catmullconv">Bézier curves and Catmull-Rom curves</a></li>
					<li><a href="ja-JP/index.html#catmullfitting">Creating a Catmull-Rom curve from three points</a></li>
					<li><a href="ja-JP/index.html#polybezier">Forming poly-Bézier curves</a></li>
					<li><a href="ja-JP/index.html#offsetting">Curve offsetting</a></li>
					<li><a href="ja-JP/index.html#graduatedoffset">Graduated curve offsetting</a></li>
					<li><a href="ja-JP/index.html#circles">Circles and quadratic Bézier curves</a></li>
					<li><a href="ja-JP/index.html#circles_cubic">Circles and cubic Bézier curves</a></li>
					<li><a href="ja-JP/index.html#arcapproximation">Approximating Bézier curves with circular arcs</a></li>
					<li><a href="ja-JP/index.html#bsplines">B-Splines</a></li>
					<li><a href="ja-JP/index.html#comments">Comments and questions</a></li>
				</ol>
			</nav>
		</header>

		<main>
			<section id="preface">
				<h1>まえがき</h1>
				<p>
					2次元上になにかを描くとき、普通は線を使いますが、これは直線と曲線の2つに分類することができます。直線を描くのはとても簡単で、これをコンピュータに描かせるのも容易です。直線の始点と終点をコンピュータに与えてやれば、ポン！直線が描けました。疑問の余地もありません。
				</p>
				<p>
					しかしながら、曲線の方はもっと大きな問題です。私たちはフリーハンドでいとも簡単に曲線を描くことができますが、コンピュータの方は少し不利です。曲線の描き方を表した数学的な関数が与えられないと、コンピュータは曲線を描くことができないのです。実際には、直線でさえも関数が必要になります。直線の関数はとても簡単なので、わたしたちはよく無視してしまいますが、コンピュータにとっては直線であれ曲線であれ、線はすべて「関数」なのです。しかしこれは、コンピュータで速く計算できて、きれいな曲線が得られるような関数を見つける必要がある、ということになります。そのような関数はたくさんありますが、多くの関心を集め続け、そしてどんな場面でも使われている、ある特定の関数に対してこの記事では焦点を絞ります。この関数は「ベジエ」曲線を描きます。
				</p>
				<p>
					ベジエ曲線は<a href="https://ja.wikipedia.org/wiki/%E3%83%94%E3%82%A8%E3%83%BC%E3%83%AB%E3%83%BB%E3%83%99%E3%82%B8%E3%82%A7"
						>Pierre Bézier</a
					>から名付けられました。この曲線がデザイン作業に適していることを世界に知らしめたのが、彼なのです（ルノーに勤務し、1962年にその研究を発表しました）。ただし、この曲線を「発明」したのは彼が最初で唯一というわけではありません。数学者<a
						href="https://en.wikipedia.org/wiki/Paul_de_Casteljau"
						>Paul de Casteljau</a
					>はシトロエンで働いていた1959年、この曲線の性質について研究し、ベジエ曲線の非常にエレガントな描き方を発見しました。これが最初だと言う人もいます。しかしながら、de
					Casteljauは自分の成果を発表しなかったため、「誰が最初か？」という問いに答えるのがとても難しくなっています。またベジエ曲線は、核心的には<a
						href="https://ja.wikipedia.org/wiki/%E3%82%BB%E3%83%AB%E3%82%B2%E3%82%A4%E3%83%BB%E3%83%99%E3%83%AB%E3%83%B3%E3%82%B7%E3%83%A5%E3%83%86%E3%82%A4%E3%83%B3"
						>Sergei Natanovich Bernstein</a
					>が研究した「ベルンシュタイン多項式」という数学関数の一種ですが、こちらの公刊に関しては少なくとも1912年まで遡ることができます。いずれにせよ、これらはほとんど瑣末なことです。より注目すべきなのは、ベジエ曲線は取り扱いに便利だいうことです。たとえば複数のベジエ曲線を繋いで、1つの曲線に見えるようにすることができます。もしあなたがPhotoshopで「パス」を描いたり、FlashやIllustrator、Inkscapeのようなベクタードローイングソフトを使ったことがあるのであれば、そこで描いてきた曲線はベジエ曲線です。
				</p>
				<p>
					では、これを自分でプログラムしなければならないとなったらどうでしょう？ハマりどころは何でしょうか？どうやってベジエ曲線を描くのでしょう？バウンディングボックスとは何で、どうやって交点を求め、どうやったら曲線を押し出せるのでしょうか？つまるところ、ベジエ曲線に対して行いたいあらゆる操作は、どのようにすればいいのでしょう？このページはそれに答えるためにあります。数学にとりかかりましょう！
				</p>
				<div class="print">
					<h2>追伸：コーヒーをおごってくれませんか？</h2>
					<p>
						この本のことを印刷するほど気に入ったのであれば、あなたは「何かお礼をする方法はないか」と考えているかもしれません。この質問に対する答えはこうです：いつでもわたしにコーヒーをおごってください。あなたが住んでいるところの、コーヒー1杯の値段でかまいません。この本にかなりの金額を支払いたいのであれば、非常に高価なコーヒーをおごってくれてもかまいません
						=)
					</p>
					<p>
						この本は小さな入門からはじまり、印刷85ページ以上に相当するようなベジエ曲線の電子書籍へと、年々成長してきています。そして、多くのコーヒーがその執筆に費やされてきました。わたしは執筆に使った時間が惜しいとは思いませんが、もう少しコーヒーがあれば、ずっと書き続けることができるのです！<a
							href="https://pomax.github.io/bezierinfo/%E3%81%AB%E3%82%A2%E3%82%AF%E3%82%BB%E3%82%B9%E3%81%97%E3%81%A6%E3%82%AA%E3%83%B3%E3%83%A9%E3%82%A4%E3%83%B3%E7%89%88%E3%81%AE%E3%81%BE%E3%81%88%E3%81%8C%E3%81%8D%E3%81%AB%E3%81%82%E3%82%8B%E3%83%AA%E3%83%B3%E3%82%AF%E3%82%92%E3%82%AF%E3%83%AA%E3%83%83%E3%82%AF%E3%81%97%E3%80%81%E3%82%B3%E3%83%BC%E3%83%92%E3%83%BC%E4%BB%A3%E3%82%92%E5%AF%84%E4%BB%98%E3%81%97%E3%81%A6%E3%81%8F%E3%81%A0%E3%81%95%E3%81%84%E3%80%82"
							>https://pomax.github.io/bezierinfo/にアクセスしてオンライン版のまえがきにあるリンクをクリックし、コーヒー代を寄付してください。</a
						>
					</p>
				</div>

				<div class="note">
					<h2>注：ベジエの図はすべてインタラクティブになっています。</h2>
					<p>このページでは<a href="https://pomax.github.io/bezierjs/">Bezier.js</a>を活用し、インタラクティブな例示を行っています。</p>
					<!-- The following is no longer true
また、[MathJax](https://mathjax.org)というすばらしいライブラリによって、（LaTeX式の）「本物」の数学組版を行っています。このページはWebpackを使い、Reactアプリケーションとしてオフラインで生成されていますが、このために「ソースを表示」オプションを追加することがかなり難しくなってしまいました。これをどうやって追加すべきかは今もまだ考え中ですが、かといって、数年ぶりとなる今回の更新を延期したくはありませんでした。
-->

					<h2>本書はオープンソースです。</h2>
					<p>
						この本はオープンソースソフトウェアのプロジェクトで、2つのGitHubリポジトリ上に存在しています。1つ目の<a
							href="https://github.com/pomax/bezierinfo"
							>https://github.com/pomax/bezierinfo</a
						>は表示のためだけに用意されたバージョンで、あなたが今読んでいるものです。もう一方の<a href="https://github.com/pomax/BezierInfo-2"
							>https://github.com/pomax/BezierInfo-2</a
						>は開発版で、すべてのHTML・JavaScript・CSSが含まれています。どちらのリポジトリもフォークすることができますし、あなたの好きなように使ってかまいません。ただし、これを自分の成果だと騙って売ることはもちろん除きます。=)
					</p>
					<h2>数学はどこまで難しくなりますか？</h2>
					<p>
						この入門に出てくる数学は、大半が高校初年度程度です。基本的な計算を理解していて、英語の読み方が分かっていれば、こなすことができるはずです。時には<em>ずっと</em>難しい数学も出てきますが、もし理解できないように感じたら、そこは読み飛ばしても大丈夫です。節の中の「詳細欄」を飛ばしてもいいですし、厄介そうな数学があれば節の最後まで読み飛ばしてもかまいません。各節の最後にはたいてい結論を並べてありますので、これを直に利用することもできます。
					</p>
					<h2>質問・コメント：</h2>
					<p>
						新しい節の提案があれば、<a href="https://github.com/pomax/BezierInfo-2/issues">GitHubのissueトラッカー</a
						>をクリックしてください（右上にあるリポジトリのリンクからでもたどり着けます）。改訂中のため、現在はこのページにはコメント欄がありませんが、内容に関する質問がある場合にもissueトラッカーを使ってかまいません。改訂が完了したら、総合的なコメント欄を復活させる予定です。あるいは、「質問対象の節を選択して『質問』ボタンをクリック」するような項目別のシステムになるかもしれません。いずれわかります。
					</p>
					<h2>コーヒーをおごってくれませんか？</h2>
					<p>
						この本が気に入った場合や、取り組んでいたことに役に立つと思った場合、あるいは、この本への感謝をわたしに伝えるにはどうすればいいのかわからない場合。そのような場合には、<a
							href="https://www.paypal.com/donate/?cmd=_s-xclick&hosted_button_id=3BNHGHZAS3DP6&locale.x=en_CA"
							>わたしにコーヒーをおごってください</a
						>。あなたが住んでいるところのコーヒー1杯の値段でかまいません。この本は小さな入門からはじまり、印刷で70ページほどに相当するようなベジエ曲線の読み物へと、年々成長してきています。そして、多くのコーヒーが執筆に費やされてきました。わたしは執筆に使った時間が惜しいとは思いませんが、もう少しコーヒーがあれば、ずっと書き続けることができるのです！
					</p>
				</div>
			</section>
			<section id="changelog">
				<h1>What's new?</h1>
				<p>
					This primer is a living document, and so depending on when you last look at it, there may be new content. Click the following link to expand
					this section to have a look at what got added, when, or click through to the <a href="./news">News posts</a> for more detailed updates. (<a
						href="./news/rss.xml"
						>RSS feed</a
					>
					available)
				</p>
				<!-- non-JS content reveals are nice -->
				<label for="changelogtoggle">Toggle changes</label>
				<input type="checkbox" id="changelogtoggle" />
				<section>
					<h2>August-September 2020</h2>
					<ul>
						<li>
							<p>
								Completely overhauled the site: the Primer is now a normal web page that works fine with JS disabled, but obviously better with JS
								turned on.
							</p>
						</li>
					</ul>
					<h2>June 2020</h2>
					<ul>
						<li><p>Added automatic CI/CD using Github Actions</p></li>
					</ul>
					<h2>January 2020</h2>
					<ul>
						<li><p>Added reset buttons to all graphics</p></li>
						<li><p>Updated to preface to correctly describe the on-page maths</p></li>
						<li><p>Fixed the Catmull-Rom section because it had glaring maths errors</p></li>
					</ul>
					<h2>August 2019</h2>
					<ul>
						<li><p>Added a section on (plain) rational Bezier curves</p></li>
						<li><p>Improved the Graphic component to allow for sliders</p></li>
					</ul>
					<h2>December 2018</h2>
					<ul>
						<li><p>Added a section on curvature and calculating kappa.</p></li>
						<li>
							<p>
								Added a Patreon page! Head on over to <a href="https://www.patreon.com/bezierinfo">patreon.com/bezierinfo</a> to help support this
								site!
							</p>
						</li>
					</ul>
					<h2>August 2018</h2>
					<ul>
						<li><p>Added a section on finding a curve&#39;s y, if all you have is the x coordinate.</p></li>
					</ul>
					<h2>July 2018</h2>
					<ul>
						<li><p>Rewrote the 3D normals section, implementing and explaining Rotation Minimising Frames.</p></li>
						<li><p>Updated the section on curve order raising/lowering, showing how to get a least-squares optimized lower order curve.</p></li>
						<li>
							<p>(Finally) updated &#39;npm test&#39; so that it automatically rebuilds when files are changed while the dev server is running.</p>
						</li>
					</ul>
					<h2>June 2018</h2>
					<ul>
						<li><p>Added a section on direct curve fitting.</p></li>
						<li><p>Added source links for all graphics.</p></li>
						<li><p>Added this &quot;What&#39;s new?&quot; section.</p></li>
					</ul>
					<h2>April 2017</h2>
					<ul>
						<li><p>Added a section on 3d normals.</p></li>
						<li><p>Added live-updating for the social link buttons, so they always link to the specific section you&#39;re reading.</p></li>
					</ul>
					<h2>February 2017</h2>
					<ul>
						<li><p>Finished rewriting the entire codebase for localization.</p></li>
					</ul>
					<h2>January 2016</h2>
					<ul>
						<li><p>Added a section to explain the Bezier interval.</p></li>
						<li><p>Rewrote the Primer as a React application.</p></li>
					</ul>
					<h2>December 2015</h2>
					<ul>
						<li><p>Set up the split repository between BezierInfo-2 as development repository, and bezierinfo as live page.</p></li>
						<li>
							<p>
								Removed the need for client-side LaTeX parsing entirely, so the site doesn&#39;t take a full minute or more to load all the graphics.
							</p>
						</li>
					</ul>
					<h2>May 2015</h2>
					<ul>
						<li><p>Switched over to pure JS rather than Processing-through-Processing.js</p></li>
						<li><p>Added Cardano&#39;s algorithm for finding the roots of a cubic polynomial.</p></li>
					</ul>
					<h2>April 2015</h2>
					<ul>
						<li><p>Added a section on arc length approximations.</p></li>
					</ul>
					<h2>February 2015</h2>
					<ul>
						<li><p>Added a section on the canonical cubic Bezier form.</p></li>
					</ul>
					<h2>November 2014</h2>
					<ul>
						<li><p>Switched to HTTPS.</p></li>
					</ul>
					<h2>July 2014</h2>
					<ul>
						<li><p>Added the section on arc approximation.</p></li>
					</ul>
					<h2>April 2014</h2>
					<ul>
						<li><p>Added the section on Catmull-Rom fitting.</p></li>
					</ul>
					<h2>November 2013</h2>
					<ul>
						<li><p>Added the section on Catmull-Rom / Bezier conversion.</p></li>
						<li><p>Added the section on Bezier cuves as matrices.</p></li>
					</ul>
					<h2>April 2013</h2>
					<ul>
						<li><p>Added a section on poly-Beziers.</p></li>
						<li><p>Added a section on boolean shape operations.</p></li>
					</ul>
					<h2>March 2013</h2>
					<ul>
						<li><p>First drastic rewrite.</p></li>
						<li><p>Added sections on circle approximations.</p></li>
						<li><p>Added a section on projecting a point onto a curve.</p></li>
						<li><p>Added a section on tangents and normals.</p></li>
						<li><p>Added Legendre-Gauss numerical data tables.</p></li>
					</ul>
					<h2>October 2011</h2>
					<ul>
						<li>
							<p>
								First commit for the <a href="https://pomax.github.io/bezierinfo/">bezierinfo</a> site, based on the pre-Primer webpage that covered
								the basics of Bezier curves in HTML with Processing.js examples.
							</p>
						</li>
					</ul>
				</section>
			</section>
			<section id="chapters">
				<section id="introduction">
					<h1>
						<div class="nav"><a href="ja-JP/index.html#whatis">next</a></div>
						<a href="ja-JP/index.html#introduction">バッとした導入</a>
					</h1>
					<p>
						まずは良い例から始めましょう。ベジエ曲線というのは、下の図に表示されているもののことです。ベジエ曲線はある始点からある終点へと延びており、その曲率は1個以上の「中間」制御点に左右されています。さて、このページの図はどれもインタラクティブになっていますので、ここで曲線をちょっと操作してみましょう。点をドラッグしたとき、曲線の形がそれに応じてどう変化するのか、確かめてみてください。
					</p>
					<div class="figure">
						<graphics-element title="2次のベジエ曲線" width="275" height="275" src="./chapters/introduction/quadratic.js">
							<fallback-image>
								<span class="view-source">Scripts are disabled. Showing fallback image.</span>
								<img width="275px" height="275px" src="./images/chapters/introduction/54e9ec0600ac436b0e6f0c6b5005cf03.png" loading="lazy" />
								<label>2次のベジエ曲線</label>
							</fallback-image></graphics-element
						>
						<graphics-element title="3次のベジエ曲線" width="275" height="275" src="./chapters/introduction/cubic.js">
							<fallback-image>
								<span class="view-source">Scripts are disabled. Showing fallback image.</span>
								<img width="275px" height="275px" src="./images/chapters/introduction/8d158a13e9a86969b99c64057644cbc6.png" loading="lazy" />
								<label>3次のベジエ曲線</label>
							</fallback-image></graphics-element
						>
					</div>

					<p>
						ベジエ曲線は、CAD（computer aided designやCAM（computer aided manufacturing）のアプリケーションで多用されています。もちろん、Adobe
						Illustrator・Photoshop・Inkscape・Gimp などのグラフィックデザインアプリケーションや、SVG（scalable vector
						graphics）・OpenTypeフォント（otf/ttf）のようなグラフィック技術でも利用されています。ベジエ曲線はたくさんのものに使われていますので、これについてもっと詳しく学びたいのであれば……さあ、準備しましょう！
					</p>
				</section>
				<section id="whatis">
					<h1>
						<div class="nav"><a href="ja-JP/index.html#introduction">previous</a><a href="ja-JP/index.html#explanation">next</a></div>
						<a href="ja-JP/index.html#whatis">ではベジエ曲線はどうやってできるのでしょう？</a>
					</h1>
					<p>
						ベジエ曲線がどのように動くのか、点を触ってみて感覚が摑めたかもしれません。では、実際のところベジエ曲線<em>とは</em>いったい何でしょうか？これを説明する方法は2通りありますが、どちらの説明でも行き着く先はまったく同じです。一方は複雑な数学を使うのに対し、もう一方はとても簡単です。というわけで……簡単な説明の方から始めましょう。
					</p>
					<p>
						ベジエ曲線は、<a href="https://ja.wikipedia.org/wiki/%E7%B7%9A%E5%BD%A2%E8%A3%9C%E9%96%93">線形補間</a
						>の結果です。というと難しそうに聞こえますが、誰でも幼い頃から線形補間をやってきています。例えば、何か2つのものの間を指し示すときには、いつも線形補間を行っています。線形補間とは、単純に「2点の間から点を得る」ことなのです。
					</p>
					<p>
						例えば、2点間の距離がわかっているとして、一方の点から距離の20%だけ離れた（すなわち、もう一方の点から80%離れた）新しい点を求めたい場合、次のようにとても簡単に計算できます。
					</p>
					<!--
\usepackagexeCJK \xeCJKsetupCJKmath=true \setCJKmainfontipaexm.ttf
 
                                                 ╭ p = 一方の点      ╮
                                                 │  1            │
                                                 │ p = もう一方の点    │
                                                 │  2            │
                                                 │ 距離= (p  - p ) │のとき、新しい点 = p  + 距離  · 比率
                                                 │       2    1  │            1
                                                 │     百分率       │
                                                 │ 比率= ───       │
                                                 ╰     100       ╯
-->
					<img class="LaTeX SVG" src="./images/chapters/whatis/06bbc5c11ad3fd88ff93eb2c06177b66.svg" width="433px" height="108px" loading="lazy" />
					<p>
						では、実際に見てみましょう。下の図はインタラクティブになっています。上下キーで補間の比率が増減しますので、どうなるか確かめてみましょう。最初に3点があり、それを結んで2本の直線が引かれています。この直線の上でそれぞれ線形補間を行うと、2つの点が得られます。この2点の間でさらに線形補間を行うと、1つの点を得ることができます。そして、あらゆる比率に対して同様に点を求め、それをすべて集めると、このようにベジエ曲線ができるのです。
					</p>
					<graphics-element title="Linear Interpolation leading to Bézier curves" width="825" height="275" src="./chapters/whatis/interpolation.js">
						<fallback-image>
							<span class="view-source">Scripts are disabled. Showing fallback image.</span>
							<img width="825px" height="275px" src="./images/chapters/whatis/524dd296e96c0fe2281fb95146f8ea65.png" loading="lazy" />
							<label></label>
						</fallback-image>
						<input type="range" min="10" max="90" step="1" value="25" class="slide-control" />
					</graphics-element>
					<p>また、これが複雑な方の数学につながっていきます。微積分です。</p>
					<p>
						いま上で行ったものとは似つかないように思えますが、実はあれは2次曲線を描いていたのです。ただし一発で描きあげるのではなく、手順を追って描いていきました。ベジエ曲線は多項式関数で表現できますが、その一方で、とても単純な補間の補間の補間の……というふうにも説明できます。これがベジエ曲線のおもしろいところです。これはまた、ベジェ曲線は「本当の数学」で見る（関数を調べたり微分を調べたり、あらゆる方法で）ことも可能ですし、「機械的」な組み立て操作として見る（例えば、ベジエ曲線は組み立てに使う点の間からは決してはみ出ないということがわかります）ことも可能だということを意味しています。
					</p>
					<p>
						それでは、もう少し詳しくベジエ曲線を見ていきましょう。数学的な表現やそこから導かれる性質、さらには、ベジエ曲線に対して／ベジエ曲線を使ってできるさまざまな内容についてです。
					</p>
				</section>
				<section id="explanation">
					<h1>
						<div class="nav"><a href="ja-JP/index.html#whatis">previous</a><a href="ja-JP/index.html#control">next</a></div>
						<a href="ja-JP/index.html#explanation">ベジエ曲線の数学</a>
					</h1>
					<p>
						ベジエ曲線は「パラメトリック」関数の一種です。数学的に言えば、パラメトリック関数というのはインチキです。というのも、「関数」はきっちり定義された用語であり、いくつかの入力を<strong>1つ</strong>の出力に対応させる写像を表すものだからです。いくつかの数値を入れると、1つの数値が出てきます。入れる数値が変わっても、出てくる数値はやはり1つだけです。パラメトリック関数はインチキです。基本的には「じゃあわかった、値を複数個出したいから、関数を複数個使うことにするよ」ということです。例として、ある値<i>x</i>に何らかの操作を行い、別の値へと写す関数があるとします。
					</p>
					<!--
\setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
 
                                                               f(x) = cos (x)
-->
					<img class="LaTeX SVG" src="./images/chapters/explanation/0cc876c56200446c60114c1b0eeeb2cc.svg" width="96px" height="17px" loading="lazy" />
					<p>
						<i>f(x)</i
						>という記法は、これが関数（1つしかない場合は慣習的に<i>f</i>と呼びます）であり、その出力が1つの変数（この場合は<i>x</i>です）に応じて変化する、ということを示す標準的な方法です。<i>x</i>を変化させると、<i>f(x)</i>の出力が変化します。
					</p>
					<p>ここまでは順調です。では、パラメトリック関数について、これがどうインチキなのかを見てみましょう。以下の2つの関数を考えます。</p>
					<!--
\setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
 
                                                               f(a) = cos (a)
                                                               f(b) = sin (b)
-->
					<img class="LaTeX SVG" src="./images/chapters/explanation/a2891980850ddbb27d308ac112d69f74.svg" width="93px" height="36px" loading="lazy" />
					<p>
						注目すべき箇所は特に何もありません。ただの正弦関数と余弦関数です。ただし、入力が別々の名前になっていることに気づくでしょう。仮に<i>a</i>の値を変えたとしても、<i>f(b)</i>の出力の値は変わらないはずです。なぜなら、こちらの関数には<i>a</i>は使われていないからです。パラメトリック関数は、これを変えてしまうのでインチキなのです。パラメトリック関数においては、どの関数も変数を共有しています。例えば、
					</p>
					<!--
\setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
 
                                                             ╭ f (t) = cos (t)
                                                             ╡  a              
                                                             │ f (t) = sin (t)
                                                             ╰  b
-->
					<img
						class="LaTeX SVG"
						src="./images/chapters/explanation/7acc94ec70f053fd10dab69d424b02a6.svg"
						width="100px"
						height="40px"
						loading="lazy"
					/>
					<p>
						複数の関数がありますが、変数は1つだけです。<i>t</i>の値を変えた場合、<i>f<sub>a</sub>(t)</i>と<i>f<sub>b</sub>(t)</i>の両方の出力が変わります。これがどのように役に立つのか、疑問に思うかもしれません。しかし、実際には答えは至ってシンプルです。<i>f<sub>a</sub>(t)</i>と<i>f<sub>b</sub>(t)</i>のラベルを、パラメトリック曲線の表示によく使われているもので置き換えてやれば、ぐっとはっきりするかと思います。
					</p>
					<!--
\setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
 
                                                               { x = cos (t) 
                                                                 y = sin (t)
-->
					<img class="LaTeX SVG" src="./images/chapters/explanation/6914ba615733c387251682db7a3db045.svg" width="77px" height="40px" loading="lazy" />
					<p>きました。<i>x</i>/<i>y</i>座標です。謎の値<i>t</i>を通して繫がっています。</p>
					<p>
						というわけで、普通の関数では<i>y</i>座標を<i>x</i>座標によって定義しますが、パラメトリック曲線ではそうではなく、座標の値を「制御」変数と結びつけます。<i>t</i>の値を変化させるたびに<strong>2つ</strong>の値が変化するので、これをグラフ上の座標
						(<i>x</i>,<i>y</i>)として使うことができます。例えば、先ほどの関数の組は円周上の点を生成します。負の無限大から正の無限大へと<i>t</i>を動かすと、得られる座標(<i>x</i>,<i>y</i>)は常に中心(0,0)・半径1の円の上に乗ります。<i>t</i>を0から5まで変化させてプロットした場合は、このようになります。
					</p>
					<graphics-element title="（部分）円 x=sin(t), y=cos(t)" width="275" height="275" src="./chapters/explanation/circle.js">
						<fallback-image>
							<span class="view-source">Scripts are disabled. Showing fallback image.</span>
							<img width="275px" height="275px" src="./images/chapters/explanation/959762e39ae32407e914a687d804ff3a.png" loading="lazy" />
							<label>（部分）円 x=sin(t), y=cos(t)</label>
						</fallback-image>
						<input type="range" min="0" max="10" step="0.1" value="5" class="slide-control" />
					</graphics-element>
					<p>
						ベジエ曲線はパラメトリック関数の一種であり、どの次元に対しても同じ基底関数を使うという点で特徴づけられます。先ほどの例では、<i>x</i>の値と<i>y</i>の値とで異なる関数（正弦関数と余弦関数）を使っていましたが、ベジエ曲線では<i>x</i>と<i>y</i>の両方で「二項係数多項式」を使います。では、二項係数多項式とは何でしょう？
					</p>
					<p>高校で習った、こんな形の多項式を思い出すかもしれません。</p>
					<!--
\setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
 
                                                                3         2
                                                   f(x) = a  · x  + b  · x  + c  · x + d
-->
					<img
						class="LaTeX SVG"
						src="./images/chapters/explanation/855a34c7f72733be6529c3fb33fa1a23.svg"
						width="213px"
						height="20px"
						loading="lazy"
					/>
					<p>
						最高次の項が<i>x³</i>であれば3次多項式、<i>x²</i>であれば2次多項式と呼び、<i>x</i>だけの場合は1次多項式――ただの直線です。（そして<i>x</i>の入った項が何もなければ、多項式ではありません！）
					</p>
					<p>
						ベジエ曲線は<i>x</i>の多項式ではなく、<i>t</i>の多項式です。<i>t</i>の値は0から1までの間に制限され、その係数<i>a</i>、<i>b</i>などは「二項係数」の形をとります。というと複雑そうに聞こえますが、実際には値を組み合わせて、とてもシンプルに記述できます。
					</p>
					<!--
\usepackagexeCJK \xeCJKsetupCJKmath=true \setCJKmainfontipaexm.ttf
 
                                           1次= (1-t) + t                                        
                                                    2                      2
                                           2次= (1-t)  + 2  · (1-t)  · t + t                     
                                                    3             2                       2    3
                                           3次= (1-t)  + 3  · (1-t)   · t + 3  · (1-t)  · t  + t 
-->
					<img
						class="LaTeX SVG"
						src="./images/chapters/explanation/adc7729f7872d71f3fbb1a79741ce10f.svg"
						width="347px"
						height="64px"
						loading="lazy"
					/>
					<p>
						「そこまでシンプルには見えないよ」と思っていることでしょう。しかし仮に、<i>t</i>を取り去って係数に1を掛けることにしてしまえば、急激に簡単になります。これが二項係数部分の項です。
					</p>
					<!--
\usepackagexeCJK \xeCJKsetupCJKmath=true \setCJKmainfontipaexm.ttf
 
                                                           1次=  1 + 1           
                                                           2次=  1 + 2 + 1       
                                                           3次=  1 + 3 + 3 + 1   
                                                           4次= 1 + 4 + 6 + 4 + 1
-->
					<img
						class="LaTeX SVG"
						src="./images/chapters/explanation/6aa5d4e20e83be1c95eaad792517dde9.svg"
						width="163px"
						height="85px"
						loading="lazy"
					/>
					<p>
						2は1+1に等しく、3は2+1や1+2に等しく、6は3+3に等しく、……ということに注目してください。見てわかるように、先頭と末尾は単に1になっていますが、中間はどれも次数が増えるたびに「上の2つの数を足し合わせた」ものになっています。<i>これなら</i>覚えやいですね。
					</p>
					<p>
						多項式部分の項がどうなっているのか、同じぐらい簡単な方法で考えることができます。仮に、<i>(1-t)</i>を<i>a</i>に、<i>t</i>を<i>b</i>に書き換え、さらに重みを一旦削除してしまえば、このようになります。
					</p>
					<!--
     \usepackagexeCJK \xeCJKsetupCJKmath=true \setCJKmainfontipaexm.ttf
      
1次= \colorbluea + \colorredb                                                                                                                          
2次= \colorbluea  · \colorbluea + \colorbluea  · \colorredb + \colorredb  · \colorredb                                                                 
3次= \colorbluea  · \colorbluea  · \colorbluea + \colorbluea  · \colorbluea  · \colorredb + \colorbluea  · \colorredb  · \colorredb + \colorredb  · \co
                                                                                     
                                                                                     
                                                                lorredb  · \colorredb
-->
					<img
						class="LaTeX SVG"
						src="./images/chapters/explanation/9229934d71b0b02921bc92594ef11a98.svg"
						width="288px"
						height="61px"
						loading="lazy"
					/>
					<p>
						これは要するに、「<i>a</i>と<i>b</i>のすべての組み合わせ」の単なる和です。プラスが出てくるたびに、<i>a</i>を<i>b</i>へと1つずつ置き換えていけばよいのです。こちらも本当に単純です。さて、これで「二項係数多項式」がわかりました。完璧を期するため、この関数の一般の形を示しておきます。
					</p>
					<!--
\usepackagexeCJK \xeCJKsetupCJKmath=true \setCJKmainfontipaexm.ttf
 
                                __ n                                                                             n-i     i
                  Bézier(n,t) = ❯      \underset二項係数部分の項\underbrace\binomni  · \ \underset多項式部分の項\underbrace(1-t)     · t 
                                ‾‾ i=0
-->
					<img
						class="LaTeX SVG"
						src="./images/chapters/explanation/b5977078d36d847fb299cbe3e7e2c3ba.svg"
						width="321px"
						height="59px"
						loading="lazy"
					/>
					<p>
						そして、これがベジエ曲線の完全な表現です。この関数中のΣは、加算の繰り返し（Σの下にある変数を使って、...=&lt;値&gt;から始めてΣの下にある値まで）を表します。
					</p>
					<div class="howtocode">
						<h3>基底関数の実装方法</h3>
						<p>上で説明した関数を使えば、数学的な組み立て方で、基底関数をナイーブに実装することもできます。</p>

						<table class="code">
							<tr>
								<td>1</td>
								<td rowspan="5">
									<textarea disabled rows="5" role="doc-example">
function Bezier(n,t):
  sum = 0
  for(k=0; k<n; k++):
    sum += n!/(k!*(n-k)!) * (1-t)^(n-k) * t^(k)
  return sum</textarea
									>
								</td>
							</tr>
							<tr>
								<td>2</td>
							</tr>
							<tr>
								<td>3</td>
							</tr>
							<tr>
								<td>4</td>
							</tr>
							<tr>
								<td>5</td>
							</tr>
						</table>

						<p>
							「こともできる」と書いたのは、この方法では実装しない方が良いからです。階乗は<em>とてつもなく</em>重い計算なのです。また、先ほどの説明からわかるように、実際は階乗を使わなくても、かなり簡単にパスカルの三角形を作ることができます。[1]から始めて[1,1]、[1,2,1]、[1,3,3,1]、……としていくだけです。下の段は上の段よりも1つ要素が増え、各段の先頭と末尾は1になります。中間の数はどれも、左右斜め上にある両要素の和になります。
						</p>
						<p>
							このパスカルの三角形は、「リストのリスト」として瞬時に生成できます。そして、これをルックアップテーブルとして利用すれば、二項係数を計算する必要はまったくなくなります。
						</p>

						<table class="code">
							<tr>
								<td>1</td>
								<td rowspan="18">
									<textarea disabled rows="18" role="doc-example">
lut = [      [1],           // n=0
            [1,1],          // n=1
           [1,2,1],         // n=2
          [1,3,3,1],        // n=3
         [1,4,6,4,1],       // n=4
        [1,5,10,10,5,1],    // n=5
       [1,6,15,20,15,6,1]]  // n=6

binomial(n,k):
  while(n >= lut.length):
    s = lut.length
    nextRow = new array(size=s+1)
    nextRow[0] = 1
    for(i=1, prev=s-1; i<s; i++):
      nextRow[i] = lut[prev][i-1] + lut[prev][i]
    nextRow[s] = 1
    lut.add(nextRow)
  return lut[n][k]</textarea
									>
								</td>
							</tr>
							<tr>
								<td>2</td>
							</tr>
							<tr>
								<td>3</td>
							</tr>
							<tr>
								<td>4</td>
							</tr>
							<tr>
								<td>5</td>
							</tr>
							<tr>
								<td>6</td>
							</tr>
							<tr>
								<td>7</td>
							</tr>
							<tr>
								<td>8</td>
							</tr>
							<tr>
								<td>9</td>
							</tr>
							<tr>
								<td>10</td>
							</tr>
							<tr>
								<td>11</td>
							</tr>
							<tr>
								<td>12</td>
							</tr>
							<tr>
								<td>13</td>
							</tr>
							<tr>
								<td>14</td>
							</tr>
							<tr>
								<td>15</td>
							</tr>
							<tr>
								<td>16</td>
							</tr>
							<tr>
								<td>17</td>
							</tr>
							<tr>
								<td>18</td>
							</tr>
						</table>

						<p>
							これはどのように動くのでしょう？最初に、十分に大きなサイズのルックアップテーブルを宣言します。次に、求めたい値を得るための関数を定義します。この関数は、求めたい値のn/kのペアがテーブル中にまだ存在しない場合、先にテーブルを拡張するようになっています。さて、これで基底関数は次のようになりました。
						</p>

						<table class="code">
							<tr>
								<td>1</td>
								<td rowspan="5">
									<textarea disabled rows="5" role="doc-example">
function Bezier(n,t):
  sum = 0
  for(k=0; k<=n; k++):
    sum += binomial(n,k) * (1-t)^(n-k) * t^(k)
  return sum</textarea
									>
								</td>
							</tr>
							<tr>
								<td>2</td>
							</tr>
							<tr>
								<td>3</td>
							</tr>
							<tr>
								<td>4</td>
							</tr>
							<tr>
								<td>5</td>
							</tr>
						</table>

						<p>
							完璧です。もちろん、さらなる最適化を施すこともできます。コンピュータグラフィクス用途ではたいてい、任意の次数の曲線が必要になるわけではありません。2次と3次の曲線だけが必要であれば、以下のようにコードを劇的に単純化することができます（実際、この入門では任意の次数までは扱いませんので、これに似たようなコードが出てきます）。
						</p>

						<table class="code">
							<tr>
								<td>1</td>
								<td rowspan="13">
									<textarea disabled rows="13" role="doc-example">
function Bezier(2,t):
  t2 = t * t
  mt = 1-t
  mt2 = mt * mt
  return mt2 + 2*mt*t + t2

function Bezier(3,t):
  t2 = t * t
  t3 = t2 * t
  mt = 1-t
  mt2 = mt * mt
  mt3 = mt2 * mt
  return mt3 + 3*mt2*t + 3*mt*t2 + t3</textarea
									>
								</td>
							</tr>
							<tr>
								<td>2</td>
							</tr>
							<tr>
								<td>3</td>
							</tr>
							<tr>
								<td>4</td>
							</tr>
							<tr>
								<td>5</td>
							</tr>
							<tr>
								<td>6</td>
							</tr>
							<tr>
								<td>7</td>
							</tr>
							<tr>
								<td>8</td>
							</tr>
							<tr>
								<td>9</td>
							</tr>
							<tr>
								<td>10</td>
							</tr>
							<tr>
								<td>11</td>
							</tr>
							<tr>
								<td>12</td>
							</tr>
							<tr>
								<td>13</td>
							</tr>
						</table>

						<p>これで基底関数をプログラムする方法がわかりました。すばらしい。</p>
					</div>

					<p>というわけで、基底関数がどのようなものか理解できました。今度はベジエ曲線を特別にする魔法――制御点を導入する時間です。</p>
				</section>
				<section id="control">
					<h1>
						<div class="nav"><a href="ja-JP/index.html#explanation">previous</a><a href="ja-JP/index.html#weightcontrol">next</a></div>
						<a href="ja-JP/index.html#control">ベジエ曲線の曲率の制御</a>
					</h1>
					<p>
						ベジエ曲線は（すべての「スプライン」と同様に）補間関数です。これは点の集合を受け取って、それらの点のどこか「内側」の値を生成するということです。（このことから、制御点同士を結んで輪郭をつくったとき、その外側に位置する点は決して生成されないことがわかります。なお、この輪郭を曲線の「包」と呼びます。お役立ち情報でした！）実際に、補間関数によって生成された値に対する、各点の寄与の大きさを可視化することができますが、これを見れば、ベジエ曲線のどの場所でどの点が重要になるのかがわかります。
					</p>
					<p>
						下のグラフは、2次ベジエ曲線や3次ベジエ曲線の補間関数を表しています。ここでSは、ベジエ関数全体に対しての、その点の寄与の大きさを示します。ある<i>t</i>において、ベジエ曲線を定義する各点の補間率がどのようになっているのか、クリックドラッグをして確かめてみてください。
					</p>
					<div class="figure">
						<graphics-element title="2次の補間" width="275" height="275" src="./chapters/control/lerp.js" data-degree="3">
							<fallback-image>
								<span class="view-source">Scripts are disabled. Showing fallback image.</span>
								<img width="275px" height="275px" src="./images/chapters/control/f700cd59e6021b0e06b819105ec931da.png" loading="lazy" />
								<label>2次の補間</label>
							</fallback-image>
							<input type="range" min="0" max="1" step="0.01" value="0" class="slide-control" />
						</graphics-element>
						<graphics-element title="3次の補間" width="275" height="275" src="./chapters/control/lerp.js" data-degree="4">
							<fallback-image>
								<span class="view-source">Scripts are disabled. Showing fallback image.</span>
								<img width="275px" height="275px" src="./images/chapters/control/4b206c16ccf8a06a0834fe9e5254560c.png" loading="lazy" />
								<label>3次の補間</label>
							</fallback-image>
							<input type="range" min="0" max="1" step="0.01" value="0" class="slide-control" />
						</graphics-element>
						<graphics-element title="15次の補間" width="275" height="275" src="./chapters/control/lerp.js" data-degree="15">
							<fallback-image>
								<span class="view-source">Scripts are disabled. Showing fallback image.</span>
								<img width="275px" height="275px" src="./images/chapters/control/be82cd31c4892a8f0582b1b5285231d9.png" loading="lazy" />
								<label>15次の補間</label>
							</fallback-image>
							<input type="range" min="0" max="1" step="0.01" value="0" class="slide-control" />
						</graphics-element>
					</div>

					<p>
						あわせて、15次ベジエ関数における補間関数も示しています。始点と終点は他の制御点と比較して、曲線の形に対してかなり大きな影響を与えていることがわかります。
					</p>
					<p>
						曲線を変更したい場合は、各点の重みを変える（実質的には補間率を変える）必要があります。これはとても単純で、寄与の大きさを変えるための値を、各点にただ掛ければいいのです。この値は「重み」と呼ばれていますが、これを元のベジエ関数に組み込めば、次のようになります。
					</p>
					<!--
\usepackagexeCJK \xeCJKsetupCJKmath=true \setCJKmainfontipaexm.ttf
 
                 __ n                                                                             n-i     i
   Bézier(n,t) = ❯      \underset二項係数部分の項\underbrace\binomni  · \ \underset多項式部分の項\underbrace(1-t)     · t   · \ \underset重み\underbracew 
                 ‾‾ i=0                                                                                                                 i
-->
					<img class="LaTeX SVG" src="./images/chapters/control/9df7dc66b51db8e3046e1f359874c38e.svg" width="360px" height="59px" loading="lazy" />
					<p>
						複雑そうに見えますが、運がいいことに「重み」というのは実はただの座標値です。というのは<i>n</i>次の曲線の場合、w<sub>0</sub>が始点の座標、w<sub>n</sub>が終点の座標となり、その間はどれも制御点の座標になります。例えば、始点が(120,160)、制御点が(35,200)と(220,260)、終点が(220,40)となる3次ベジエ曲線は、次のようになります。
					</p>
					<!--
\setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
 
  ╭                              3                                  2                                            2                      3
  ╡ x = \colordarkred110  · (1-t)  + \colordarkgreen25  · 3  · (1-t)   · t + \colordarkblue210  · 3  · (1-t)  · t  + \coloramber210  · t  
  │                              3                                   2                                            2                     3
  ╰ y = \colordarkred150  · (1-t)  + \colordarkgreen190  · 3  · (1-t)   · t + \colordarkblue250  · 3  · (1-t)  · t  + \coloramber30  · t 
-->
					<img class="LaTeX SVG" src="./images/chapters/control/20b0be6397fbd726298de6ec70a8544b.svg" width="473px" height="40px" loading="lazy" />
					<p>この式からは、記事の冒頭に出てきた曲線が得られます。</p>
					<Graphic title="あの3次ベジエ曲線" setup="{this.drawCubic}" draw="{this.drawCurve}" />

					<p>
						ベジエ曲線で、他にはどんなことができるでしょうか？実は、非常にたくさんのことが可能です。この記事の残りの部分では、実現可能な各種操作や適用可能なアルゴリズム、そしてこれによって達成できるタスクについて扱います。
					</p>
					<div class="howtocode">
						<h3>重みつき基底関数の実装方法</h3>
						<p>基底関数の実装方法はすでに知っていますし、これに制御点を組み込むのは非常に簡単です。</p>

						<table class="code">
							<tr>
								<td>1</td>
								<td rowspan="5">
									<textarea disabled rows="5" role="doc-example">
function Bezier(n,t,w[]):
  sum = 0
  for(k=0; k<n; k++):
    sum += w[k] * binomial(n,k) * (1-t)^(n-k) * t^(k)
  return sum</textarea
									>
								</td>
							</tr>
							<tr>
								<td>2</td>
							</tr>
							<tr>
								<td>3</td>
							</tr>
							<tr>
								<td>4</td>
							</tr>
							<tr>
								<td>5</td>
							</tr>
						</table>

						<p>そして、最適化を行ったバージョンは以下のようになります。</p>

						<table class="code">
							<tr>
								<td>1</td>
								<td rowspan="13">
									<textarea disabled rows="13" role="doc-example">
function Bezier(2,t,w[]):
  t2 = t * t
  mt = 1-t
  mt2 = mt * mt
  return w[0]*mt2 + w[1]*2*mt*t + w[2]*t2

function Bezier(3,t,w[]):
  t2 = t * t
  t3 = t2 * t
  mt = 1-t
  mt2 = mt * mt
  mt3 = mt2 * mt
  return w[0]*mt3 + 3*w[1]*mt2*t + 3*w[2]*mt*t2 + w[3]*t3</textarea
									>
								</td>
							</tr>
							<tr>
								<td>2</td>
							</tr>
							<tr>
								<td>3</td>
							</tr>
							<tr>
								<td>4</td>
							</tr>
							<tr>
								<td>5</td>
							</tr>
							<tr>
								<td>6</td>
							</tr>
							<tr>
								<td>7</td>
							</tr>
							<tr>
								<td>8</td>
							</tr>
							<tr>
								<td>9</td>
							</tr>
							<tr>
								<td>10</td>
							</tr>
							<tr>
								<td>11</td>
							</tr>
							<tr>
								<td>12</td>
							</tr>
							<tr>
								<td>13</td>
							</tr>
						</table>

						<p>これで、重みつき基底関数をプログラムする方法がわかりました。</p>
					</div>
				</section>
				<section id="weightcontrol">
					<h1>
						<div class="nav"><a href="ja-JP/index.html#control">previous</a><a href="ja-JP/index.html#extended">next</a></div>
						<a href="ja-JP/index.html#weightcontrol">Controlling Bézier curvatures, part 2: Rational Béziers</a>
					</h1>
					<p>
						We can further control Bézier curves by "rationalising" them: that is, adding a "ratio" value in addition to the weight value discussed in
						the previous section, thereby gaining control over "how strongly" each coordinate influences the curve.
					</p>
					<p>Adding these ratio values to the regular Bézier curve function is fairly easy. Where the regular function is the following:</p>
					<!--
\setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
 
                                                          __ n                    n-i     i
                                            Bézier(n,t) = ❯      \binomni  · (1-t)     · t   · w 
                                                          ‾‾ i=0                                i
-->
					<img
						class="LaTeX SVG"
						src="./images/chapters/weightcontrol/85d526fb17f9e859dcd7d40d22192e37.svg"
						width="276px"
						height="41px"
						loading="lazy"
					/>
					<p>The function for rational Bézier curves has two more terms:</p>
					<!--
\setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
 
                                                    __ n                    n-i     i
                                                    ❯      \binomni  · (1-t)     · t   · w   · \colorblueratio 
                                                    ‾‾ i=0                                i                   i
                            Rational  Bézier(n,t) = ───────────────────────────────────────────────────────────
                                                                __ n                     n-i      i
                                                    \colorblue  ❯      \binomni  ·  (1-t)     ·  t   ·  ratio  
                                                                ‾‾ i=0                                       i
-->
					<img
						class="LaTeX SVG"
						src="./images/chapters/weightcontrol/2ec04091c55fe31bf85ac28c5b6d95cb.svg"
						width="409px"
						height="48px"
						loading="lazy"
					/>
					<p>
						In this, the first new term represents an additional weight for each coordinate. For example, if our ratio values are [1, 0.5, 0.5, 1]
						then <code>ratio<sub>0</sub> = 1</code>, <code>ratio<sub>1</sub> = 0.5</code>, and so on, and is effectively identical as if we were just
						using different weight. So far, nothing too special.
					</p>
					<p>
						However, the second new term is what makes the difference: every point on the curve isn't just a "double weighted" point, it is a
						<em>fraction</em> of the "doubly weighted" value we compute by introducing that ratio. When computing points on the curve, we compute the
						"normal" Bézier value and then <em>divide</em> that by the Bézier value for the curve that only uses ratios, not weights.
					</p>
					<p>
						This does something unexpected: it turns our polynomial into something that <em>isn't</em> a polynomial anymore. It is now a kind of curve
						that is a super class of the polynomials, and can do some really cool things that Bézier curves can't do "on their own", such as perfectly
						describing circles (which we'll see in a later section is literally impossible using standard Bézier curves).
					</p>
					<p>
						But the best way to show what this does is to do literally that: let's look at the effect of "rationalising" our Bézier curves using an
						interactive graphic for a rationalised curves. The following graphic shows the Bézier curve from the previous section, "enriched" with
						ratio factors for each coordinate. The closer to zero we set one or more terms, the less relative influence the associated coordinate
						exerts on the curve (and of course the higher we set them, the more influence they have). Try to change the values and see how it affects
						what gets drawn:
					</p>
					<graphics-element title="Our rational cubic Bézier curve" width="275" height="275" src="./chapters/weightcontrol/rational.js">
						<fallback-image>
							<span class="view-source">Scripts are disabled. Showing fallback image.</span>
							<img width="275px" height="275px" src="./images/chapters/weightcontrol/3d71e2b9373684eebcb0dc8563f70b18.png" loading="lazy" />
							<label>Our rational cubic Bézier curve</label>
						</fallback-image>
						<input type="range" min="0.01" max="2" value="1" step="0.01" class="ratio-1" />
						<input type="range" min="0.01" max="2" value="1" step="0.01" class="ratio-2" />
						<input type="range" min="0.01" max="2" value="1" step="0.01" class="ratio-3" />
						<input type="range" min="0.01" max="2" value="1" step="0.01" class="ratio-4" />
					</graphics-element>
					<p>
						You can think of the ratio values as each coordinate's "gravity": the higher the gravity, the closer to that coordinate the curve will
						want to be. You'll also notice that if you simply increase or decrease all the ratios by the same amount, nothing changes... much like
						with gravity, if the relative strengths stay the same, nothing really changes. The values define each coordinate's influence
						<em>relative to all other points</em>.
					</p>
					<div class="howtocode">
						<h3>How to implement rational curves</h3>
						<p>Extending the code of the previous section to include ratios is almost trivial:</p>

						<table class="code">
							<tr>
								<td>1</td>
								<td rowspan="26">
									<textarea disabled rows="26" role="doc-example">
function RationalBezier(2,t,w[],r[]):
  t2 = t * t
  mt = 1-t
  mt2 = mt * mt
  f = [
    r[0] * mt2,
    2 * r[1] * mt * t,
    r[2] * t2
  ]
  basis = f[0] + f[1] + f[2]
  return (f[0] * w[0] + f[1] * w[1] + f[2] * w[2])/basis

function RationalBezier(3,t,w[],r[]):
  t2 = t * t
  t3 = t2 * t
  mt = 1-t
  mt2 = mt * mt
  mt3 = mt2 * mt
  f = [
    r[0] * mt3,
    3 * r[1] * mt2 * t,
    3 * r[2] * mt * t2,
    r[3] * t3
  ]
  basis = f[0] + f[1] + f[2] + f[3]
  return (f[0] * w[0] + f[1] * w[1] + f[2] * w[2] + f[3] * w[3])/basis</textarea
									>
								</td>
							</tr>
							<tr>
								<td>2</td>
							</tr>
							<tr>
								<td>3</td>
							</tr>
							<tr>
								<td>4</td>
							</tr>
							<tr>
								<td>5</td>
							</tr>
							<tr>
								<td>6</td>
							</tr>
							<tr>
								<td>7</td>
							</tr>
							<tr>
								<td>8</td>
							</tr>
							<tr>
								<td>9</td>
							</tr>
							<tr>
								<td>10</td>
							</tr>
							<tr>
								<td>11</td>
							</tr>
							<tr>
								<td>12</td>
							</tr>
							<tr>
								<td>13</td>
							</tr>
							<tr>
								<td>14</td>
							</tr>
							<tr>
								<td>15</td>
							</tr>
							<tr>
								<td>16</td>
							</tr>
							<tr>
								<td>17</td>
							</tr>
							<tr>
								<td>18</td>
							</tr>
							<tr>
								<td>19</td>
							</tr>
							<tr>
								<td>20</td>
							</tr>
							<tr>
								<td>21</td>
							</tr>
							<tr>
								<td>22</td>
							</tr>
							<tr>
								<td>23</td>
							</tr>
							<tr>
								<td>24</td>
							</tr>
							<tr>
								<td>25</td>
							</tr>
							<tr>
								<td>26</td>
							</tr>
						</table>

						<p>And that's all we have to do.</p>
					</div>
				</section>
				<section id="extended">
					<h1>
						<div class="nav"><a href="ja-JP/index.html#weightcontrol">previous</a><a href="ja-JP/index.html#matrix">next</a></div>
						<a href="ja-JP/index.html#extended">ベジエ曲線の区間 [0,1]</a>
					</h1>
					<p>
						ここまでの説明で、ベジエ曲線の裏側にある数学がわかりました。しかし、気づいているかもしれませんが、ひとつ引っかかる点があります。ベジエ曲線はいつも<code>t=0</code>から<code>t=1</code>の間を動いていますが、どうしてこの特定の区間なのでしょう？
					</p>
					<p>
						このことは、曲線の「始点」から曲線の「終点」までどうやって動かすか、ということにすべて関係しています。2つの値を混ぜ合わせて1つの値をつくる場合、一般の式は次のようになります。
					</p>
					<!--
\usepackagexeCJK \xeCJKsetupCJKmath=true \setCJKmainfontipaexm.ttf
 
                                                        混ぜ合わさった値 = a  · 値  + b  · 値 
                                                                         1         2
-->
					<img class="LaTeX SVG" src="./images/chapters/extended/b0eb0b24e7fa29c545ab1479d2df0554.svg" width="252px" height="20px" loading="lazy" />
					<p>
						明らかに、始点では<code>a=1, b=0</code>とする必要があります。こうすれば、値1が100%、値2が0%で混ぜ合わさるからです。また、終点では<code
							>a=0, b=1</code
						>とする必要があります。こうすれば、値1が0%、値2が100%で混ぜ合わさります。これに加えて、<code>a</code>と<code>b</code>を独立にしておきたくはありません。独立になっている場合、何でも好きな値にすることできますが、こうすると例えば「値1が100%<strong>かつ</strong>値2が100%」のようなことが可能になってしまいます。これはこれで原則としてはかまいませんが、ベジエ曲線の場合は混ぜ合わさった値が常に始点と終点の<em>間</em>になってほしいのです。というわけで、混ぜ合わせの和が100%を決して超えないように、<code>a</code>と<code>b</code>の値を設定する必要があります。これは次のようにすれば簡単です。
					</p>
					<!--
\usepackagexeCJK \xeCJKsetupCJKmath=true \setCJKmainfontipaexm.ttf
 
                                                     混ぜ合わさった値 = a  · 値  + (1 - a)  · 値 
                                                                      1               2
-->
					<img class="LaTeX SVG" src="./images/chapters/extended/fd520a6e2c7f39e90496e5cf494cce2e.svg" width="293px" height="20px" loading="lazy" />
					<p>
						こうすれば、和が100%を超えることはないと保証できます。<code>a</code>の値を区間[0,1]に制限してしまえば、混ぜ合わさった値は常に2つの値の間のどこか（両端を含む）になり、また和は常に100%になります。
					</p>
					<p>
						しかし……この式を0と1の間の値だけで使うのではなく、もし仮にこの区間の外の値で使うとしたら、どうなるのでしょう？めちゃくちゃになってしまうのでしょうか？……実はそうではありません。「その先」が見えるのです。
					</p>
					<p>
						ベジエ曲線の場合、区間を広げると曲線は単純に「そのまま延びて」いきます。ベジエ曲線はある多項式曲線の一部分にすぎませんので、単純に区間を広くとればとるほど、曲線のより多くの部分が現れるようになります。では、どのように見えるのでしょうか？
					</p>
					<p>
						下の2つの図は「いつもの方法」で描いたベジエ曲線ですが、これと一緒に、<code>t</code>の値をずっと先まで広げた場合の「延びた」ベジエ曲線も表示しています。見てわかるように、曲線の残りの部分には多くの「かたち」が隠れています。そして曲線の点を動かせば、その部分の形状も変わります。
					</p>
					<div class="figure">
						<graphics-element title="無限区間の2次ベジエ曲線" width="275" height="275" src="./chapters/extended/extended.js" data-type="quadratic">
							<fallback-image>
								<span class="view-source">Scripts are disabled. Showing fallback image.</span>
								<img width="275px" height="275px" src="./images/chapters/extended/37948bde4bf0d25bde85f172bf55b9fb.png" loading="lazy" />
								<label>無限区間の2次ベジエ曲線</label>
							</fallback-image></graphics-element
						>
						<graphics-element title="無限区間の3次ベジエ曲線" width="275" height="275" src="./chapters/extended/extended.js" data-type="cubic">
							<fallback-image>
								<span class="view-source">Scripts are disabled. Showing fallback image.</span>
								<img width="275px" height="275px" src="./images/chapters/extended/2d17acb381ebdd28f0ff43be00d723c4.png" loading="lazy" />
								<label>無限区間の3次ベジエ曲線</label>
							</fallback-image></graphics-element
						>
					</div>

					<p>
						実際に、グラフィックデザインやコンピュータモデリングで使われている曲線の中には、座標が固定されていて、区間は自由に動かせるような曲線があります。これは、区間が固定されていて、座標を自由に動かすことのできるベジエ曲線とは反対になっています。すばらしい例が<a
							href="https://levien.com/phd/phd.html"
							>「Spiro」曲線</a
						>で、これは<a href="https://ja.wikipedia.org/wiki/%E3%82%AF%E3%83%AD%E3%82%BD%E3%82%A4%E3%83%89%E6%9B%B2%E7%B7%9A"
							>オイラー螺旋とも呼ばれるクロソイド曲線</a
						>の一部分に基づいた曲線です。非常に美しく心地よい曲線で、<a href="https://fontforge.org/en-US/">FontForge</a>や<a
							href="https://inkscape.org/ja/"
							>Inkscape</a
						>など多くのグラフィックアプリに実装されており、フォントデザインにも利用されています（Inconsolataフォントなど）。
					</p>
				</section>
				<section id="matrix">
					<h1>
						<div class="nav"><a href="ja-JP/index.html#extended">previous</a><a href="ja-JP/index.html#decasteljau">next</a></div>
						<a href="ja-JP/index.html#matrix">行列演算としてのベジエ曲線の曲率</a>
					</h1>
					<p>
						ベジエ曲線は、行列演算の形でも表現することができます。ベジエ曲線の式を多項式基底と係数行列で表し、実際の座標も行列として表現するのです。これがどういうことを意味しているのか、3次ベジエ曲線について見てみましょう。
					</p>
					<!--
\setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
 
                                                3                   2                             2          3
                              B(t) = P   · (1-t)  + P   · 3  · (1-t)   · t + P   · 3  · (1-t)  · t  + P   · t 
                                      1              2                        3                        4
-->
					<img class="LaTeX SVG" src="./images/chapters/matrix/9a9a55f5b0323d9ea88f82fc6be58ad3.svg" width="468px" height="20px" loading="lazy" />
					<p>実際の座標を一旦無視すると、次のようになります。</p>
					<!--
\setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
 
                                                      3             2                       2    3
                                          B(t) = (1-t)  + 3  · (1-t)   · t + 3  · (1-t)  · t  + t 
-->
					<img class="LaTeX SVG" src="./images/chapters/matrix/87cfac83cb8a4b0bee68ef006effc611.svg" width="353px" height="19px" loading="lazy" />
					<p>これは、4つの項の和になっています。</p>
					<!--
\setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
 
                                                                           3
                                                           ... =      (1-t) 
                                                                           2
                                                               + 3  · (1-t)   · t
                                                                                2
                                                               + 3  · (1-t)  · t 
                                                                        3
                                                               +       t  
-->
					<img class="LaTeX SVG" src="./images/chapters/matrix/cdd88611833f3b178df91278359a4193.svg" width="140px" height="75px" loading="lazy" />
					<p>それぞれの項を展開します。</p>
					<!--
\setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
 
                                                                           3         2
                                        ... =  (1-t)  · (1-t)  · (1-t) = -t  + 3  · t  - 3  · t + 1
                                                                               3         2
                                            + 3  · (1-t)  · (1-t)  · t = 3  · t  - 6  · t  + 3  · t
                                                                                    3         2
                                            +   3  · (1-t)  · t  · t   =     -3  · t  + 3  · t 
                                                                                     3
                                            +        t  · t  · t       =            t  
-->
					<img class="LaTeX SVG" src="./images/chapters/matrix/ec118f296511c6e9ac8727be3703a7ce.svg" width="397px" height="75px" loading="lazy" />
					<p>その上で、係数の0や1もすべて明示的に書けば、このようになります。</p>
					<!--
\setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
 
                                                                3         2
                                                   ... = -1  · t  + 3  · t  - 3  · t + 1
                                                                3         2
                                                       + +3  · t  - 6  · t  + 3  · t + 0 
                                                                3         2
                                                       + -3  · t  + 3  · t  + 0  · t + 0
                                                                3         2
                                                       + +1  · t  + 0  · t  + 0  · t + 0 
-->
					<img class="LaTeX SVG" src="./images/chapters/matrix/67a5ea33d6c6558f7d954b18226f4956.svg" width="217px" height="75px" loading="lazy" />
					<p><em>さらに</em>、これは4つの行列演算の和として見ることができます。</p>
					<!--
\setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
 
                                     ┌ -1 ┐                    ┌ 3  ┐                    ┌ -3 ┐                    ┌ 1 ┐
                    ┌  3  2     ┐  · │ 3  │ + ┌  3  2     ┐  · │ -6 │ + ┌  3  2     ┐  · │ 3  │ + ┌  3  2     ┐  · │ 0 │
                    └ t  t  t 1 ┘    │ -3 │   └ t  t  t 1 ┘    │ 3  │   └ t  t  t 1 ┘    │ 0  │   └ t  t  t 1 ┘    │ 0 │
                                     └ 1  ┘                    └ 0  ┘                    └ 0  ┘                    └ 0 ┘
-->
					<img class="LaTeX SVG" src="./images/chapters/matrix/8ecff6b8a37d60385d287ea2b26876db.svg" width="607px" height="72px" loading="lazy" />
					<p>これを1つの行列演算にまとめると、以下のようになります。</p>
					<!--
\setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
 
                                                                       ┌ -1  3 -3 1 ┐
                                                      ┌  3  2     ┐  · │  3 -6  3 0 │
                                                      └ t  t  t 1 ┘    │ -3  3  0 0 │
                                                                       └  1  0  0 0 ┘
-->
					<img class="LaTeX SVG" src="./images/chapters/matrix/b9527f7d5a0f5d2d737eac118d69243e.svg" width="227px" height="72px" loading="lazy" />
					<p>
						多項式基底をこのような形で表現する場合、通常はその基底を昇冪の順に並べます。したがって、<code>t</code>の行列を左右反転させ、大きな「混合」行列は上下に反転させる必要があります。
					</p>
					<!--
\setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
 
                                                                       ┌  1  0  0 0 ┐
                                                      ┌      2  3 ┐  · │ -3  3  0 0 │
                                                      └ 1 t t  t  ┘    │  3 -6  3 0 │
                                                                       └ -1  3 -3 1 ┘
-->
					<img class="LaTeX SVG" src="./images/chapters/matrix/1a64ed455c6dd2f8cacca5e5e12bdcc1.svg" width="227px" height="72px" loading="lazy" />
					<p>そして最後に、もともとあった座標を3番目の行列として付け加えます。</p>
					<!--
\setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
 
                                                                                        ┌ P  ┐
                                                                                        │  1 │
                                                                      ┌  1  0  0 0 ┐    │ P  │
                                              B(t) = ┌      2  3 ┐  · │ -3  3  0 0 │  · │  2 │
                                                     └ 1 t t  t  ┘    │  3 -6  3 0 │    │ P  │
                                                                      └ -1  3 -3 1 ┘    │  3 │
                                                                                        │ P  │
                                                                                        └  4 ┘
-->
					<img class="LaTeX SVG" src="./images/chapters/matrix/b32cae2dfc47d5f36df0bc3defb7dfa8.svg" width="323px" height="73px" loading="lazy" />
					<p>2次ベジエ曲線の場合も同様に変形することができ、最終的には以下のようになります。</p>
					<!--
\setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
 
                                                                                     ┌ P  ┐
                                                                      ┌  1  0 0 ┐    │  1 │
                                                 B(t) = ┌      2 ┐  · │ -2  2 0 │  · │ P  │
                                                        └ 1 t t  ┘    └  1 -2 1 ┘    │  2 │
                                                                                     │ P  │
                                                                                     └  3 ┘
-->
					<img class="LaTeX SVG" src="./images/chapters/matrix/1bae50fefa43210b3a6259d1984f6cbc.svg" width="263px" height="55px" loading="lazy" />
					<p>
						<code>t</code
						>の値を代入して行列の乗算を行えば、もともとの多項式関数から計算したときの値や、線形補間によって順次求めたときの値と、まったく同じものが得られます。
					</p>
					<p>
						<strong>では、なぜわざわざ行列を使うのでしょう？</strong>
						行列表現を使うことによって、他の表現ではわからなかった関数の性質を発見できるようになります。ベジエ曲線は<a
							href="https://ja.wikipedia.org/wiki/%E4%B8%89%E8%A7%92%E8%A1%8C%E5%88%97"
							>三角行列</a
						>の形になり、その行列式は実際の座標の積に等しくなることがわかります。また、この行列には逆行列が存在しますが、これは<a
							href="https://ja.wikipedia.org/wiki/%E6%AD%A3%E5%89%87%E8%A1%8C%E5%88%97#.E7.89.B9.E5.BE.B4.E3.81.A5.E3.81.91"
							>さまざまな性質</a
						>が満たされることを意味します。もっとも、疑問の中心は「それでなぜこれが役に立つのか？」という点でしょうが、「ただちには役に立たない」というのが回答です。しかしながら、この先に出てくる曲線のプロパティの中には、関数を操作して求めることも、また行列をうまいこと利用して求めることも、どちらでも可能な例があります。そしてときには、行列による手法の方が（劇的に）速くなる場合があるのです。
					</p>
					<p>というわけで、現時点では「ベジエ曲線は行列で表現可能」ということだけを覚えて、次に進みましょう。</p>
				</section>
				<section id="decasteljau">
					<h1>
						<div class="nav"><a href="ja-JP/index.html#matrix">previous</a><a href="ja-JP/index.html#flattening">next</a></div>
						<a href="ja-JP/index.html#decasteljau">ド・カステリョのアルゴリズム</a>
					</h1>
					<p>
						ベジエ曲線を描く場合は、<code>t</code>の値を0から1まで動かしながら重みつき基底関数を計算し、プロットに必要な<code>x/y</code>の値を求めます。しかし、曲線が複雑になればなるほど、計算コストがかかるようになってしまいます。そこでその代わりに、「ド・カステリョのアルゴリズム」を使って曲線を描くこともできます。こちらは幾何学的に曲線を描く方法で、実装も非常に簡単です。実際、鉛筆と定規を使って手描きすることもできるほど、とても簡単な方法なのです。
					</p>
					<p><code>x/y</code>の値を求めるために関数を使うのではなく、次のようにします。</p>
					<ul>
						<li><code>t</code>を（そのまま）比率として考えます。t=0は直線上の0%の位置、t=1は100%の位置です。</li>
						<li>曲線を定める点同士を結ぶように、それぞれ直線を引きます。<code>n</code>次の曲線であれば、<code>n</code>本の直線を引きます。</li>
						<li>
							各直線上において、距離が<code>t</code>となる点にそれぞれ印をつけます。例えば<code>t</code>が0.2なら、始点から20%、終点から80%の位置になります。
						</li>
						<li>今度は、<code>それらの</code>点同士を直線で結びます。<code>n-1</code>本の直線が得られます。</li>
						<li>各直線上において、距離が<code>t</code>となる点にそれぞれ印をつけます。</li>
						<li><code>それらの</code>点同士を直線で結びます。<code>n-2</code>本の直線が得られます。</li>
						<li>印をつけ、直線で結び、印をつけ、……</li>
						<li>1本の直線になるまで繰り返します。その直線上の<code>t</code>の点は、元の曲線上で<code>t</code>となる点に一致しています。</li>
					</ul>
					<p>
						下の図にマウスを乗せると、この様子を実際に見ることができます。ド・カステリョのアルゴリズムによって曲線上の点を明示的に計算していますが、マウスを動かすと求める点が変わります。マウスカーソルを左から右へ（もちろん、右から左へでも）動かせば、このアルゴリズムによって曲線が生成される様子がわかります。
					</p>
					<graphics-element title="ド・カステリョのアルゴリズムで曲線をたどる" width="275" height="275" src="./chapters/decasteljau/decasteljau.js">
						<fallback-image>
							<span class="view-source">Scripts are disabled. Showing fallback image.</span>
							<img width="275px" height="275px" src="./images/chapters/decasteljau/df92f529841f39decf9ad62b0967855a.png" loading="lazy" />
							<label>ド・カステリョのアルゴリズムで曲線をたどる</label>
						</fallback-image>
						<input type="range" min="0" max="1" step="0.01" value="0" class="slide-control" />
					</graphics-element>
					<div class="howtocode">
						<h3>ド・カステリョのアルゴリズムの実装方法</h3>
						<p>いま説明したアルゴリズムを実装すると、以下のようになります。</p>

						<table class="code">
							<tr>
								<td>1</td>
								<td rowspan="8">
									<textarea disabled rows="8" role="doc-example">
function drawCurve(points[], t):
  if(points.length==1):
    draw(points[0])
  else:
    newpoints=array(points.size-1)
    for(i=0; i<newpoints.length; i++):
      newpoints[i] = (1-t) * points[i] + t * points[i+1]
    drawCurve(newpoints, t)</textarea
									>
								</td>
							</tr>
							<tr>
								<td>2</td>
							</tr>
							<tr>
								<td>3</td>
							</tr>
							<tr>
								<td>4</td>
							</tr>
							<tr>
								<td>5</td>
							</tr>
							<tr>
								<td>6</td>
							</tr>
							<tr>
								<td>7</td>
							</tr>
							<tr>
								<td>8</td>
							</tr>
						</table>

						<p>
							これで実装完了です。ただし、+演算子のオーバーロードなどという贅沢品はたいてい無いでしょうから、<code>x</code>や<code>y</code>の値を直接扱う場合のコードも示しておきます。
						</p>

						<table class="code">
							<tr>
								<td>1</td>
								<td rowspan="10">
									<textarea disabled rows="10" role="doc-example">
function drawCurve(points[], t):
  if(points.length==1):
    draw(points[0])
  else:
    newpoints=array(points.size-1)
    for(i=0; i<newpoints.length; i++):
      x = (1-t) * points[i].x + t * points[i+1].x
      y = (1-t) * points[i].y + t * points[i+1].y
      newpoints[i] = new point(x,y)
    drawCurve(newpoints, t)</textarea
									>
								</td>
							</tr>
							<tr>
								<td>2</td>
							</tr>
							<tr>
								<td>3</td>
							</tr>
							<tr>
								<td>4</td>
							</tr>
							<tr>
								<td>5</td>
							</tr>
							<tr>
								<td>6</td>
							</tr>
							<tr>
								<td>7</td>
							</tr>
							<tr>
								<td>8</td>
							</tr>
							<tr>
								<td>9</td>
							</tr>
							<tr>
								<td>10</td>
							</tr>
						</table>

						<p>
							さて、これは何をしているのでしょう？関数に渡す点のリストが長さ1であれば、点を1つ描きます。それ以外であれば、比率<i>t</i>の位置の点（すなわち、さきほどの説明に出てきた「印」）のリストを作り、そしてこの新しいリストを引数にして関数を呼び出します。
						</p>
					</div>
				</section>
				<section id="flattening">
					<h1>
						<div class="nav"><a href="ja-JP/index.html#decasteljau">previous</a><a href="ja-JP/index.html#splitting">next</a></div>
						<a href="ja-JP/index.html#flattening">簡略化した描画</a>
					</h1>
					<p>
						曲線を複数点で「サンプリング」し、さらにそれを直線で繫げてしまえば、描画の手順を簡略化することができます。単なる一連の直線、つまり「平坦」な線へと曲線を単純化するので、この処理は「平坦化」という名前で知られています。
					</p>
					<p>
						例えば「X個の線分がほしい」場合には、分割数がそうなるようにサンプリング間隔を選び、曲線をサンプリングします。この方法の利点は速さです。曲線の座標を100個だの1000個だの計算するのではなく、ずっと少ない回数のサンプリングでも、十分きれいに見えるような曲線を作ることができるのです。欠点はもちろん、「本物の曲線」に比べて精度が損なわれてしまうことです。したがって、交点の検出や曲線の位置揃えを正しく行いたい場合には、平坦化した曲線は普通利用できません。
					</p>
					<div class="figure">
						<graphics-element title="2次ベジエ曲線の平坦化" width="275" height="275" src="./chapters/flattening/flatten.js" data-type="quadratic">
							<fallback-image>
								<span class="view-source">Scripts are disabled. Showing fallback image.</span>
								<img width="275px" height="275px" src="./images/chapters/flattening/6813bfc608aea11df1dda444b9f18123.png" loading="lazy" />
								<label>2次ベジエ曲線の平坦化</label>
							</fallback-image>
							<input type="range" min="1" max="16" step="1" value="4" class="slide-control" />
						</graphics-element>
						<graphics-element title="3次ベジエ曲線の平坦化" width="275" height="275" src="./chapters/flattening/flatten.js" data-type="cubic">
							<fallback-image>
								<span class="view-source">Scripts are disabled. Showing fallback image.</span>
								<img width="275px" height="275px" src="./images/chapters/flattening/0e0e4a2ee46bd89bcfde9f75cfe43292.png" loading="lazy" />
								<label>3次ベジエ曲線の平坦化</label>
							</fallback-image>
							<input type="range" min="1" max="24" step="1" value="8" class="slide-control" />
						</graphics-element>
					</div>

					<p>
						2次ベジエ曲線も3次ベジエ曲線も、図をクリックして上下キーを押すと曲線の分割数が増減しますので、試してみてください。ある曲線では分割数が少なくてもうまくいきますが、曲線が複雑になればなるほど、曲率の変化を正確に捉えるためにはより多くの分割数が必要になることがわかります（3次ベジエ曲線で試してみてください）。
					</p>
					<div class="howtocode">
						<h3>曲線平坦化の実装方法</h3>
						<p>上でいま解説したアルゴリズムを使って実装するだけです。</p>

						<table class="code">
							<tr>
								<td>1</td>
								<td rowspan="7">
									<textarea disabled rows="7" role="doc-example">
function flattenCurve(curve, segmentCount):
  step = 1/segmentCount;
  coordinates = [curve.getXValue(0), curve.getYValue(0)]
  for(i=1; i <= segmentCount; i++):
    t = i*step;
    coordinates.push[curve.getXValue(t), curve.getYValue(t)]
  return coordinates;</textarea
									>
								</td>
							</tr>
							<tr>
								<td>2</td>
							</tr>
							<tr>
								<td>3</td>
							</tr>
							<tr>
								<td>4</td>
							</tr>
							<tr>
								<td>5</td>
							</tr>
							<tr>
								<td>6</td>
							</tr>
							<tr>
								<td>7</td>
							</tr>
						</table>

						<p>これで完了です。実装できました。あとは、一連の直線で結果の「曲線」を描画するだけです。</p>

						<table class="code">
							<tr>
								<td>1</td>
								<td rowspan="7">
									<textarea disabled rows="7" role="doc-example">
function drawFlattenedCurve(curve, segmentCount):
  coordinates = flattenCurve(curve, segmentCount)
  coord = coordinates[0], _coord;
  for(i=1; i < coordinates.length; i++):
    _coord = coordinates[i]
    line(coord, _coord)
    coord = _coord</textarea
									>
								</td>
							</tr>
							<tr>
								<td>2</td>
							</tr>
							<tr>
								<td>3</td>
							</tr>
							<tr>
								<td>4</td>
							</tr>
							<tr>
								<td>5</td>
							</tr>
							<tr>
								<td>6</td>
							</tr>
							<tr>
								<td>7</td>
							</tr>
						</table>

						<p>先頭の座標を参照点にしてスタートし、あとはそれぞれの点からその次の点へと、直線を引いていくだけです。</p>
					</div>
				</section>
				<section id="splitting">
					<h1>
						<div class="nav"><a href="ja-JP/index.html#flattening">previous</a><a href="ja-JP/index.html#matrixsplit">next</a></div>
						<a href="ja-JP/index.html#splitting">曲線の分割</a>
					</h1>
					<p>
						ベジエ曲線を分割して、繫ぎ合わせたときに元に戻るような小さい2曲線にしたい場合にも、ド・カステリョのアルゴリズムを使えば、これに必要な点をすべて求めることができます。ある値<code>t</code>に対してド・カステリョの骨格を組み立てると、その<code>t</code>で曲線を分割する際に必要になる点がすべて得られます。骨格内部の点のうち、曲線上の点から見て手前側にある点によって一方の曲線が定義され、向こう側にある点によってもう一方の曲線が定義されます。
					</p>
					<graphics-element title="曲線の分割" width="825" height="275" src="./chapters/splitting/splitting.js">
						<fallback-image>
							<span class="view-source">Scripts are disabled. Showing fallback image.</span>
							<img width="825px" height="275px" src="./images/chapters/splitting/fce5eb16dfcd103797c5e17bd77f1437.png" loading="lazy" />
							<label></label>
						</fallback-image>
						<input type="range" min="0" max="1" step="0.01" value="0.5" class="slide-control" />
					</graphics-element>
					<div class="howtocode">
						<h3>曲線分割の実装方法</h3>
						<p>ド・カステリョの関数の中に記録する処理を追加すれば、曲線の分割が実装できます。</p>

						<table class="code">
							<tr>
								<td>1</td>
								<td rowspan="16">
									<textarea disabled rows="16" role="doc-example">
left=[]
right=[]
function drawCurve(points[], t):
  if(points.length==1):
    left.add(points[0])
    right.add(points[0])
    draw(points[0])
  else:
    newpoints=array(points.size-1)
    for(i=0; i<newpoints.length; i++):
      if(i==0):
        left.add(points[i])
      if(i==newpoints.length-1):
        right.add(points[i+1])
      newpoints[i] = (1-t) * points[i] + t * points[i+1]
    drawCurve(newpoints, t)</textarea
									>
								</td>
							</tr>
							<tr>
								<td>2</td>
							</tr>
							<tr>
								<td>3</td>
							</tr>
							<tr>
								<td>4</td>
							</tr>
							<tr>
								<td>5</td>
							</tr>
							<tr>
								<td>6</td>
							</tr>
							<tr>
								<td>7</td>
							</tr>
							<tr>
								<td>8</td>
							</tr>
							<tr>
								<td>9</td>
							</tr>
							<tr>
								<td>10</td>
							</tr>
							<tr>
								<td>11</td>
							</tr>
							<tr>
								<td>12</td>
							</tr>
							<tr>
								<td>13</td>
							</tr>
							<tr>
								<td>14</td>
							</tr>
							<tr>
								<td>15</td>
							</tr>
							<tr>
								<td>16</td>
							</tr>
						</table>

						<p>
							ある値<code>t</code>に対してこの関数を実行すると、<code>left</code>と<code>right</code>に新しい2曲線の座標が入ります。一方は<code>t</code>の「左」側、もう一方は「右」側の曲線です。この2曲線は元の曲線と同じ次数になり、また元の曲線とぴったり重なります。
						</p>
					</div>
				</section>
				<section id="matrixsplit">
					<h1>
						<div class="nav"><a href="ja-JP/index.html#splitting">previous</a><a href="ja-JP/index.html#reordering">next</a></div>
						<a href="ja-JP/index.html#matrixsplit">行列による曲線の分割</a>
					</h1>
					<p>
						曲線分割には、ベジエ曲線の行列表現を利用する方法もあります。<a href="#matrix">行列についての節</a
						>では、行列の乗算で曲線が表現できることを確認しました。特に2次・3次のベジエ曲線に関しては、それぞれ以下のような形になりました（読みやすさのため、ベジエの係数ベクトルを反転させています）。
					</p>
					<!--
\setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
 
                                                                                     ┌ P  ┐
                                                                      ┌  1  0 0 ┐    │  1 │
                                                 B(t) = ┌      2 ┐  · │ -2  2 0 │  · │ P  │
                                                        └ 1 t t  ┘    └  1 -2 1 ┘    │  2 │
                                                                                     │ P  │
                                                                                     └  3 ┘
-->
					<img
						class="LaTeX SVG"
						src="./images/chapters/matrixsplit/1bae50fefa43210b3a6259d1984f6cbc.svg"
						width="263px"
						height="55px"
						loading="lazy"
					/>
					<p>ならびに</p>
					<!--
\setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
 
                                                                                        ┌ P  ┐
                                                                                        │  1 │
                                                                      ┌  1  0  0 0 ┐    │ P  │
                                              B(t) = ┌      2  3 ┐  · │ -3  3  0 0 │  · │  2 │
                                                     └ 1 t t  t  ┘    │  3 -6  3 0 │    │ P  │
                                                                      └ -1  3 -3 1 ┘    │  3 │
                                                                                        │ P  │
                                                                                        └  4 ┘
-->
					<img
						class="LaTeX SVG"
						src="./images/chapters/matrixsplit/f690ff0502d9fd7d4697cc43d98afd5d.svg"
						width="323px"
						height="73px"
						loading="lazy"
					/>
					<p>
						曲線をある点<code>t = z</code
						>で分割し、新しく2つの（自明ですが、より短い）ベジエ曲線を作ることを考えましょう。曲線の行列表現と線形代数を利用すると、この2つのベジエ曲線の座標を求めることができます。まず、実際の「曲線上の点」の情報を分解し、新しい行列の積のかたちにします。
					</p>
					<!--
\setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
 
                                                                  ┌ P  ┐                                              ┌ P  ┐
                                                   ┌  1  0 0 ┐    │  1 │                 ┌ 1 0 0  ┐    ┌  1  0 0 ┐    │  1 │
                B(t) = ┌                    2 ┐  · │ -2  2 0 │  · │ P  │ = ┌      2 ┐  · │ 0 z 0  │  · │ -2  2 0 │  · │ P  │
                       └ 1 (z  · t) (z  · t)  ┘    └  1 -2 1 ┘    │  2 │   └ 1 t t  ┘    │      2 │    └  1 -2 1 ┘    │  2 │
                                                                  │ P  │                 └ 0 0 z  ┘                   │ P  │
                                                                  └  3 ┘                                              └  3 ┘
-->
					<img
						class="LaTeX SVG"
						src="./images/chapters/matrixsplit/f565e66677138927335535d009409c3d.svg"
						width="648px"
						height="55px"
						loading="lazy"
					/>
					<p>ならびに</p>
					<!--
\setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
 
                                                                    ┌ P  ┐                                                       ┌ P  ┐
                                                                    │  1 │                    ┌ 1 0  0 0  ┐                      │  1 │
                                                  ┌  1  0  0 0 ┐    │ P  │                    │ 0 z  0 0  │    ┌  1  0  0 0 ┐    │ P  │
     B(t) = ┌                    2         3 ┐  · │ -3  3  0 0 │  · │  2 │ = ┌      2  3 ┐  · │      2    │  · │ -3  3  0 0 │  · │  2 │
            └ 1 (z  · t) (z  · t)  (z  · t)  ┘    │  3 -6  3 0 │    │ P  │   └ 1 t t  t  ┘    │ 0 0 z  0  │    │  3 -6  3 0 │    │ P  │
                                                  └ -1  3 -3 1 ┘    │  3 │                    │         3 │    └ -1  3 -3 1 ┘    │  3 │
                                                                    │ P  │                    └ 0 0  0 z  ┘                      │ P  │
                                                                    └  4 ┘                                                       └  4 ┘
-->
					<img
						class="LaTeX SVG"
						src="./images/chapters/matrixsplit/ebf8d72c6056476172deeb89726b75c8.svg"
						width="805px"
						height="75px"
						loading="lazy"
					/>
					<p>
						これらの行列をまとめて、仮に**[tの値たち] · [ベジエ行列] ·
						[列ベクトル]**の形式にできたとしましょう。ただし、先頭2つの行列は変わらずそのままだとします。このとき、右端の列ベクトルは、前半部分すなわち<code
							>t = 0</code
						>から<code>t = z</code
						>を表す、新しいベジエ曲線の座標となります。結論からいうと、線形代数の簡単な規則を使えば、この変形は非常に容易です（そして、導出過程を気にしないのであれば、囲みの末尾まで飛ばして結果に行ってもかまいません！）。
					</p>
					<div class="note">
						<h2>新しい凸包の座標の導出</h2>
						<p>
							曲線を分割して2つの部分を得るためには、いくつかの段階を経る必要があります。曲線の次数が高くなるほど手間がかかるようになりますので、まずは2次の曲線で見てみましょう。
						</p>
						<!--
\setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
 
                                                                                            ┌ P  ┐
                                                               ┌ 1 0 0  ┐    ┌  1  0 0 ┐    │  1 │
                                          B(t) = ┌      2 ┐  · │ 0 z 0  │  · │ -2  2 0 │  · │ P  │
                                                 └ 1 t t  ┘    │      2 │    └  1 -2 1 ┘    │  2 │
                                                               └ 0 0 z  ┘                   │ P  │
                                                                                            └  3 ┘
-->
						<img
							class="LaTeX SVG"
							src="./images/chapters/matrixsplit/c32007be095224e0d157a8f71c62c90e.svg"
							width="348px"
							height="55px"
							loading="lazy"
						/>
						<!--
\usepackagexeCJK \xeCJKsetupCJKmath=true \setCJKmainfontipaexm.ttf
 
                                                                                                         ┌ P  ┐
                                                                                                         │  1 │
                             = ┌      2 ┐  · \undersetこれを…\underbrace\kern 2.25em Z  · M \kern 2.25em  · │ P  │
                               └ 1 t t  ┘                                                                │  2 │
                                                                                                         │ P  │
                                                                                                         └  3 ┘
-->
						<img
							class="LaTeX SVG"
							src="./images/chapters/matrixsplit/63d1337d275abf7b296d500b9b5821fd.svg"
							width="249px"
							height="55px"
							loading="lazy"
						/>
						<!--
\usepackagexeCJK \xeCJKsetupCJKmath=true \setCJKmainfontipaexm.ttf
 
                                                                                                    ┌ P  ┐
                                                                                   -1               │  1 │
                                  = ┌      2 ┐  · \underset…こうして…\underbrace M  · M    · Z  · M   · │ P  │
                                    └ 1 t t  ┘                                                      │  2 │
                                                                                                    │ P  │
                                                                                                    └  3 ┘
-->
						<img
							class="LaTeX SVG"
							src="./images/chapters/matrixsplit/d9d04b9b6c66788d18832a383d6f7ea0.svg"
							width="252px"
							height="55px"
							loading="lazy"
						/>
						<!--
\usepackagexeCJK \xeCJKsetupCJKmath=true \setCJKmainfontipaexm.ttf
 
                                                                                                                       ┌ P  ┐
                                                                                                                       │  1 │
              = ┌      2 ┐  · M \underset…こうじゃ！\underbrace \kern 1.25em  · \kern 1.25em Q \kern 1.25em  · \kern 1.25em │ P  │
                └ 1 t t  ┘                                                                                             │  2 │
                                                                                                                       │ P  │
                                                                                                                       └  3 ┘
-->
						<img
							class="LaTeX SVG"
							src="./images/chapters/matrixsplit/baedd4067516584d425b93331b7ce04f.svg"
							width="255px"
							height="55px"
							loading="lazy"
						/>
						<p>
							[<em>M · M<sup>-1</sup></em
							>]は単位行列なので、このような操作ができるのです（これは微積分でいえば、なにかにx/xを掛けるようなものです。関数自体はなにも変わりませんが、解きやすいかたちに変形したり、別のかたちに分解したりといったことが可能になります）。この行列を掛けると、式全体としてはなにも変わりませんが、[<em
								>なにか · M</em
							>]という行列の並びを[<em>M · なにか</em>]という並びに変えることができます。そして、これが大きな違いを生み出します。[<em
								>M<sup>-1</sup> · Z · M</em
							>]の値が分かれば、それを座標に掛け合わせることによって、2次ベジエ曲線の正しい行列表現（すなわち[<em>T · M · P</em>]）と、<em>t = 0</em
							>から<em>t = z</em>までの曲線を表す座標の組とが得られます。では、計算してみましょう。
						</p>
						<!--
\setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
 
                                           ┌ 1 0 0 ┐
                            -1             │   1   │    ┌ 1 0 0  ┐    ┌  1  0 0 ┐   ┌     1            0        0  ┐
                       Q = M    · Z  · M = │ 1 ─ 0 │  · │ 0 z 0  │  · │ -2  2 0 │ = │  -(z-1)          z        0  │
                                           │   2   │    │      2 │    └  1 -2 1 ┘   │        2                   2 │
                                           └ 1 1 1 ┘    └ 0 0 z  ┘                  └ (z - 1)  -2  · (z-1)  · z z  ┘
-->
						<img
							class="LaTeX SVG"
							src="./images/chapters/matrixsplit/5e008143622c66bb5e9cc4d5d6a8ea62.svg"
							width="627px"
							height="56px"
							loading="lazy"
						/>
						<p>いいですね！これで、新しい2次ベジエ曲線が得られます。</p>
						<!--
\setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
 
                                                                ┌ P  ┐                      ╭      ┌ P  ┐ ╮
                                                                │  1 │                      │      │  1 │ │
                                 B(t) = ┌      2 ┐  · M  · Q  · │ P  │ = ┌      2 ┐  · M  · │ Q  · │ P  │ │
                                        └ 1 t t  ┘              │  2 │   └ 1 t t  ┘         │      │  2 │ │
                                                                │ P  │                      │      │ P  │ │
                                                                └  3 ┘                      ╰      └  3 ┘ ╯
-->
						<img
							class="LaTeX SVG"
							src="./images/chapters/matrixsplit/dceed84990aaf6878bcc67ddbaa8d8d9.svg"
							width="417px"
							height="55px"
							loading="lazy"
						/>
						<!--
\setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
 
                                                              ╭                                     ┌ P  ┐ ╮
                                               ┌  1  0 0 ┐    │ ┌     1            0        0  ┐    │  1 │ │
                               = ┌      2 ┐  · │ -2  2 0 │  · │ │  -(z-1)          z        0  │  · │ P  │ │
                                 └ 1 t t  ┘    └  1 -2 1 ┘    │ │        2                   2 │    │  2 │ │
                                                              │ └ (z - 1)  -2  · (z-1)  · z z  ┘    │ P  │ │
                                                              ╰                                     └  3 ┘ ╯
-->
						<img
							class="LaTeX SVG"
							src="./images/chapters/matrixsplit/f63067c2c3042c374a58dfa7f692309e.svg"
							width="479px"
							height="55px"
							loading="lazy"
						/>
						<!--
\setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
 
                                                           ┌                        P                          ┐
                                                           │                         1                         │
                                            ┌  1  0 0 ┐    │               z  · P  - (z-1)  · P                │
                            = ┌      2 ┐  · │ -2  2 0 │  · │                     2             1               │
                              └ 1 t t  ┘    └  1 -2 1 ┘    │  2                                        2       │
                                                           │ z   · P  - 2  · z  · (z-1)  · P  + (z - 1)   · P  │
                                                           └        3                       2                1 ┘
-->
						<img
							class="LaTeX SVG"
							src="./images/chapters/matrixsplit/e58196b82b78f584779208cce88137f5.svg"
							width="492px"
							height="55px"
							loading="lazy"
						/>
						<p>
							<strong><em>すばらしい</em></strong
							>。<code>t = 0</code>から<code>t = z</code
							>の部分曲線を求める場合、始点の座標はそのままになります（もっともです）。制御点は、元々の制御点と始点を、比率zで混ぜ合わせたものになります。そして不思議なことに、新たな終点は2次の<a
								href="https://ja.wikipedia.org/wiki/%E3%83%90%E3%83%BC%E3%83%B3%E3%82%B9%E3%82%BF%E3%82%A4%E3%83%B3%E5%A4%9A%E9%A0%85%E5%BC%8F"
								>ベルンシュタイン多項式</a
							>に似た混ぜ合わせになります。これらの新しい座標は、とても簡単に直接計算ができるのです！
						</p>
						<p>
							もちろん、これは2曲線のうちの片方にすぎません。<code>t = z</code>から<code>t = 1</code
							>の部分を得るためには、同様の計算をする必要があります。まず、今さっき行ったのは、一般の区間[0,<code>z</code>]についての計算でした。これは0があるので簡単な形になっていましたが、実際には、次の式を計算していたということがわかります。
						</p>
						<!--
\setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
 
                                                                                                 ┌ P  ┐
                                                                                  ┌  1  0 0 ┐    │  1 │
                                     B(t) = ┌                              2 ┐  · │ -2  2 0 │  · │ P  │
                                            └ 1 ( 0 + z  · t) ( 0 + z  · t)  ┘    └  1 -2 1 ┘    │  2 │
                                                                                                 │ P  │
                                                                                                 └  3 ┘
-->
						<img
							class="LaTeX SVG"
							src="./images/chapters/matrixsplit/6a22184e6ca869d28f4a252b64f23eff.svg"
							width="381px"
							height="55px"
							loading="lazy"
						/>
						<!--
\setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
 
                                                                                         ┌ P  ┐
                                                            ┌ 1 0 0  ┐    ┌  1  0 0 ┐    │  1 │
                                            = ┌      2 ┐  · │ 0 z 0  │  · │ -2  2 0 │  · │ P  │
                                              └ 1 t t  ┘    │      2 │    └  1 -2 1 ┘    │  2 │
                                                            └ 0 0 z  ┘                   │ P  │
                                                                                         └  3 ┘
-->
						<img
							class="LaTeX SVG"
							src="./images/chapters/matrixsplit/3b5e41808b6c3bc66f3da2f40651410e.svg"
							width="313px"
							height="55px"
							loading="lazy"
						/>
						<p>区間[<em>z</em>,1]を求めたい場合は、かわりに次のような計算になります。</p>
						<!--
\setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
 
                                                                                                     ┌ P  ┐
                                                                                      ┌  1  0 0 ┐    │  1 │
                                 B(t) = ┌                                      2 ┐  · │ -2  2 0 │  · │ P  │
                                        └ 1 ( z + (1-z)  · t) ( z + (1-z)  · t)  ┘    └  1 -2 1 ┘    │  2 │
                                                                                                     │ P  │
                                                                                                     └  3 ┘
-->
						<img
							class="LaTeX SVG"
							src="./images/chapters/matrixsplit/e079f44b56e07c8d7f83c17c8ebf1ecf.svg"
							width="461px"
							height="55px"
							loading="lazy"
						/>
						<!--
\setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
 
                                                     ┌              2        ┐                   ┌ P  ┐
                                                     │ 1  z        z         │    ┌  1  0 0 ┐    │  1 │
                                     = ┌      2 ┐  · │ 0 1-z 2  · z  · (1-z) │  · │ -2  2 0 │  · │ P  │
                                       └ 1 t t  ┘    │                2      │    └  1 -2 1 ┘    │  2 │
                                                     └ 0  0      (1-z)       ┘                   │ P  │
                                                                                                 └  3 ┘
-->
						<img
							class="LaTeX SVG"
							src="./images/chapters/matrixsplit/4764868f43815e471bb1ea95a81e1633.svg"
							width="412px"
							height="57px"
							loading="lazy"
						/>
						<p>先ほどと同じ手法を使い、[<em>なにか · M</em>]を[<em>M · なにか</em>]に変えます。</p>
						<!--
\setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
 
                                      ┌ 1 0 0 ┐    ┌              2        ┐
                      -1              │   1   │    │ 1  z        z         │    ┌  1  0 0 ┐   ┌      2                   2 ┐
                Q' = M    · Z'  · M = │ 1 ─ 0 │  · │ 0 1-z 2  · z  · (1-z) │  · │ -2  2 0 │ = │ (z-1)  -2  · z  · (z-1) z  │
                                      │   2   │    │                2      │    └  1 -2 1 ┘   │    0        -(z-1)      z  │
                                      └ 1 1 1 ┘    └ 0  0      (1-z)       ┘                  └    0           0        1  ┘
-->
						<img
							class="LaTeX SVG"
							src="./images/chapters/matrixsplit/c341532f693c2c1adfd298597bbfb5b5.svg"
							width="729px"
							height="57px"
							loading="lazy"
						/>
						<p>よって、後半部分の曲線は結局のところ以下のようになります。</p>
						<!--
\setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
 
                                                               ┌ P  ┐                      ╭       ┌ P  ┐ ╮
                                                               │  1 │                      │       │  1 │ │
                                B(t) = ┌      2 ┐  · M  · Q  · │ P  │ = ┌      2 ┐  · M  · │ Q'  · │ P  │ │
                                       └ 1 t t  ┘              │  2 │   └ 1 t t  ┘         │       │  2 │ │
                                                               │ P  │                      │       │ P  │ │
                                                               └  3 ┘                      ╰       └  3 ┘ ╯
-->
						<img
							class="LaTeX SVG"
							src="./images/chapters/matrixsplit/e2622175dadafecc015f15c79ddf3002.svg"
							width="421px"
							height="55px"
							loading="lazy"
						/>
						<!--
\setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
 
                                                               ╭                                   ┌ P  ┐ ╮
                                                ┌  1  0 0 ┐    │ ┌      2                   2 ┐    │  1 │ │
                                = ┌      2 ┐  · │ -2  2 0 │  · │ │ (z-1)  -2  · z  · (z-1) z  │  · │ P  │ │
                                  └ 1 t t  ┘    └  1 -2 1 ┘    │ │    0        -(z-1)      z  │    │  2 │ │
                                                               │ └    0           0        1  ┘    │ P  │ │
                                                               ╰                                   └  3 ┘ ╯
-->
						<img
							class="LaTeX SVG"
							src="./images/chapters/matrixsplit/4ce218bc968cbd98da0ca6ab66d415ed.svg"
							width="473px"
							height="57px"
							loading="lazy"
						/>
						<!--
\setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
 
                                                            ┌  2                                      2       ┐
                                                            │ z   · P  - 2  · z  · (z-1)  · P  + (z-1)   · P  │
                                             ┌  1  0 0 ┐    │        3                       2              1 │
                             = ┌      2 ┐  · │ -2  2 0 │  · │              z  · P  - (z-1)  · P               │
                               └ 1 t t  ┘    └  1 -2 1 ┘    │                    3             2              │
                                                            │                       P                         │
                                                            └                        3                        ┘
-->
						<img
							class="LaTeX SVG"
							src="./images/chapters/matrixsplit/9a4899b69e03cd4ad02c5eedffaa6a2f.svg"
							width="492px"
							height="57px"
							loading="lazy"
						/>
						<p>
							<strong><em>おみごと</em></strong
							>。先ほどと同じようになっていることがわかります。終点の座標はそのままで（もっともです）、制御点は、元々の制御点と終点を比率zで混ぜ合わせたものになります。そして不思議なことに、新たな始点は2次のベルンシュタイン多項式に似た混ぜ合わせになります。ただし、(1-z)の代わりに(z-1)になっています。これらの新しい座標<em>も</em>、とても簡単に直接計算ができるのです！
						</p>
					</div>

					<p>
						というわけで、ド・カステリョのアルゴリズムではなく線形代数の方を使うと、どのような2次ベジエ曲線でもある値<code>t = z</code
						>で分割すれば2つのベジエ曲線となり、しかもその座標は簡単に求められる、ということがわかりました。
					</p>
					<!--
\setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
 
                                                                  ┌                        P                          ┐
                                                         ┌ P  ┐   │                         1                         │
                     ┌     1            0        0  ┐    │  1 │   │               z  · P  - (z-1)  · P                │
                     │  -(z-1)          z        0  │  · │ P  │ = │                     2             1               │
                     │        2                   2 │    │  2 │   │  2                                        2       │
                     └ (z - 1)  -2  · (z-1)  · z z  ┘    │ P  │   │ z   · P  - 2  · z  · (z-1)  · P  + (z - 1)   · P  │
                                                         └  3 ┘   └        3                       2                1 ┘
-->
					<img
						class="LaTeX SVG"
						src="./images/chapters/matrixsplit/480ebd0234e2fe1adc94926e8ed4339c.svg"
						width="576px"
						height="55px"
						loading="lazy"
					/>
					<p>および</p>
					<!--
\setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
 
                                                                  ┌  2                                      2       ┐
                                                         ┌ P  ┐   │ z   · P  - 2  · z  · (z-1)  · P  + (z-1)   · P  │
                       ┌      2                   2 ┐    │  1 │   │        3                       2              1 │
                       │ (z-1)  -2  · z  · (z-1) z  │  · │ P  │ = │              z  · P  - (z-1)  · P               │
                       │    0        -(z-1)      z  │    │  2 │   │                    3             2              │
                       └    0           0        1  ┘    │ P  │   │                       P                         │
                                                         └  3 ┘   └                        3                        ┘
-->
					<img
						class="LaTeX SVG"
						src="./images/chapters/matrixsplit/17e308aa6d459b1d06d3160cc8e2e786.svg"
						width="571px"
						height="57px"
						loading="lazy"
					/>
					<p>
						3次の曲線についても同様です。ただし、実際の導出はあなたにとっておきますので（自力で書き下してみてください）、新しい座標の組の結果を示すだけにします。
					</p>
					<!--
\setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
 
                                                              ┌                                    P                                      ┐
                                                     ┌ P  ┐   │                                     1                                     │
┌    1            0                0         0  ┐    │  1 │   │                           z  · P  - (z-1)  · P                            │
│  -(z-1)         z                0         0  │    │ P  │   │                                 2             1                           │
│       2                           2           │  · │  2 │ = │               2                                      2                    │
│  (z-1)  -2  · (z-1)  · z         z         0  │    │ P  │   │              z   · P  - 2  · z  · (z-1)  · P  + (z-1)   · P               │
│       3           2                      2  3 │    │  3 │   │                     3                       2              1              │
└ -(z-1)  3  · (z-1)   · z -3  · (z-1)  · z  z  ┘    │ P  │   │  3               2                                 2              3       │
                                                     └  4 ┘   │ z   · P  - 3  · z   · (z-1)  · P  + 3  · z  · (z-1)   · P  - (z-1)   · P  │
                                                              └        4                        3                        2              1 ┘
-->
					<img
						class="LaTeX SVG"
						src="./images/chapters/matrixsplit/11505e0215ef026f2e49383ebb4a1abb.svg"
						width="841px"
						height="75px"
						loading="lazy"
					/>
					<p>および</p>
					<!--
\setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
 
                                                              ┌  3               2                                 2              3       ┐
                                                     ┌ P  ┐   │ z   · P  - 3  · z   · (z-1)  · P  + 3  · z  · (z-1)   · P  - (z-1)   · P  │
┌       3           2                      2  3 ┐    │  1 │   │        4                        3                        2              1 │
│ -(z-1)  3  · (z-1)   · z -3  · (z-1)  · z  z  │    │ P  │   │               2                                      2                    │
│                   2                         2 │  · │  2 │ = │              z   · P  - 2  · z  · (z-1)  · P  + (z-1)   · P               │
│    0         (z-1)        -2  · (z-1)  · z z  │    │ P  │   │                     4                       3              2              │
│    0            0              -(z-1)      z  │    │  3 │   │                           z  · P  - (z-1)  · P                            │
└    0            0                0         1  ┘    │ P  │   │                                 4             3                           │
                                                     └  4 ┘   │                                    P                                      │
                                                              └                                     4                                     ┘
-->
					<img
						class="LaTeX SVG"
						src="./images/chapters/matrixsplit/a899891096d82b7fdb23a90e6106b6df.svg"
						width="837px"
						height="77px"
						loading="lazy"
					/>
					<p>
						さて、これらの行列を見るに、後半部分の曲線の行列は本当に計算する必要があったのでしょうか？いえ、ありませんでした。片方の行列が得られれば、実はもう一方の行列も暗に得られたことになります。まず、行列*<strong
							>Q**<em>の各行の値を右側に寄せ、右側にあった0を左側に押しのけます。次に行列を上下に反転させます。これでたちまち</em></strong
						>Q'***が「計算」できるのです。
					</p>
					<p>
						この方法で曲線の分割を実装すれば、再帰が少なくて済みます。また、数値のキャッシュを利用した単純な演算になるので、再帰の計算コストが大きいシステムにおいては、コストが抑えられるかもしれません。行列の乗算に適したデバイスで計算を行えば、ド・カステリョのアルゴリズムに比べてかなり速くなるでしょう。
					</p>
				</section>
				<section id="reordering">
					<h1>
						<div class="nav"><a href="ja-JP/index.html#matrixsplit">previous</a><a href="ja-JP/index.html#derivatives">next</a></div>
						<a href="ja-JP/index.html#reordering">Lowering and elevating curve order</a>
					</h1>
					<p>
						One interesting property of Bézier curves is that an <em>n<sup>th</sup></em> order curve can always be perfectly represented by an
						<em>(n+1)<sup>th</sup></em> order curve, by giving the higher-order curve specific control points.
					</p>
					<p>
						If we have a curve with three points, then we can create a curve with four points that exactly reproduces the original curve. First, we
						give it the same start and end points, and for its two control points we pick "1/3<sup>rd</sup> start + 2/3<sup>rd</sup> control" and
						"2/3<sup>rd</sup> control + 1/3<sup>rd</sup> end". Now we have exactly the same curve as before, except represented as a cubic curve
						rather than a quadratic curve.
					</p>
					<p>
						The general rule for raising an <em>n<sup>th</sup></em> order curve to an <em>(n+1)<sup>th</sup></em> order curve is as follows (observing
						that the start and end weights are the same as the start and end weights for the old curve):
					</p>
					<!--
    \setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
     
              __ k                                                                                          k-i     i
Bézier(k,t) = ❯      \undersetbinomial term\underbrace\binomki  · \ \undersetpolynomial term\underbrace(1-t)     · t    · \ \undersetnew 
              ‾‾ i=0
                                                  ╭ (k-i)  · w  + i  · w    ╮
                                                  │           i         i-1 │
                                weights\underbrace│ ─────────────────────── │  , with k = n+1 and w   =0 when i = 0
                                                  ╰            k            ╯                      i-1
-->
					<img class="LaTeX SVG" src="./images/chapters/reordering/e9fc9c715bb55a702db68b2bb6da0a68.svg" width="768px" height="61px" loading="lazy" />
					<p>
						However, this rule also has as direct consequence that you <strong>cannot</strong> generally safely lower a curve from
						<em>n<sup>th</sup></em> order to <em>(n-1)<sup>th</sup></em> order, because the control points cannot be "pulled apart" cleanly. We can
						try to, but the resulting curve will not be identical to the original, and may in fact look completely different.
					</p>
					<p>
						However, there is a surprisingly good way to ensure that a lower order curve looks "as close as reasonably possible" to the original
						curve: we can optimise the "least-squares distance" between the original curve and the lower order curve, in a single operation (also
						explained over on <a href="https://www.sirver.net/blog/2011/08/23/degree-reduction-of-bezier-curves/">Sirver's Castle</a>). However, to
						use it, we'll need to do some calculus work and then switch over to linear algebra. As mentioned in the section on matrix representations,
						some things can be done much more easily with matrices than with calculus functions, and this is one of those things. So... let's go!
					</p>
					<p>We start by taking the standard Bézier function, and condensing it a little:</p>
					<!--
\setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
 
                                               __ n       n               n                       n-i     i
                                 Bézier(n,t) = ❯      w  B (t)  , where  B (t) = \binomni  · (1-t)     · t 
                                               ‾‾ i=0  i  i               i
-->
					<img class="LaTeX SVG" src="./images/chapters/reordering/8090b63b005bf3edb916b97bda317a0e.svg" width="408px" height="41px" loading="lazy" />
					<p>
						Then, we apply one of those silly (actually, super useful) calculus tricks: since our <code>t</code> value is always between zero and one
						(inclusive), we know that <code>(1-t)</code> plus <code>t</code> always sums to 1. As such, we can express any value as a sum of
						<code>t</code> and <code>1-t</code>:
					</p>
					<!--
\setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
 
                                          x = 1 x = ((1-t) + t) x = (1-t) x + t x = x (1-t) + x t
-->
					<img class="LaTeX SVG" src="./images/chapters/reordering/ff224ded6bbbc94b43130f5f8eeb5d29.svg" width="379px" height="16px" loading="lazy" />
					<p>
						So, with that seemingly trivial observation, we rewrite that Bézier function by splitting it up into a sum of a <code>(1-t)</code> and
						<code>t</code> component:
					</p>
					<!--
\setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
 
                                          Bézier(n,t)= (1-t) B(n,t) + t B(n,t)                    
                                                       __ n               n      __ n         n   
                                                     = ❯      w  (1 - t) B (t) + ❯      w  t B (t)
                                                       ‾‾ i=0  i          i      ‾‾ i=0  i    i
-->
					<img class="LaTeX SVG" src="./images/chapters/reordering/56130afc4cb313e0e74cf670d34590f6.svg" width="316px" height="67px" loading="lazy" />
					<p>
						So far so good. Now, to see why we did this, let's write out the <code>(1-t)</code> and <code>t</code> parts, and see what that gives us.
						I promise, it's about to make sense. We start with <code>(1-t)</code>:
					</p>
					<!--
\setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
 
                                                  n              n!         n-i  i
                                         (1 - t) B (t)= (1-t) ──────── (1-t)    t                  
                                                  i           (n-i)!i!
                                                        n+1-i   (n+1)!        n+1-i  i
                                                      = ───── ────────── (1-t)      t              
                                                         n+1  (n+1-i)!i!                           
                                                        k-i    k!         k-i  i
                                                      = ─── ──────── (1-t)    t ,  where  k = n + 1
                                                         k  (k-i)!i!
                                                        k-i  k
                                                      = ─── B (t)                                  
                                                         k   i
-->
					<img
						class="LaTeX SVG"
						src="./images/chapters/reordering/0f5698b31598b2390e966fc5e43ab53e.svg"
						width="387px"
						height="160px"
						loading="lazy"
					/>
					<p>
						So by using this seemingly silly trick, we can suddenly express part of our n<sup>th</sup> order Bézier function in terms of an (n+1)<sup
							>th</sup
						>
						order Bézier function. And that sounds a lot like raising the curve order! Of course we need to be able to repeat that trick for the
						<code>t</code> part, but that's not a problem:
					</p>
					<!--
\setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
 
                                        n          n!         n-i  i
                                     t B (t)= t ──────── (1-t)    t                                    
                                        i       (n-i)!i!
                                              i+1        (n+1)!             (n+1)-(i+1)  i+1
                                            = ─── ──────────────────── (1-t)            t              
                                              n+1 ((n+1)-(i+1))!(i+1)!                                 
                                              i+1        k!             k-(i+1)  i+1
                                            = ─── ──────────────── (1-t)        t   ,  where  k = n + 1
                                               k  (k-(i+1))!(i+1)!
                                              i+1  k
                                            = ─── B   (t)                                              
                                               k   i+1
-->
					<img
						class="LaTeX SVG"
						src="./images/chapters/reordering/ab7c087f7c070d43a42f3f03010a7427.svg"
						width="471px"
						height="159px"
						loading="lazy"
					/>
					<p>
						So, with both of those changed from an order <code>n</code> expression to an order <code>(n+1)</code> expression, we can put them back
						together again. Now, where the order <code>n</code> function had a summation from 0 to <code>n</code>, the order <code>n+1</code> function
						uses a summation from 0 to <code>n+1</code>, but this shouldn't be a problem as long as we can add some new terms that "contribute
						nothing". In the next section on derivatives, there is a discussion about why "higher terms than there is a binomial for" and "lower than
						zero terms" both "contribute nothing". So as long as we can add terms that have the same form as the terms we need, we can just include
						them in the summation, they'll sit there and do nothing, and the resulting function stays identical to the lower order curve.
					</p>
					<p>Let's do this:</p>
					<!--
\setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
 
                                              __ n+1             n      __ n+1       n
                                 Bézier(n,t)= ❯      w  (1 - t) B (t) + ❯      w  t B (t)                   
                                              ‾‾ i=0  i          i      ‾‾ i=0  i    i
                                              __ n+1    k-i  k      __ n+1    i+1  k
                                            = ❯      w  ─── B (t) + ❯      w  ─── B   (t),  where  k = n + 1
                                              ‾‾ i=0  i  k   i      ‾‾ i=0  i  k   i+1
                                              __ n+1    k-i  k      __ n+1      i  k
                                            = ❯      w  ─── B (t) + ❯      p    ─ B (t)                     
                                              ‾‾ i=0  i  k   i      ‾‾ i=0  i-1 k  i
                                              __ n+1 ╭    k-i        i ╮  k
                                            = ❯      │ w  ─── + p    ─ │ B (t)                              
                                              ‾‾ i=0 ╰  i  k     i-1 k ╯  i
                                              __ n+1                      k                 i
                                            = ❯      (w  (1-s) + p    s) B (t),  where  s = ─               
                                              ‾‾ i=0   i          i-1     i                 k
-->
					<img
						class="LaTeX SVG"
						src="./images/chapters/reordering/4ff41e183d60d5fd10a5d3d30dd63358.svg"
						width="465px"
						height="257px"
						loading="lazy"
					/>
					<p>
						And this is where we switch over from calculus to linear algebra, and matrices: we can now express this relation between Bézier(n,t) and
						Bézier(n+1,t) as a very simple matrix multiplication:
					</p>
					<!--
\setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
 
                                                                 M B  = B 
                                                                    n    k
-->
					<img class="LaTeX SVG" src="./images/chapters/reordering/1f5b60d190a1c7099b3411e4cc477291.svg" width="71px" height="16px" loading="lazy" />
					<p>where the matrix <strong>M</strong> is an <code>n+1</code> by <code>n</code> matrix, and looks like:</p>
					<!--
\setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
 
                                                      ┌ 1  0   .   .   .   .    .    .  ┐
                                                      │ 1 k-1                           │
                                                      │ ─ ───  0   .   .   .    0    .  │
                                                      │ k  k                            │
                                                      │    2  k-2                       │
                                                      │ 0  ─  ───  0   .   .    .    .  │
                                                      │    k   k                        │
                                                      │        3  k-3                   │
                                                      │ .  0   ─  ───  0   .    .    .  │
                                                  M = │        k   k                    │
                                                      │ .  .   0  ... ...  0    .    .  │
                                                      │ .  .   .   0  ... ...   0    .  │
                                                      │                   n-1 k-n+1     │
                                                      │ .  .   .   .   0  ─── ─────  0  │
                                                      │                    k    k       │
                                                      │                         n   k-n │
                                                      │ .  0   .   .   .   0    ─   ─── │
                                                      │                         k    k  │
                                                      └ .  .   .   .   .   .    0    1  ┘
-->
					<img
						class="LaTeX SVG"
						src="./images/chapters/reordering/056e25c397c524d80f378ce3823c7e78.svg"
						width="336px"
						height="187px"
						loading="lazy"
					/>
					<p>
						That might look unwieldy, but it's really just a mostly-zeroes matrix, with a very simply fraction on the diagonal, and an even simpler
						fraction to the left of it. Multiplying a list of coordinates with this matrix means we can plug the resulting transformed coordinates
						into the one-order-higher function and get an identical looking curve.
					</p>
					<p>Not too bad!</p>
					<p>
						Equally interesting, though, is that with this matrix operation established, we can now use an incredibly powerful and ridiculously simple
						way to find out a "best fit" way to reverse the operation, called
						<a href="https://mathworld.wolfram.com/NormalEquation.html">the normal equation</a>. What it does is minimize the sum of the square
						differences between one set of values and another set of values. Specifically, if we can express that as some function
						<strong>A x = b</strong>, we can use it. And as it so happens, that's exactly what we're dealing with, so:
					</p>
					<!--
\setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
 
                                                                   M B = B             
                                                                      n   k
                                                                T         T
                                                              (M  M) B = M  B          
                                                                      n      k
                                                       T   -1   T          T   -1  T
                                                     (M  M)   (M  M) B = (M  M)   M  B 
                                                                      n               k
                                                                           T   -1  T
                                                                   I B = (M  M)   M  B 
                                                                      n               k
                                                                           T   -1  T
                                                                     B = (M  M)   M  B 
                                                                      n               k
-->
					<img
						class="LaTeX SVG"
						src="./images/chapters/reordering/46e64dc07502e14217ec83d755f736ee.svg"
						width="272px"
						height="116px"
						loading="lazy"
					/>
					<p>The steps taken here are:</p>
					<ol>
						<li>We have a function in a form that the normal equation can be used with, so</li>
						<li>apply the normal equation!</li>
						<li>
							Then, we want to end up with just B<sub>n</sub> on the left, so we start by left-multiply both sides such that we'll end up with lots of
							stuff on the left that simplified to "a factor 1", which in matrix maths is the
							<a href="https://en.wikipedia.org/wiki/Identity_matrix">identity matrix</a>.
						</li>
						<li>
							In fact, by left-multiplying with the inverse of what was already there, we've effectively "nullified" (but really, one-inified) that
							big, unwieldy block into the identity matrix <strong>I</strong>. So we substitute the mess with <strong>I</strong>, and then
						</li>
						<li>
							because multiplication with the identity matrix does nothing (like multiplying by 1 does nothing in regular algebra), we just drop it.
						</li>
					</ol>
					<p>
						And we're done: we now have an expression that lets us approximate an <code>n+1</code><sup>th</sup> order curve with a lower <code>n</code
						><sup>th</sup> order curve. It won't be an exact fit, but it's definitely a best approximation. So, let's implement these rules for
						raising and lowering curve order to a (semi) random curve, using the following graphic. Select the sketch, which has movable control
						points, and press your up and down arrow keys to raise or lower the curve order.
					</p>
					<graphics-element title="A variable-order Bézier curve" width="275" height="275" src="./chapters/reordering/reorder.js">
						<fallback-image>
							<span class="view-source">Scripts are disabled. Showing fallback image.</span>
							<img width="275px" height="275px" src="./images/chapters/reordering/c4874e1205aabe624e5504abe154eae9.png" loading="lazy" />
							<label>A variable-order Bézier curve</label>
						</fallback-image>
						<button class="raise">raise</button>
						<button class="lower">lower</button>
					</graphics-element>
				</section>
				<section id="derivatives">
					<h1>
						<div class="nav"><a href="ja-JP/index.html#reordering">previous</a><a href="ja-JP/index.html#pointvectors">next</a></div>
						<a href="ja-JP/index.html#derivatives">Derivatives</a>
					</h1>
					<p>
						There's a number of useful things that you can do with Bézier curves based on their derivative, and one of the more amusing observations
						about Bézier curves is that their derivatives are, in fact, also Bézier curves. In fact, the differentiation of a Bézier curve is
						relatively straightforward, although we do need a bit of math.
					</p>
					<p>First, let's look at the derivative rule for Bézier curves, which is:</p>
					<!--
\setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
 
                                                               __ n-1
                                           Bézier'(n,t) = n  · ❯      (b   -b )  ·  Bézier(n-1,t) 
                                                               ‾‾ i=0   i+1  i                   i
-->
					<img
						class="LaTeX SVG"
						src="./images/chapters/derivatives/f67d2d379ba6dfaa7f7686a7d1eae367.svg"
						width="333px"
						height="44px"
						loading="lazy"
					/>
					<p>
						which we can also write (observing that <i>b</i> in this formula is the same as our <i>w</i> weights, and that <i>n</i> times a summation
						is the same as a summation where each term is multiplied by <i>n</i>) as:
					</p>
					<!--
\setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
 
                                                          __ n-1
                                           Bézier'(n,t) = ❯       Bézier(n-1,t)   · n  · (w   -w )
                                                          ‾‾ i=0               i           i+1  i
-->
					<img
						class="LaTeX SVG"
						src="./images/chapters/derivatives/67ca2710769505572e097ffb40de099f.svg"
						width="343px"
						height="44px"
						loading="lazy"
					/>
					<p>
						Or, in plain text: the derivative of an n<sup>th</sup> degree Bézier curve is an (n-1)<sup>th</sup> degree Bézier curve, with one fewer
						term, and new weights w'<sub>0</sub>...w'<sub>n-1</sub> derived from the original weights as n(w<sub>i+1</sub> - w<sub>i</sub>). So for a
						3<sup>rd</sup> degree curve, with four weights, the derivative has three new weights: w'<sub>0</sub> = 3(w<sub>1</sub>-w<sub>0</sub>),
						w'<sub>1</sub> = 3(w<sub>2</sub>-w<sub>1</sub>) and w'<sub>2</sub> = 3(w<sub>3</sub>-w<sub>2</sub>).
					</p>
					<div class="note">
						<h3>"Slow down, why is that true?"</h3>
						<p>
							Sometimes just being told "this is the derivative" is nice, but you might want to see why this is indeed the case. As such, let's have a
							look at the proof for this derivative. First off, the weights are independent of the full Bézier function, so the derivative involves
							only the derivative of the polynomial basis function. So, let's find that:
						</p>
						<!--
\setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
 
                                                             d    ╭ n ╮  k      n-k d
                                                     B   (t) ── = │   │ t  (1-t)    ──
                                                      n,k    dt   ╰ k ╯             dt
-->
						<img
							class="LaTeX SVG"
							src="./images/chapters/derivatives/a992185a346518b5ca159484019b6917.svg"
							width="209px"
							height="36px"
							loading="lazy"
						/>
						<p>
							Applying the <a href="https://en.wikipedia.org/wiki/Product_rule">product</a> and
							<a href="https://en.wikipedia.org/wiki/Chain_rule">chain</a> rules gives us:
						</p>
						<!--
\setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
 
                                           ╭ n ╮        k-1      n-k    k         n-k-1
                                     ... = │   │ (k  · t    (1-t)    + t   · (1-t)       · (n-k)  · -1)
                                           ╰ k ╯
-->
						<img
							class="LaTeX SVG"
							src="./images/chapters/derivatives/c3ac18fe4ba0606a15bc111e52b17a9a.svg"
							width="412px"
							height="28px"
							loading="lazy"
						/>
						<p>Which is hard to work with, so let's expand that properly:</p>
						<!--
\setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
 
                                                   kn!     k-1      n-k   (n-k)n!   k      n-1-k
                                           ... = ──────── t    (1-t)    - ──────── t  (1-t)     
                                                 k!(n-k)!                 k!(n-k)!
-->
						<img
							class="LaTeX SVG"
							src="./images/chapters/derivatives/12fa7f83f055ef2078cc9f04e1468663.svg"
							width="344px"
							height="27px"
							loading="lazy"
						/>
						<p>
							Now, the trick is to turn this expression into something that has binomial coefficients again, so we want to end up with things that
							look like "x! over y!(x-y)!". If we can do that in a way that involves terms of <i>n-1</i> and <i>k-1</i>, we'll be on the right track.
						</p>
						<!--
\setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
 
                                     n!       k-1      n-k   (n-k)n!   k      n-1-k
                          ... = ──────────── t    (1-t)    - ──────── t  (1-t)                                   
                                (k-1)!(n-k)!                 k!(n-k)!
                                  ╭    (n-1)!     k-1      n-k   (n-k)(n-1)!  k      n-1-k ╮
                          ... = n │ ──────────── t    (1-t)    - ─────────── t  (1-t)      │                     
                                  ╰ (k-1)!(n-k)!                  k!(n-k)!                 ╯
                                  ╭        (n-1)!         (k-1)      (n-1)-(k-1)      (n-1)!     k      (n-1)-k ╮
                          ... = n │ ──────────────────── t      (1-t)            - ──────────── t  (1-t)        │
                                  ╰ (k-1)!((n-1)-(k-1))!                           k!((n-1)-k)!                 ╯
-->
						<img
							class="LaTeX SVG"
							src="./images/chapters/derivatives/64c06c61727d0912a67c0f287a395e47.svg"
							width="545px"
							height="76px"
							loading="lazy"
						/>
						<p>And that's the first part done: the two components inside the parentheses are actually regular, lower-order Bézier expressions:</p>
						<!--
\setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
 
                                        ╭    x!     y      x-y      x!     k      x-k ╮
                                ... = n │ ──────── t  (1-t)    - ──────── t  (1-t)    │  , with x=n-1, y=k-1
                                        ╰ y!(x-y)!               k!(x-k)!             ╯                     
                                ... = n (B           (t) - B       (t))                                     
                                          (n-1),(k-1)       (n-1),k
-->
						<img
							class="LaTeX SVG"
							src="./images/chapters/derivatives/6a3672344bb571eadb72669f60a93ff4.svg"
							width="533px"
							height="48px"
							loading="lazy"
						/>
						<p>
							Now to apply this to our weighted Bézier curves. We'll write out the plain curve formula that we saw earlier, and then work our way
							through to its derivative:
						</p>
						<!--
\setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
 
                            Bézier   (t)    = B   (t)  · w  + B   (t)  · w  + B   (t)  · w  + B   (t)  · w  + ...
                                  n,k          n,0        0    n,1        1    n,2        2    n,3        3
                                         d
                            Bézier   (t) ── = n  · (B      (t) - B     (t))  · w  +                              
                                  n,k    dt          n-1,-1       n-1,0         0
                                              n  · (B     (t) - B     (t))  · w  +                               
                                                     n-1,0       n-1,1         1
                                              n  · (B     (t) - B     (t))  · w  +                               
                                                     n-1,1       n-1,2         2
                                              n  · (B     (t) - B     (t))  · w  +                               
                                                     n-1,2       n-1,3         3
                                              ...                                                                
-->
						<img
							class="LaTeX SVG"
							src="./images/chapters/derivatives/897cfd8648720dc21463a9358cc65ab4.svg"
							width="527px"
							height="112px"
							loading="lazy"
						/>
						<p>
							If we expand this (with some color to show how terms line up), and reorder the terms by increasing values for <i>k</i> we see the
							following:
						</p>
						<!--
\setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
 
                                  n  · B      (t)  · w              +                                    
                                        n-1,-1        0
                                  n  · B               (t)  · w     - n  · B               (t)  · w     +
                                        n-1,\colorblue0        1            n-1,\colorblue0        0
                                  n  · B              (t)  · w      - n  · B              (t)  · w      +
                                        n-1,\colorred1        2             n-1,\colorred1        1      
                                  n  · B                  (t)  · w  - n  · B                  (t)  · w  +
                                        n-1,\colormagenta2        3         n-1,\colormagenta2        2
                                  ...                               - n  · B     (t)  · w               +
                                                                            n-1,3        3
                                  ...                                                                    
-->
						<img
							class="LaTeX SVG"
							src="./images/chapters/derivatives/18c6e782012234a2c7425204505c8888.svg"
							width="300px"
							height="109px"
							loading="lazy"
						/>
						<p>
							Two of these terms fall way: the first term falls away because there is no -1<sup>st</sup> term in a summation. As such, it always
							contributes "nothing", so we can safely completely ignore it for the purpose of finding the derivative function. The other term is the
							very last term in this expansion: one involving <i>B<sub>n-1,n</sub></i
							>. This term would have a binomial coefficient of [<i>i</i> choose <i>i+1</i>], which is a non-existent binomial coefficient. Again,
							this term would contribute "nothing", so we can ignore it, too. This means we're left with:
						</p>
						<!--
\setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
 
                                  n  · B               (t)  · w     - n  · B               (t)  · w     +
                                        n-1,\colorblue0        1            n-1,\colorblue0        0
                                  n  · B              (t)  · w      -  n  · B              (t)  · w     +
                                        n-1,\colorred1        2              n-1,\colorred1        1     
                                  n  · B                  (t)  · w  - n  · B                  (t)  · w  +
                                        n-1,\colormagenta2        3         n-1,\colormagenta2        2
                                  ...                               
-->
						<img
							class="LaTeX SVG"
							src="./images/chapters/derivatives/f29a9d52897d2060a0c8a37073ed04fc.svg"
							width="295px"
							height="71px"
							loading="lazy"
						/>
						<p>And that's just a summation of lower order curves:</p>
						<!--
    \setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
     
             d
Bézier   (t) ── = n  · B                 (t)  · (w  - w ) + n  · B                (t)  · (w  - w ) + n  · B                    (t)  · (w  - w )  +  
      n,k    dt         (n-1),\colorblue0         1    0          (n-1),\colorred1         2    1          (n-1),\colormagenta2         3    2
                                                                        ...
-->
						<img
							class="LaTeX SVG"
							src="./images/chapters/derivatives/a7c61e0e8b42010df6dab641c92ef13d.svg"
							width="716px"
							height="36px"
							loading="lazy"
						/>
						<p>We can rewrite this as a normal summation, and we're done:</p>
						<!--
\setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
 
                 d    __ n-1                                 __ n-1
    Bézier   (t) ── = ❯      n  · B     (t)  · (w    - w ) = ❯      B     (t)  · \undersetderivative weights \underbracen  · (w    - w )
          n,k    dt   ‾‾ k=0       n-1,k         k+1    k    ‾‾ k=0  n-1,k                                                     k+1    k
-->
						<img
							class="LaTeX SVG"
							src="./images/chapters/derivatives/50616f9c922967c0c9c179af9b091947.svg"
							width="545px"
							height="51px"
							loading="lazy"
						/>
					</div>

					<p>
						Let's rewrite that in a form similar to our original formula, so we can see the difference. We will first list our original formula for
						Bézier curves, and then the derivative:
					</p>
					<!--
    \setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
     
              __ n                                                                                          n-i     i
Bézier(n,t) = ❯      \undersetbinomial term\underbrace\binomni  · \ \undersetpolynomial term\underbrace(1-t)     · t   · \
              ‾‾ i=0
                                                            \undersetweight\underbracew 
                                                                                       i
-->
					<img
						class="LaTeX SVG"
						src="./images/chapters/derivatives/b58fb122c5c8159938182c185f287142.svg"
						width="352px"
						height="55px"
						loading="lazy"
					/>
					<!--
    \setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
     
               __ k                                                                                          k-i     i
Bézier'(n,t) = ❯      \undersetbinomial term\underbrace\binomki  · \ \undersetpolynomial term\underbrace(1-t)     · t   · \ \undersetderivative 
               ‾‾ i=0
                                                 weight\underbracen  · (w    - w )  ,  with  k=n-1
                                                                         i+1    i
-->
					<img
						class="LaTeX SVG"
						src="./images/chapters/derivatives/2fc50617b6886534d1ab4638ed8a24ac.svg"
						width="533px"
						height="59px"
						loading="lazy"
					/>
					<p>
						What are the differences? In terms of the actual Bézier curve, virtually nothing! We lowered the order (rather than <i>n</i>, it's now
						<i>n-1</i>), but it's still the same Bézier function. The only real difference is in how the weights change when we derive the curve's
						function. If we have four points A, B, C, and D, then the derivative will have three points, the second derivative two, and the third
						derivative one:
					</p>
					<!--
\setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
 
                                B(n,t),           w = {A,B,C,D}   
                                B'(n,t),   n = 3, w' = {A',B',C'} = {3  · (B-A),   3  · (C-B),   3  · (D-C)}
                                B''(n,t),  n = 2, w'' = {A'',B''} = {2  · (B'-A'),   2  · (C'-B')}          
                                B'''(n,t), n = 1, w''' = {A'''}   = {1  · (B''-A'')}                        
-->
					<img
						class="LaTeX SVG"
						src="./images/chapters/derivatives/2d733684f81b65a42c4cdb3f1e589c8b.svg"
						width="523px"
						height="73px"
						loading="lazy"
					/>
					<p>
						We can keep performing this trick for as long as we have more than one weight. Once we have one weight left, the next step will see
						<i>k = 0</i>, and the result of our "Bézier function" summation is zero, because we're not adding anything at all. As such, a quadratic
						curve has no second derivative, a cubic curve has no third derivative, and generalized: an <i>n<sup>th</sup></i> order curve has
						<i>n-1</i> (meaningful) derivatives, with any further derivative being zero.
					</p>
				</section>
				<section id="pointvectors">
					<h1>
						<div class="nav"><a href="ja-JP/index.html#derivatives">previous</a><a href="ja-JP/index.html#pointvectors3d">next</a></div>
						<a href="ja-JP/index.html#pointvectors">Tangents and normals</a>
					</h1>
					<p>
						If you want to move objects along a curve, or "away from" a curve, the two vectors you're most interested in are the tangent vector and
						normal vector for curve points. These are actually really easy to find. For moving and orienting along a curve, we use the tangent, which
						indicates the direction of travel at specific points, and is literally just the first derivative of our curve:
					</p>
					<!--
\setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
 
                                                            tangent (t) = B' (t)
                                                                   x        x
                                                                                
                                                            tangent (t) = B' (t)
                                                                   y        y
-->
					<img
						class="LaTeX SVG"
						src="./images/chapters/pointvectors/8b15a314beca97071b0ccb22c969355d.svg"
						width="132px"
						height="59px"
						loading="lazy"
					/>
					<p>
						This gives us the directional vector we want. We can normalize it to give us uniform directional vectors (having a length of 1.0) at each
						point, and then do whatever it is we want to do based on those directions:
					</p>
					<!--
\setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
 
                                                                       ┌─────────────────┐
                                                                       │      2         2
                                                 d = \|tangent(t)\| =  │B' (t)  + B' (t)  
                                                                      ⟍│  x         y
                                              
                                                                       tangent (t)     B' (t)
                                              ^                               x          x    
                                              x(t) = \|tangent (t)\| =────────────── = ──────
                                                              x       \|tangent(t)\|     d
                                              
                                                                        tangent (t)     B' (t)
                                              ^                                y          y
                                              y(t) = \|tangent (t)\| = ────────────── = ──────
                                                              y        \|tangent(t)\|     d
-->
					<img
						class="LaTeX SVG"
						src="./images/chapters/pointvectors/b60cdba673c2c9fc84c800f07fd18145.svg"
						width="279px"
						height="121px"
						loading="lazy"
					/>
					<p>
						The tangent is very useful for moving along a line, but what if we want to move away from the curve instead, perpendicular to the curve at
						some point <i>t</i>? In that case we want the <em>normal</em> vector. This vector runs at a right angle to the direction of the curve, and
						is typically of length 1.0, so all we have to do is rotate the normalized directional vector and we're done:
					</p>
					<!--
\setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
 
                                 ^           \pi   ^           \pi     ^
                    normal (t) = x(t)  · cos ─── - y(t)  · sin ─── = - y(t)                                            
                          x                   2                 2
                                                                                                                       
                                                                              ^           \pi   ^           \pi    ^
                    normal (t) = \undersetquarter circle rotation \underbrace x(t)  · sin ─── + y(t)  · cos ───  = x(t)
                          y                                                                2                 2
-->
					<img
						class="LaTeX SVG"
						src="./images/chapters/pointvectors/58b19accb8a68c665ff5cbed610eea4e.svg"
						width="324px"
						height="79px"
						loading="lazy"
					/>
					<div class="note">
						<p>
							Rotating coordinates is actually very easy, if you know the rule for it. You might find it explained as "applying a
							<a href="https://en.wikipedia.org/wiki/Rotation_matrix">rotation matrix</a>, which is what we'll look at here, too. Essentially, the
							idea is to take the circles over which we can rotate, and simply "sliding the coordinates" over these circles by the desired angle. If
							we want a quarter circle turn, we take the coordinate, slide it along the circle by a quarter turn, and done.
						</p>
						<p>
							To turn any point <i>(x,y)</i> into a rotated point <i>(x',y')</i> (over 0,0) by some angle φ, we apply this nice and easy computation:
						</p>
						<!--
\setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
 
                                                   x' = x  · cos (\phi) - y  · sin (\phi)
                                                   y' = x  · sin (\phi) + y  · cos (\phi)
-->
						<img
							class="LaTeX SVG"
							src="./images/chapters/pointvectors/1df6c055ae8e41a46bfdebc55a4f17c0.svg"
							width="183px"
							height="37px"
							loading="lazy"
						/>
						<p>Which is the "long" version of the following matrix transformation:</p>
						<!--
\setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
 
                                                 ┌ x' ┐ = ┌ cos (\phi) -sin (\phi) ┐ ┌ x ┐
                                                 └ y' ┘   └ sin (\phi) cos (\phi)  ┘ └ y ┘
-->
						<img
							class="LaTeX SVG"
							src="./images/chapters/pointvectors/f02e359a5e47667919738fff69d2625b.svg"
							width="211px"
							height="40px"
							loading="lazy"
						/>
						<p>
							And that's all we need to rotate any coordinate. Note that for quarter, half, and three-quarter turns these functions become even
							easier, since <em>sin</em> and <em>cos</em> for these angles are, respectively: 0 and 1, -1 and 0, and 0 and -1.
						</p>
						<p>
							But <strong><em>why</em></strong> does this work? Why this matrix multiplication?
							<a href="https://en.wikipedia.org/wiki/Rotation_matrix#Decomposition_into_shears">Wikipedia</a> (technically, Thomas Herter and Klaus
							Lott) tells us that a rotation matrix can be treated as a sequence of three (elementary) shear operations. When we combine this into a
							single matrix operation (because all matrix multiplications can be collapsed), we get the matrix that you see above.
							<a href="https://datagenetics.com/blog/august32013/index.html">DataGenetics</a> have an excellent article about this very thing: it's
							really quite cool, and I strongly recommend taking a quick break from this primer to read that article.
						</p>
					</div>

					<p>
						The following two graphics show the tangent and normal along a quadratic and cubic curve, with the direction vector coloured blue, and the
						normal vector coloured red (the markers are spaced out evenly as <em>t</em>-intervals, not spaced equidistant).
					</p>
					<div class="figure">
						<graphics-element
							title="Quadratic Bézier tangents and normals"
							width="275"
							height="275"
							src="./chapters/pointvectors/pointvectors.js"
							data-type="quadratic"
						>
							<fallback-image>
								<span class="view-source">Scripts are disabled. Showing fallback image.</span>
								<img width="275px" height="275px" src="./images/chapters/pointvectors/f1b4e81d22f4c44d4618b0f55a1a88c5.png" loading="lazy" />
								<label>Quadratic Bézier tangents and normals</label>
							</fallback-image></graphics-element
						>
						<graphics-element
							title="Cubic Bézier tangents and normals"
							width="275"
							height="275"
							src="./chapters/pointvectors/pointvectors.js"
							data-type="cubic"
						>
							<fallback-image>
								<span class="view-source">Scripts are disabled. Showing fallback image.</span>
								<img width="275px" height="275px" src="./images/chapters/pointvectors/5863bd013ad6594f63f8dfa51ff4adc0.png" loading="lazy" />
								<label>Cubic Bézier tangents and normals</label>
							</fallback-image></graphics-element
						>
					</div>
				</section>
				<section id="pointvectors3d">
					<h1>
						<div class="nav"><a href="ja-JP/index.html#pointvectors">previous</a><a href="ja-JP/index.html#components">next</a></div>
						<a href="ja-JP/index.html#pointvectors3d">Working with 3D normals</a>
					</h1>
					<p>
						Before we move on to the next section we need to spend a little bit of time on the difference between 2D and 3D. While for many things
						this difference is irrelevant and the procedures are identical (for instance, getting the 3D tangent is just doing what we do for 2D, but
						for x, y, and z, instead of just for x and y), when it comes to normals things are a little more complex, and thus more work. Mind you,
						it's not "super hard", but there are more steps involved and we should have a look at those.
					</p>
					<p>
						Getting normals in 3D is in principle the same as in 2D: we take the normalised tangent vector, and then rotate it by a quarter turn.
						However, this is where things get that little more complex: we can turn in quite a few directions, since "the normal" in 3D is a plane,
						not a single vector, so we basically need to define what "the" normal is in the 3D case.
					</p>
					<p>
						The "naïve" approach is to construct what is known as the
						<a href="https://en.wikipedia.org/wiki/Frenet%E2%80%93Serret_formulas">Frenet normal</a>, where we follow a simple recipe that works in
						many cases (but does super bizarre things in some others). The idea is that even though there are infinitely many vectors that are
						perpendicular to the tangent (i.e. make a 90 degree angle with it), the tangent itself sort of lies on its own plane already: since each
						point on the curve (no matter how closely spaced) has its own tangent vector, we can say that each point lies in the same plane as the
						local tangent, as well as the tangents "right next to it".
					</p>
					<p>
						Even if that difference in tangent vectors is minute, "any difference" is all we need to find out what that plane is - or rather, what the
						vector perpendicular to that plane is. Which is what we need: if we can calculate that vector, and we have the tangent vector that we know
						lies on a plane, then we can rotate the tangent vector over the perpendicular, and presto. We have computed the normal using the same
						logic we used for the 2D case: "just rotate it 90 degrees".
					</p>
					<p>So let's do that! And in a twist surprise, we can do this in four lines:</p>
					<ul>
						<li><strong>a</strong> = normalize(B'(t))</li>
						<li><strong>b</strong> = normalize(<strong>a</strong> + B''(t))</li>
						<li><strong>r</strong> = normalize(<strong>b</strong> × <strong>a</strong>)</li>
						<li><strong>normal</strong> = normalize(<strong>r</strong> × <strong>a</strong>)</li>
					</ul>
					<p>Let's unpack that a little:</p>
					<ul>
						<li>
							We start by taking the <a href="https://en.wikipedia.org/wiki/Unit_vector">normalized vector</a> for the derivative at some point on the
							curve. We normalize it so the maths is less work. Less work is good.
						</li>
						<li>
							Then, we compute <strong>b</strong> which represents what a next point's tangent would be if the curve stopped changing at our point and
							just had the same derivative and second derivative from that point on.
						</li>
						<li>
							This lets us find two vectors (the derivative, and the second derivative added to the derivative) that lie on the same plane, which
							means we can use them to compute a vector perpendicular to that plane, using an elementary vector operation called the
							<a href="https://en.wikipedia.org/wiki/Cross_product">cross product</a>. (Note that while that operation uses the × operator, it's most
							definitely not a multiplication!) The result of that gives us a vector that we can use as the "axis of rotation" for turning the tangent
							a quarter circle to get our normal, just like we did in the 2D case.
						</li>
						<li>
							Since the cross product lets us find a vector that is perpendicular to some plane defined by two other vectors, and since the normal
							vector should be perpendicular to the plane that the tangent and the axis of rotation lie in, we can use the cross product a second
							time, and immediately get our normal vector.
						</li>
					</ul>
					<p>
						And then we're done, we found "the" normal vector for a 3D curve. Let's see what that looks like for a sample curve, shall we? You can
						move your cursor across the graphic from left to right, to show the normal at a point with a t value that is based on your cursor
						position: all the way on the left is 0, all the way on the right = 1, midway is t=0.5, etc:
					</p>
					<graphics-element title="Some known and unknown vectors" width="350" height="300" src="./chapters/pointvectors3d/frenet.js">
						<fallback-image>
							<span class="view-source">Scripts are disabled. Showing fallback image.</span>
							<img width="350px" height="300px" src="./images/chapters/pointvectors3d/11c1da2357004bb51cf0c591fc492115.png" loading="lazy" />
							<label></label>
						</fallback-image>
						<input type="range" min="0" max="1" step="0.01" value="0" class="slide-control" />
					</graphics-element>
					<p>
						However, if you've played with that graphic a bit, you might have noticed something odd. The normal seems to "suddenly twist around the
						curve" between t=0.65 and t=0.75... Why is it doing that?
					</p>
					<p>
						As it turns out, it's doing that because that's how the maths works, and that's the problem with Frenet normals: while they are
						"mathematically correct", they are "practically problematic", and so for any kind of graphics work what we really want is a way to compute
						normals that just... look good.
					</p>
					<p>Thankfully, Frenet normals are not our only option.</p>
					<p>
						Another option is to take a slightly more algorithmic approach and compute a form of
						<a href="https://www.microsoft.com/en-us/research/wp-content/uploads/2016/12/Computation-of-rotation-minimizing-frames.pdf"
							>Rotation Minimising Frame</a
						>
						(also known as "parallel transport frame" or "Bishop frame") instead, where a "frame" is a set made up of the tangent, the rotational
						axis, and the normal vector, centered on an on-curve point.
					</p>
					<p>
						These type of frames are computed based on "the previous frame", so we cannot simply compute these "on demand" for single points, as we
						could for Frenet frames; we have to compute them for the entire curve. Thankfully, the procedure is pretty simple, and can be performed at
						the same time that you're building lookup tables for your curve.
					</p>
					<p>
						The idea is to take a starting "tangent/rotation axis/normal" frame at t=0, and then compute what the next frame "should" look like by
						applying some rules that yield a good looking next frame. In the case of the RMF paper linked above, those rules are:
					</p>
					<ul>
						<li>Take a point on the curve for which we know the RM frame already,</li>
						<li>take a next point on the curve for which we don't know the RM frame yet, and</li>
						<li>
							reflect the known frame onto the next point, by treating the plane through the curve at the point exactly between the next and previous
							points as a "mirror".
						</li>
						<li>
							This gives the next point a tangent vector that's essentially pointing in the opposite direction of what it should be, and a normal
							that's slightly off-kilter, so:
						</li>
						<li>
							reflect the vectors of our "mirrored frame" a second time, but this time using the plane through the "next point" itself as "mirror".
						</li>
						<li>Done: the tangent and normal have been fixed, and we have a good looking frame to work with.</li>
					</ul>
					<p>So, let's write some code for that!</p>
					<div class="howtocode">
						<h3>Implementing Rotation Minimising Frames</h3>
						<p>
							We first assume we have a function for calculating the Frenet frame at a point, which we already discussed above, inn a way that it
							yields a frame with properties:
						</p>

						<table class="code">
							<tr>
								<td>1</td>
								<td rowspan="6">
									<textarea disabled rows="6" role="doc-example">
{
  o: origin of all vectors, i.e. the on-curve point,
  t: tangent vector,
  r: rotational axis vector,
  n: normal vector
}</textarea
									>
								</td>
							</tr>
							<tr>
								<td>2</td>
							</tr>
							<tr>
								<td>3</td>
							</tr>
							<tr>
								<td>4</td>
							</tr>
							<tr>
								<td>5</td>
							</tr>
							<tr>
								<td>6</td>
							</tr>
						</table>

						<p>Then, we can write a function that generates a sequence of RM frames in the following manner:</p>

						<table class="code">
							<tr>
								<td>1</td>
								<td rowspan="36">
									<textarea disabled rows="36" role="doc-example">
generateRMFrames(steps) -> frames:
  step = 1.0/steps

  // Start off with the standard tangent/axis/normal frame
  // associated with the curve at t=0:
  frames.add(getFrenetFrame(0))

  // start constructing RM frames:
  for t0 = 0, t0 < 1.0, t0 += step:
    // start with the previous, known frame
    x0 = frames.last

    // get the next frame: we're going to keep its position and tangent,
    // but we're going to recompute the axis and normal.
    t1 = t0 + step
    x1 = { o: getPoint(t1), t: getDerivative(t) }

    // First we reflect x0's tangent and axis of rotation onto x1,
    // through/ the plane of reflection at the point between x0 x1
    v1 = x1.o - x0.o
    c1 = v1 · v1
    riL = x0.r - v1 * 2/c1 * v1 · x0.r
    tiL = x0.t - v1 * 2/c1 * v1 · x0.t

    // note that v1 is a vector, but 2/c1 and (v1 · ...) are just
    // plain numbers, so we're just scaling v1 by some constant.

    // Then we reflect a second time, over a plane at x1, so that
    // the frame tangent is aligned with the curve tangent again:
    v2 = x1.t - tiL
    c2 = v2 · v2

    // and we're done here:
    x1.r = riL - v2 * 2/c2 * v2 · riL
    x1.n = x1.r × x1.t
    frames.add(x1)</textarea
									>
								</td>
							</tr>
							<tr>
								<td>2</td>
							</tr>
							<tr>
								<td>3</td>
							</tr>
							<tr>
								<td>4</td>
							</tr>
							<tr>
								<td>5</td>
							</tr>
							<tr>
								<td>6</td>
							</tr>
							<tr>
								<td>7</td>
							</tr>
							<tr>
								<td>8</td>
							</tr>
							<tr>
								<td>9</td>
							</tr>
							<tr>
								<td>10</td>
							</tr>
							<tr>
								<td>11</td>
							</tr>
							<tr>
								<td>12</td>
							</tr>
							<tr>
								<td>13</td>
							</tr>
							<tr>
								<td>14</td>
							</tr>
							<tr>
								<td>15</td>
							</tr>
							<tr>
								<td>16</td>
							</tr>
							<tr>
								<td>17</td>
							</tr>
							<tr>
								<td>18</td>
							</tr>
							<tr>
								<td>19</td>
							</tr>
							<tr>
								<td>20</td>
							</tr>
							<tr>
								<td>21</td>
							</tr>
							<tr>
								<td>22</td>
							</tr>
							<tr>
								<td>23</td>
							</tr>
							<tr>
								<td>24</td>
							</tr>
							<tr>
								<td>25</td>
							</tr>
							<tr>
								<td>26</td>
							</tr>
							<tr>
								<td>27</td>
							</tr>
							<tr>
								<td>28</td>
							</tr>
							<tr>
								<td>29</td>
							</tr>
							<tr>
								<td>30</td>
							</tr>
							<tr>
								<td>31</td>
							</tr>
							<tr>
								<td>32</td>
							</tr>
							<tr>
								<td>33</td>
							</tr>
							<tr>
								<td>34</td>
							</tr>
							<tr>
								<td>35</td>
							</tr>
							<tr>
								<td>36</td>
							</tr>
						</table>

						<p>
							Ignoring comments, this is certainly more code than when we were just computing a single Frenet frame, but it's not a crazy amount more
							code to get much better looking normals.
						</p>
					</div>

					<p>
						Speaking of better looking, what does this actually look like? Let's revisit that earlier curve, but this time use rotation minimising
						frames rather than Frenet frames:
					</p>
					<graphics-element title="Some known and unknown vectors" width="350" height="300" src="./chapters/pointvectors3d/rotation-minimizing.js">
						<fallback-image>
							<span class="view-source">Scripts are disabled. Showing fallback image.</span>
							<img width="350px" height="300px" src="./images/chapters/pointvectors3d/f4a2fa1e0204c890b2bff07228ba678d.png" loading="lazy" />
							<label></label>
						</fallback-image>
						<input type="range" min="0" max="1" step="0.01" value="0" class="slide-control" />
					</graphics-element>
					<p>That looks so much better!</p>
					<p>
						For those reading along with the code: we don't even strictly speaking need a Frenet frame to start with: we could, for instance, treat
						the z-axis as our initial axis of rotation, so that our initial normal is <strong>(0,0,1) × tangent</strong>, and then take things from
						there, but having that initial "mathematically correct" frame so that the initial normal seems to line up based on the curve's orientation
						in 3D space is just nice.
					</p>
				</section>
				<section id="components">
					<h1>
						<div class="nav"><a href="ja-JP/index.html#pointvectors3d">previous</a><a href="ja-JP/index.html#extremities">next</a></div>
						<a href="ja-JP/index.html#components">Component functions</a>
					</h1>
					<p>
						One of the first things people run into when they start using Bézier curves in their own programs is "I know how to draw the curve, but
						how do I determine the bounding box?". It's actually reasonably straightforward to do so, but it requires having some knowledge on
						exploiting math to get the values we need. For bounding boxes, we aren't actually interested in the curve itself, but only in its
						"extremities": the minimum and maximum values the curve has for its x- and y-axis values. If you remember your calculus (provided you ever
						took calculus, otherwise it's going to be hard to remember) we can determine function extremities using the first derivative of that
						function, but this poses a problem, since our function is parametric: every axis has its own function.
					</p>
					<p>
						The solution: compute the derivative for each axis separately, and then fit them back together in the same way we do for the original.
					</p>
					<p>
						Let's look at how a parametric Bézier curve "splits up" into two normal functions, one for the x-axis and one for the y-axis. Note the
						leftmost figure is again an interactive curve, without labeled axes (you get coordinates in the graph instead). The center and rightmost
						figures are the component functions for computing the x-axis value, given a value for <i>t</i> (between 0 and 1 inclusive), and the y-axis
						value, respectively.
					</p>
					<p>
						If you move points in a curve sideways, you should only see the middle graph change; likewise, moving points vertically should only show a
						change in the right graph.
					</p>
					<graphics-element
						title="Quadratic Bézier curve components"
						width="825"
						height="275"
						src="./chapters/components/components.js"
						data-type="quadratic"
					>
						<fallback-image>
							<span class="view-source">Scripts are disabled. Showing fallback image.</span>
							<img width="825px" height="275px" src="./images/chapters/components/1e6e38f6403dbe4c8b80295a94fc6748.png" loading="lazy" />
							<label></label> </fallback-image
					></graphics-element>
					<p>&nbsp;</p>
					<graphics-element
						title="Cubic Bézier curve components"
						width="825"
						height="275"
						src="./chapters/components/components.js"
						data-type="cubic"
					>
						<fallback-image>
							<span class="view-source">Scripts are disabled. Showing fallback image.</span>
							<img width="825px" height="275px" src="./images/chapters/components/348694339257428a260144da4bbf80fc.png" loading="lazy" />
							<label></label> </fallback-image
					></graphics-element>
				</section>
				<section id="extremities">
					<h1>
						<div class="nav"><a href="ja-JP/index.html#components">previous</a><a href="ja-JP/index.html#boundingbox">next</a></div>
						<a href="ja-JP/index.html#extremities">Finding extremities: root finding</a>
					</h1>
					<p>
						Now that we understand (well, superficially anyway) the component functions, we can find the extremities of our Bézier curve by finding
						maxima and minima on the component functions, by solving the equation B'(t) = 0. We've already seen that the derivative of a Bézier curve
						is a simpler Bézier curve, but how do we solve the equality? Fairly easily, actually, until our derivatives are 4th order or higher...
						then things get really hard. But let's start simple:
					</p>
					<h3>Quadratic curves: linear derivatives.</h3>
					<p>
						The derivative of a quadratic Bézier curve is a linear Bézier curve, interpolating between just two terms, which means finding the
						solution for "where is this line 0" is effectively trivial by rewriting it to a function of <code>t</code> and solving. First we turn our
						cubic Bézier function into a quadratic one, by following the rule mentioned at the end of the
						<a href="#derivatives">derivatives section</a>:
					</p>
					<!--
\setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
 
                                                         B'(t) = a(1-t) + b(t)= 0,
                                                                   a - at + bt= 0,
                                                                    (b-a)t + a= 0 
-->
					<img
						class="LaTeX SVG"
						src="./images/chapters/extremities/55e16ef652d30face0f6586b675a6c7b.svg"
						width="187px"
						height="63px"
						loading="lazy"
					/>
					<p>And then we turn this into our solution for <code>t</code> using basic arithmetics:</p>
					<!--
\setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
 
                                                              (b-a)t + a= 0, 
                                                                  (b-a)t= -a,
                                                                          -a 
                                                                       t= ───
                                                                          b-a
-->
					<img
						class="LaTeX SVG"
						src="./images/chapters/extremities/1fab66c84e7df38a2edda147f939bd80.svg"
						width="135px"
						height="77px"
						loading="lazy"
					/>
					<p>Done.</p>
					<p>
						Although with the <a href="https://en.wikipedia.org/wiki/Caveat_emptor#Caveat_lector">caveat</a> that if <code>b-a</code> is zero, there
						is no solution and we probably shouldn't try to perform that division.
					</p>
					<h3>Cubic curves: the quadratic formula.</h3>
					<p>
						The derivative of a cubic Bézier curve is a quadratic Bézier curve, and finding the roots for a quadratic polynomial means we can apply
						the <a href="https://en.wikipedia.org/wiki/Quadratic_formula">Quadratic formula</a>. If you've seen it before, you'll remember it, and if
						you haven't, it looks like this:
					</p>
					<!--
\setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
 
                                                                                         ┌────────┐
                                                                                         │ 2
                                                        2                           -b ±⟍│b  - 4ac
                                         Given f(t) = at  + bt + c, f(t)=0 when t = ───────────────
                                                                                          2a
-->
					<img
						class="LaTeX SVG"
						src="./images/chapters/extremities/2c398b492aadc90eb4e4853fc20b23e9.svg"
						width="411px"
						height="40px"
						loading="lazy"
					/>
					<p>
						So, if we can rewrite the Bézier component function as a plain polynomial, we're done: we just plug in the values into the quadratic
						formula, check if that square root is negative or not (if it is, there are no roots) and then just compute the two values that come out
						(because of that plus/minus sign we get two). Any value between 0 and 1 is a root that matters for Bézier curves, anything below or above
						that is irrelevant (because Bézier curves are only defined over the interval [0,1]). So, how do we convert?
					</p>
					<p>
						First we turn our cubic Bézier function into a quadratic one, by following the rule mentioned at the end of the
						<a href="#derivatives">derivatives section</a>:
					</p>
					<!--
\setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
 
                                 B(t) uses { p ,p ,p ,p  }                                                 
                                              1  2  3  4                                                   
                                 B'(t) uses { v ,v ,v  }, where v  = 3(p -p ), v  = 3(p -p ), v  = 3(p -p )
                                               1  2  3           1      2  1    2      3  2    3      4  3
-->
					<img
						class="LaTeX SVG"
						src="./images/chapters/extremities/c4858be225d004441b2aefedacda89a3.svg"
						width="537px"
						height="36px"
						loading="lazy"
					/>
					<p>And then, using these <em>v</em> values, we can find out what our <em>a</em>, <em>b</em>, and <em>c</em> should be:</p>
					<!--
\setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
 
                                                             2                  2
                                               B'(t)= v (1-t)  + 2v (1-t)t + v t            
                                                       1           2          3
                                                          2                    2       2
                                                 ...= v (t  - 2t + 1) + 2v (t-t ) + v t     
                                                       1                  2          3
                                                         2                          2      2
                                                 ...= v t  - 2v t + v  + 2v t - 2v t  + v t 
                                                       1       1     1     2      2      3
                                                         2       2      2
                                                 ...= v t  - 2v t  + v t  - 2v t + v  + 2v t
                                                       1       2      3       1     1     2
                                                                  2
                                                 ...= (v -2v +v )t  + 2(v -v )t + v         
                                                        1   2  3         2  1      1
-->
					<img
						class="LaTeX SVG"
						src="./images/chapters/extremities/d1c65d927825f20c3c358d1ff96ce881.svg"
						width="315px"
						height="119px"
						loading="lazy"
					/>
					<p>
						This gives us three coefficients {a, b, c} that are expressed in terms of <code>v</code> values, where the <code>v</code> values are
						expressions of our original coordinate values, so we can do some substitution to get:
					</p>
					<!--
\setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
 
                                                   a= v -2v +v  = 3(-p  + 3p  - 3p  + p )
                                                       1   2  3       1     2     3    4
                                                   b= 2(v -v ) = 6(p  - 2p  + p )        
                                                         2  1       1     2    3
                                                   c= v  = 3(p -p )                      
                                                       1      2  1
-->
					<img
						class="LaTeX SVG"
						src="./images/chapters/extremities/a6acf08f43aa1f48c08a40e76bdd2a31.svg"
						width="308px"
						height="63px"
						loading="lazy"
					/>
					<p>Easy-peasy. We can now almost trivially find the roots by plugging those values into the quadratic formula.</p>
					<p>
						And as a cubic curve, there is also a meaningful second derivative, which we can compute by simple taking the derivative of the
						derivative.
					</p>
					<h3>Quartic curves: Cardano's algorithm.</h3>
					<p>
						We haven't really looked at them before now, but the next step up would be a Quartic curve, a fourth degree Bézier curve. As expected,
						these have a derivative that is a cubic function, and now things get much harder. Cubic functions don't have a "simple" rule to find their
						roots, like the quadratic formula, and instead require quite a bit of rewriting to a form that we can even start to try to solve.
					</p>
					<p>
						Back in the 16<sup>th</sup> century, before Bézier curves were a thing, and even before <em>calculus itself</em> was a thing,
						<a href="https://en.wikipedia.org/wiki/Gerolamo_Cardano">Gerolamo Cardano</a> figured out that even if the general cubic function is
						really hard to solve, it can be rewritten to a form for which finding the roots is "easier" (even if not "easy"):
					</p>
					<!--
\setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
 
                                                                      3     2
                                                   very hard: solve at  + bt  + ct + d = 0
                                                                     3
                                                      easier: solve t  + pt + q = 0       
-->
					<img
						class="LaTeX SVG"
						src="./images/chapters/extremities/d31432533bd7940545d4a269eefbabf2.svg"
						width="253px"
						height="44px"
						loading="lazy"
					/>
					<p>
						We can see that the easier formula only has two constants, rather than four, and only two expressions involving <code>t</code>, rather
						than three: this makes things considerably easier to solve because it lets us use
						<a href="https://www.wolframalpha.com/input/?i=t%5E3+%2B+pt+%2B+q">regular calculus</a> to find the values that satisfy the equation.
					</p>
					<p>
						Now, there is one small hitch: as a cubic function, the solutions may be
						<a href="https://en.wikipedia.org/wiki/Complex_number">complex numbers</a> rather than plain numbers... And Cardano realised this,
						centuries before complex numbers were a well-understood and established part of number theory. His interpretation of them was "these
						numbers are impossible but that's okay because they disappear again in later steps", allowing him to not think about them too much, but we
						have it even easier: as we're trying to find the roots for display purposes, we don't even <em>care</em> about complex numbers: we're
						going to simplify Cardano's approach just that tiny bit further by throwing away any solution that's not a plain number.
					</p>
					<p>
						So, how do we rewrite the hard formula into the easier formula? This is explained in detail over at
						<a href="https://trans4mind.com/personal_development/mathematics/polynomials/cubicAlgebra.htm">Ken J. Ward's page</a> for solving the
						cubic equation, so instead of showing the maths, I'm simply going to show the programming code for solving the cubic equation, with the
						complex roots getting totally ignored, but if you're interested you should definitely head over to Ken's page and give the procedure a
						read-through.
					</p>
					<div class="howtocode">
						<h3>Implementing Cardano's algorithm for finding all real roots</h3>
						<p>
							The "real roots" part is fairly important, because while you cannot take a square, cube, etc. root of a negative number in the "real"
							number space (denoted with ℝ), this is perfectly fine in the
							<a href="https://en.wikipedia.org/wiki/Complex_number">"complex" number</a> space (denoted with ℂ). And, as it so happens, Cardano is
							also attributed as the first mathematician in history to have made use of complex numbers in his calculations. For this very algorithm!
						</p>

						<table class="code">
							<tr>
								<td>1</td>
								<td rowspan="81">
									<textarea disabled rows="81" role="doc-example">
// A helper function to filter for values in the [0,1] interval:
function accept(t) {
  return 0<=t && t <=1;
}

// A real-cuberoots-only function:
function cuberoot(v) {
  if(v<0) return -pow(-v,1/3);
  return pow(v,1/3);
}

// Now then: given cubic coordinates {pa, pb, pc, pd} find all roots.
function getCubicRoots(pa, pb, pc, pd) {
  var   a = (3*pa - 6*pb + 3*pc),
        b = (-3*pa + 3*pb),
        c = pa,
        d = (-pa + 3*pb - 3*pc + pd);

  // do a check to see whether we even need cubic solving:
  if (approximately(d,0)) {
    // this is not a cubic curve.
    if (approximately(a,0)) {
      // in fact, this is not a quadratic curve either.
      if (approximately(b,0)) {
        // in fact in fact, there are no solutions.
        return [];
      }
      // linear solution
      return [-c / b].filter(accept);
    }
    // quadratic solution
    var q = sqrt(b*b - 4*a*c), 2a = 2*a;
    return [(q-b)/2a, (-b-q)/2a].filter(accept)
  }

  // at this point, we know we need a cubic solution.

  a /= d;
  b /= d;
  c /= d;

  var p = (3*b - a*a)/3,
      p3 = p/3,
      q = (2*a*a*a - 9*a*b + 27*c)/27,
      q2 = q/2,
      discriminant = q2*q2 + p3*p3*p3;

  // and some variables we're going to use later on:
  var u1, v1, root1, root2, root3;

  // three possible real roots:
  if (discriminant < 0) {
    var mp3  = -p/3,
    mp33 = mp3*mp3*mp3,
    r    = sqrt( mp33 ),
    t    = -q / (2*r),
    cosphi = t<-1 ? -1 : t>1 ? 1 : t,
    phi  = acos(cosphi),
    crtr = cuberoot(r),
    t1   = 2*crtr;
    root1 = t1 * cos(phi/3) - a/3;
    root2 = t1 * cos((phi+2*pi)/3) - a/3;
    root3 = t1 * cos((phi+4*pi)/3) - a/3;
    return [root1, root2, root3].filter(accept);
  }

  // three real roots, but two of them are equal:
  if(discriminant === 0) {
    u1 = q2 < 0 ? cuberoot(-q2) : -cuberoot(q2);
    root1 = 2*u1 - a/3;
    root2 = -u1 - a/3;
    return [root1, root2].filter(accept);
  }

  // one real root, two complex roots
  var sd = sqrt(discriminant);
  u1 = cuberoot(sd - q2);
  v1 = cuberoot(sd + q2);
  root1 = u1 - v1 - a/3;
  return [root1].filter(accept);
}</textarea
									>
								</td>
							</tr>
							<tr>
								<td>2</td>
							</tr>
							<tr>
								<td>3</td>
							</tr>
							<tr>
								<td>4</td>
							</tr>
							<tr>
								<td>5</td>
							</tr>
							<tr>
								<td>6</td>
							</tr>
							<tr>
								<td>7</td>
							</tr>
							<tr>
								<td>8</td>
							</tr>
							<tr>
								<td>9</td>
							</tr>
							<tr>
								<td>10</td>
							</tr>
							<tr>
								<td>11</td>
							</tr>
							<tr>
								<td>12</td>
							</tr>
							<tr>
								<td>13</td>
							</tr>
							<tr>
								<td>14</td>
							</tr>
							<tr>
								<td>15</td>
							</tr>
							<tr>
								<td>16</td>
							</tr>
							<tr>
								<td>17</td>
							</tr>
							<tr>
								<td>18</td>
							</tr>
							<tr>
								<td>19</td>
							</tr>
							<tr>
								<td>20</td>
							</tr>
							<tr>
								<td>21</td>
							</tr>
							<tr>
								<td>22</td>
							</tr>
							<tr>
								<td>23</td>
							</tr>
							<tr>
								<td>24</td>
							</tr>
							<tr>
								<td>25</td>
							</tr>
							<tr>
								<td>26</td>
							</tr>
							<tr>
								<td>27</td>
							</tr>
							<tr>
								<td>28</td>
							</tr>
							<tr>
								<td>29</td>
							</tr>
							<tr>
								<td>30</td>
							</tr>
							<tr>
								<td>31</td>
							</tr>
							<tr>
								<td>32</td>
							</tr>
							<tr>
								<td>33</td>
							</tr>
							<tr>
								<td>34</td>
							</tr>
							<tr>
								<td>35</td>
							</tr>
							<tr>
								<td>36</td>
							</tr>
							<tr>
								<td>37</td>
							</tr>
							<tr>
								<td>38</td>
							</tr>
							<tr>
								<td>39</td>
							</tr>
							<tr>
								<td>40</td>
							</tr>
							<tr>
								<td>41</td>
							</tr>
							<tr>
								<td>42</td>
							</tr>
							<tr>
								<td>43</td>
							</tr>
							<tr>
								<td>44</td>
							</tr>
							<tr>
								<td>45</td>
							</tr>
							<tr>
								<td>46</td>
							</tr>
							<tr>
								<td>47</td>
							</tr>
							<tr>
								<td>48</td>
							</tr>
							<tr>
								<td>49</td>
							</tr>
							<tr>
								<td>50</td>
							</tr>
							<tr>
								<td>51</td>
							</tr>
							<tr>
								<td>52</td>
							</tr>
							<tr>
								<td>53</td>
							</tr>
							<tr>
								<td>54</td>
							</tr>
							<tr>
								<td>55</td>
							</tr>
							<tr>
								<td>56</td>
							</tr>
							<tr>
								<td>57</td>
							</tr>
							<tr>
								<td>58</td>
							</tr>
							<tr>
								<td>59</td>
							</tr>
							<tr>
								<td>60</td>
							</tr>
							<tr>
								<td>61</td>
							</tr>
							<tr>
								<td>62</td>
							</tr>
							<tr>
								<td>63</td>
							</tr>
							<tr>
								<td>64</td>
							</tr>
							<tr>
								<td>65</td>
							</tr>
							<tr>
								<td>66</td>
							</tr>
							<tr>
								<td>67</td>
							</tr>
							<tr>
								<td>68</td>
							</tr>
							<tr>
								<td>69</td>
							</tr>
							<tr>
								<td>70</td>
							</tr>
							<tr>
								<td>71</td>
							</tr>
							<tr>
								<td>72</td>
							</tr>
							<tr>
								<td>73</td>
							</tr>
							<tr>
								<td>74</td>
							</tr>
							<tr>
								<td>75</td>
							</tr>
							<tr>
								<td>76</td>
							</tr>
							<tr>
								<td>77</td>
							</tr>
							<tr>
								<td>78</td>
							</tr>
							<tr>
								<td>79</td>
							</tr>
							<tr>
								<td>80</td>
							</tr>
							<tr>
								<td>81</td>
							</tr>
						</table>
					</div>

					<p>
						And that's it. The maths is complicated, but the code is pretty much just "follow the maths, while caching as many values as we can to
						prevent recomputing things as much as possible" and now we have a way to find all roots for a cubic function and can just move on with
						using that to find extremities of our curves.
					</p>
					<p>
						And of course, as a quartic curve also has meaningful second and third derivatives, we can quite easily compute those by using the
						derivative of the derivative (of the derivative), just as for cubic curves.
					</p>
					<h3>Quintic and higher order curves: finding numerical solutions</h3>
					<p>
						And this is where thing stop, because we <em>cannot</em> find the roots for polynomials of degree 5 or higher using algebra (a fact known
						as <a href="https://en.wikipedia.org/wiki/Abel%E2%80%93Ruffini_theorem">the Abel–Ruffini theorem</a>). Instead, for occasions like these,
						where algebra simply cannot yield an answer, we turn to <a href="https://en.wikipedia.org/wiki/Numerical_analysis">numerical analysis</a>.
					</p>
					<p>
						That's a fancy term for saying "rather than trying to find exact answers by manipulating symbols, find approximate answers by describing
						the underlying process as a combination of steps, each of which <em>can</em> be assigned a number via symbolic manipulation". For example,
						trying to mathematically compute how much water fits in a completely crazy three dimensional shape is very hard, even if it got you the
						perfect, precise answer. A much easier approach, which would be less perfect but still entirely useful, would be to just grab a buck and
						start filling the shape until it was full: just count the number of buckets of water you used. And if we want a more precise answer, we
						can use smaller buckets.
					</p>
					<p>
						So that's what we're going to do here, too: we're going to treat the problem as a sequence of steps, and the smaller we can make each
						step, the closer we'll get to that "perfect, precise" answer. And as it turns out, there is a really nice numerical root-finding
						algorithm, called the <a href="https://en.wikipedia.org/wiki/Newton-Raphson">Newton-Raphson</a> root finding method (yes, after
						<em><a href="https://en.wikipedia.org/wiki/Isaac_Newton">that</a></em> Newton), which we can make use of. The Newton-Raphson approach
						consists of taking our impossible-to-solve function <code>f(x)</code>, picking some initial value <code>x</code> (literally any value will
						do), and calculating <code>f(x)</code>. We can think of that value as the "height" of the function at <code>x</code>. If that height is
						zero, we're done, we have found a root. If it isn't, we calculate the tangent line at <code>f(x)</code> and calculate at which
						<code>x</code> value <em>its</em> height is zero (which we've already seen is very easy). That will give us a new <code>x</code> and we
						repeat the process until we find a root.
					</p>
					<p>
						Mathematically, this means that for some <code>x</code>, at step <code>n=1</code>, we perform the following calculation until
						<code>f<sub>y</sub>(x)</code> is zero, so that the next <code>t</code> is the same as the one we already have:
					</p>
					<!--
\setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
 
                                                                        f (x )
                                                                         y  n
                                                            x    = x  - ───────
                                                             n+1    n   f' (x )
                                                                          y  n
-->
					<img
						class="LaTeX SVG"
						src="./images/chapters/extremities/53e67a29f134bd561aca550a2091a196.svg"
						width="132px"
						height="45px"
						loading="lazy"
					/>
					<p>(The Wikipedia article has a decent animation for this process, so I will not add a graphic for that here)</p>
					<p>
						Now, this works well only if we can pick good starting points, and our curve is
						<a href="https://en.wikipedia.org/wiki/Continuous_function">continuously differentiable</a> and doesn't have
						<a href="https://en.wikipedia.org/wiki/Oscillation_(mathematics)">oscillations</a>. Glossing over the exact meaning of those terms, the
						curves we're dealing with conform to those constraints, so as long as we pick good starting points, this will work. So the question is:
						which starting points do we pick?
					</p>
					<p>
						As it turns out, Newton-Raphson is so blindingly fast that we could get away with just not picking: we simply run the algorithm from
						<em>t=0</em> to <em>t=1</em> at small steps (say, 1/200<sup>th</sup>) and the result will be all the roots we want. Of course, this may
						pose problems for high order Bézier curves: 200 steps for a 200<sup>th</sup> order Bézier curve is going to go wrong, but that's okay:
						there is no reason (at least, none that I know of) to <em>ever</em> use Bézier curves of crazy high orders. You might use a fifth order
						curve to get the "nicest still remotely workable" approximation of a full circle with a single Bézier curve, but that's pretty much as
						high as you'll ever need to go.
					</p>
					<h3>In conclusion:</h3>
					<p>
						So now that we know how to do root finding, we can determine the first and second derivative roots for our Bézier curves, and show those
						roots overlaid on the previous graphics. For the quadratic curve, that means just the first derivative, in red:
					</p>
					<graphics-element
						title="Quadratic Bézier curve extremities"
						width="825"
						height="275"
						src="./chapters/extremities/extremities.js"
						data-type="quadratic"
					>
						<fallback-image>
							<span class="view-source">Scripts are disabled. Showing fallback image.</span>
							<img width="825px" height="275px" src="./images/chapters/extremities/fd68347a917c9b703ff8005287ac6ca4.png" loading="lazy" />
							<label></label> </fallback-image
					></graphics-element>
					<p>And for cubic curves, that means first and second derivatives, in red and purple respectively:</p>
					<graphics-element
						title="Cubic Bézier curve extremities"
						width="825"
						height="275"
						src="./chapters/extremities/extremities.js"
						data-type="cubic"
					>
						<fallback-image>
							<span class="view-source">Scripts are disabled. Showing fallback image.</span>
							<img width="825px" height="275px" src="./images/chapters/extremities/fbfe9464c9653f5efcd04411e683faf9.png" loading="lazy" />
							<label></label> </fallback-image
					></graphics-element>
				</section>
				<section id="boundingbox">
					<h1>
						<div class="nav"><a href="ja-JP/index.html#extremities">previous</a><a href="ja-JP/index.html#aligning">next</a></div>
						<a href="ja-JP/index.html#boundingbox">Bounding boxes</a>
					</h1>
					<p>
						If we have the extremities, and the start/end points, a simple for-loop that tests for min/max values for x and y means we have the four
						values we need to box in our curve:
					</p>
					<p><em>Computing the bounding box for a Bézier curve</em>:</p>
					<ol>
						<li>Find all <em>t</em> value(s) for the curve derivative's x- and y-roots.</li>
						<li>Discard any <em>t</em> value that's lower than 0 or higher than 1, because Bézier curves only use the interval [0,1].</li>
						<li>
							Determine the lowest and highest value when plugging the values <em>t=0</em>, <em>t=1</em> and each of the found roots into the original
							functions: the lowest value is the lower bound, and the highest value is the upper bound for the bounding box we want to construct.
						</li>
					</ol>
					<p>
						Applying this approach to our previous root finding, we get the following
						<a href="https://en.wikipedia.org/wiki/Bounding_volume#Common_types">axis-aligned bounding boxes</a> (with all curve extremity points
						shown on the curve):
					</p>
					<div class="figure">
						<graphics-element
							title="Quadratic Bézier bounding box"
							width="275"
							height="275"
							src="./chapters/boundingbox/bbox.js"
							data-type="quadratic"
						>
							<fallback-image>
								<span class="view-source">Scripts are disabled. Showing fallback image.</span>
								<img width="275px" height="275px" src="./images/chapters/boundingbox/12ec4a5039de2e2cc06611db5e826282.png" loading="lazy" />
								<label>Quadratic Bézier bounding box</label>
							</fallback-image></graphics-element
						>
						<graphics-element title="Cubic Bézier bounding box" width="275" height="275" src="./chapters/boundingbox/bbox.js" data-type="cubic">
							<fallback-image>
								<span class="view-source">Scripts are disabled. Showing fallback image.</span>
								<img width="275px" height="275px" src="./images/chapters/boundingbox/daad01218ba430e2355d151811aa971b.png" loading="lazy" />
								<label>Cubic Bézier bounding box</label>
							</fallback-image></graphics-element
						>
					</div>

					<p>
						We can construct even nicer boxes by aligning them along our curve, rather than along the x- and y-axis, but in order to do so we first
						need to look at how aligning works.
					</p>
				</section>
				<section id="aligning">
					<h1>
						<div class="nav"><a href="ja-JP/index.html#boundingbox">previous</a><a href="ja-JP/index.html#tightbounds">next</a></div>
						<a href="ja-JP/index.html#aligning">Aligning curves</a>
					</h1>
					<p>
						While there are an incredible number of curves we can define by varying the x- and y-coordinates for the control points, not all curves
						are actually distinct. For instance, if we define a curve, and then rotate it 90 degrees, it's still the same curve, and we'll find its
						extremities in the same spots, just at different draw coordinates. As such, one way to make sure we're working with a "unique" curve is to
						"axis-align" it.
					</p>
					<p>
						Aligning also simplifies a curve's functions. We can translate (move) the curve so that the first point lies on (0,0), which turns our
						<em>n</em> term polynomial functions into <em>n-1</em> term functions. The order stays the same, but we have less terms. Then, we can
						rotate the curves so that the last point always lies on the x-axis, too, making its coordinate (...,0). This further simplifies the
						function for the y-component to an <em>n-2</em> term function. For instance, if we have a cubic curve such as this:
					</p>
					<!--
\setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
 
       ╭                           3                              2                                         2                      3
       ╡ x = \colorblue120  · (1-t)  \colorblue + 35  · 3  · (1-t)   · t \colorblue + 220  · 3  · (1-t)  · t  \colorblue + 220  · t  
       │                           3                               2                                         2                     3
       ╰ y = \colorblue160  · (1-t)  \colorblue + 200  · 3  · (1-t)   · t \colorblue + 260  · 3  · (1-t)  · t  \colorblue + 40  · t 
-->
					<img class="LaTeX SVG" src="./images/chapters/aligning/00480d8ea1d0b86eb66939bced85e14b.svg" width="497px" height="40px" loading="lazy" />
					<p>
						Then translating it so that the first coordinate lies on (0,0), moving all <em>x</em> coordinates by -120, and all <em>y</em> coordinates
						by -160, gives us:
					</p>
					<!--
\setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
 
        ╭                         3                              2                                         2                      3
        ╡ x = \colorblue0  · (1-t)  \colorblue - 85  · 3  · (1-t)   · t \colorblue + 100  · 3  · (1-t)  · t  \colorblue + 100  · t  
        │                         3                              2                                         2                      3
        ╰ y = \colorblue0  · (1-t)  \colorblue + 40  · 3  · (1-t)   · t \colorblue + 100  · 3  · (1-t)  · t  \colorblue - 120  · t 
-->
					<img class="LaTeX SVG" src="./images/chapters/aligning/6acf1a1e496f47c11e079a1d13f0a368.svg" width="481px" height="40px" loading="lazy" />
					<p>
						If we then rotate the curve so that its end point lies on the x-axis, the coordinates (integer-rounded for illustrative purposes here)
						become:
					</p>
					<!--
\setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
 
        ╭                         3                              2                                        2                      3
        ╡ x = \colorblue0  · (1-t)  \colorblue - 85  · 3  · (1-t)   · t \colorblue - 12  · 3  · (1-t)  · t  \colorblue + 156  · t  
        │                         3                              2                                         2                    3
        ╰ y = \colorblue0  · (1-t)  \colorblue - 40  · 3  · (1-t)   · t \colorblue + 140  · 3  · (1-t)  · t  \colorblue + 0  · t 
-->
					<img class="LaTeX SVG" src="./images/chapters/aligning/f6767b16ff8e04646f45fb9a1f3e4024.svg" width="473px" height="40px" loading="lazy" />
					<p>If we drop all the zero-terms, this gives us:</p>
					<!--
\setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
 
                   ╭                                  2                                        2                      3
                   ╡ x = \colorblue - 85  · 3  · (1-t)   · t \colorblue - 12  · 3  · (1-t)  · t  \colorblue + 156  · t  
                   │                                  2                                         2
                   ╰ y = \colorblue - 40  · 3  · (1-t)   · t \colorblue + 140  · 3  · (1-t)  · t                       
-->
					<img class="LaTeX SVG" src="./images/chapters/aligning/a75137c250be63877a30f4bda8d801f8.svg" width="408px" height="40px" loading="lazy" />
					<p>
						We can see that our original curve definition has been simplified considerably. The following graphics illustrate the result of aligning
						our example curves to the x-axis, with the cubic case using the coordinates that were just used in the example formulae:
					</p>
					<graphics-element title="Aligning a quadratic curve" width="550" height="275" src="./chapters/aligning/aligning.js" data-type="quadratic">
						<fallback-image>
							<span class="view-source">Scripts are disabled. Showing fallback image.</span>
							<img width="550px" height="275px" src="./images/chapters/aligning/28cc0f129fa0c028a1addd702e99f162.png" loading="lazy" />
							<label></label> </fallback-image
					></graphics-element>
					<p>&nbsp;</p>
					<graphics-element title="Aligning a cubic curve" width="550" height="275" src="./chapters/aligning/aligning.js" data-type="cubic">
						<fallback-image>
							<span class="view-source">Scripts are disabled. Showing fallback image.</span>
							<img width="550px" height="275px" src="./images/chapters/aligning/9a6755a1e31a990e8f072a6da98f811a.png" loading="lazy" />
							<label></label> </fallback-image
					></graphics-element>
				</section>
				<section id="tightbounds">
					<h1>
						<div class="nav"><a href="ja-JP/index.html#aligning">previous</a><a href="ja-JP/index.html#inflections">next</a></div>
						<a href="ja-JP/index.html#tightbounds">Tight bounding boxes</a>
					</h1>
					<p>
						With our knowledge of bounding boxes, and curve alignment, We can now form the "tight" bounding box for curves. We first align our curve,
						recording the translation we performed, "T", and the rotation angle we used, "R". We then determine the aligned curve's normal bounding
						box. Once we have that, we can map that bounding box back to our original curve by rotating it by -R, and then translating it by -T.
					</p>
					<p>We now have nice tight bounding boxes for our curves:</p>
					<div class="figure">
						<graphics-element
							title="Aligning a quadratic curve"
							width="275"
							height="275"
							src="./chapters/tightbounds/tightbounds.js"
							data-type="quadratic"
						>
							<fallback-image>
								<span class="view-source">Scripts are disabled. Showing fallback image.</span>
								<img width="275px" height="275px" src="./images/chapters/tightbounds/ed91133976018ec032d9115344debb36.png" loading="lazy" />
								<label>Aligning a quadratic curve</label>
							</fallback-image></graphics-element
						>
						<graphics-element title="Aligning a cubic curve" width="275" height="275" src="./chapters/tightbounds/tightbounds.js" data-type="cubic">
							<fallback-image>
								<span class="view-source">Scripts are disabled. Showing fallback image.</span>
								<img width="275px" height="275px" src="./images/chapters/tightbounds/9ee5abc64b3fba71e284c70539279d74.png" loading="lazy" />
								<label>Aligning a cubic curve</label>
							</fallback-image></graphics-element
						>
					</div>

					<p>
						These are, strictly speaking, not necessarily the tightest possible bounding boxes. It is possible to compute the optimal bounding box by
						determining which spanning lines we need to effect a minimal box area, but because of the parametric nature of Bézier curves this is
						actually a rather costly operation, and the gain in bounding precision is often not worth it.
					</p>
				</section>
				<section id="inflections">
					<h1>
						<div class="nav"><a href="ja-JP/index.html#tightbounds">previous</a><a href="ja-JP/index.html#canonical">next</a></div>
						<a href="ja-JP/index.html#inflections">Curve inflections</a>
					</h1>
					<p>
						Now that we know how to align a curve, there's one more thing we can calculate: inflection points. Imagine we have a variable size circle
						that we can slide up against our curve. We place it against the curve and adjust its radius so that where it touches the curve, the
						curvatures of the curve and the circle are the same, and then we start to slide the circle along the curve - for quadratic curves, we can
						always do this without the circle behaving oddly: we might have to change the radius of the circle as we slide it along, but it'll always
						sit against the same side of the curve.
					</p>
					<p>
						But what happens with cubic curves? Imagine we have an S curve and we place our circle at the start of the curve, and start sliding it
						along. For a while we can simply adjust the radius and things will be fine, but once we get to the midpoint of that S, something odd
						happens: the circle "flips" from one side of the curve to the other side, in order for the curvatures to keep matching. This is called an
						inflection, and we can find out where those happen relatively easily.
					</p>
					<p>What we need to do is solve a simple equation:</p>
					<!--
\setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
 
                                                                  C(t) = 0
-->
					<img class="LaTeX SVG" src="./images/chapters/inflections/ed68dcfb203517ca080fe48914769fb0.svg" width="59px" height="16px" loading="lazy" />
					<p>
						What we're saying here is that given the curvature function <em>C(t)</em>, we want to know for which values of <em>t</em> this function is
						zero, meaning there is no "curvature", which will be exactly at the point between our circle being on one side of the curve, and our
						circle being on the other side of the curve. So what does <em>C(t)</em> look like? Actually something that seems not too hard:
					</p>
					<!--
\setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
 
                     C(t) =  Bézier \prime(t)  ·  Bézier \prime\prime(t) -  Bézier \prime(t)  ·  Bézier \prime\prime(t)
                                   x                    y                         y                    x
-->
					<img
						class="LaTeX SVG"
						src="./images/chapters/inflections/a283e01df17f3d763ec89621f2af6c5c.svg"
						width="385px"
						height="21px"
						loading="lazy"
					/>
					<p>
						The function <em>C(t)</em> is the cross product between the first and second derivative functions for the parametric dimensions of our
						curve. And, as already shown, derivatives of Bézier curves are just simpler Bézier curves, with very easy to compute new coefficients, so
						this should be pretty easy.
					</p>
					<p>
						However as we've seen in the section on aligning, aligning lets us simplify things <em>a lot</em>, by completely removing the
						contributions of the first coordinate from most mathematical evaluations, and removing the last <em>y</em> coordinate as well by virtue of
						the last point lying on the x-axis. So, while we can evaluate <em>C(t) = 0</em> for our curve, it'll be much easier to first axis-align
						the curve and <em>then</em> evaluating the curvature function.
					</p>
					<div class="note">
						<h3>Let's derive the full formula anyway</h3>
						<p>
							Of course, before we do our aligned check, let's see what happens if we compute the curvature function without axis-aligning. We start
							with the first and second derivatives, given our basis functions:
						</p>
						<!--
\setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
 
                                                 3           2             2      3
                              Bézier(t) = x (1-t)  + 3x (1-t) t + 3x (1-t)t  + x t                            
                                           1           2            3           4
                                    \prime            2                2                                      
                              Bézier      (t) = a(1-t)  + 2b(1-t)t + ct   { a=3(x -x ),b=3(x -x ),c=3(x -x ) }
                                                                                 2  1       3  2       4  3   
                                    \prime\prime
                              Bézier            (t) = u(1-t) + vt {u=2(b-a),v=2(c-b)}\                        
-->
						<img
							class="LaTeX SVG"
							src="./images/chapters/inflections/f9f2258e59b038659087a5e87ba2e0af.svg"
							width="601px"
							height="71px"
							loading="lazy"
						/>
						<p>And of course the same functions for <em>y</em>:</p>
						<!--
\setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
 
                                                               3           2             2      3
                                            Bézier(t) = y (1-t)  + 3y (1-t) t + 3y (1-t)t  + y t 
                                                         1           2            3           4
                                                  \prime            2                2           
                                            Bézier      (t) = d(1-t)  + 2e(1-t)t + ft            
                                                  \prime\prime
                                            Bézier            (t) = w(1-t) + zt                  
-->
						<img
							class="LaTeX SVG"
							src="./images/chapters/inflections/be9e409d619ecd735b0fbc219bec6d07.svg"
							width="399px"
							height="69px"
							loading="lazy"
						/>
						<p>
							Asking a computer to now compose the <em>C(t)</em> function for us (and to expand it to a readable form of simple terms) gives us this
							rather overly complicated set of arithmetic expressions:
						</p>
						<!--
\setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
 
                                  2             2             2             2             2
                             -18 t  x  y  + 36 t  x  y  - 18 t  x  y  + 18 t  x  y  - 54 t  x  y              
                                     2  1          3  1          4  1          1  2          3  2
                                  2             2             2             2             2
                             +36 t  x  y  - 36 t  x  y  + 54 t  x  y  - 18 t  x  y  + 18 t  x  y              
                                     4  2          1  3          2  3          4  3          1  4
                                  2             2                                                             
                             -36 t  x  y  + 18 t  x  y  + 36 t x  y   - 54 t x  y   + 18 t x  y   - 36 t x  y 
                                     2  4          3  4         2  1          3  1          4  1          1  2
                             +54 t x  y   - 18 t x  y   + 54 t x  y   - 54 t x  y   - 18 t x  y   + 18 t x  y 
                                    3  2          4  2          1  3          2  3          1  4          2  4
                             -18 x  y     + 18 x  y     + 18 x  y     - 18 x  y     - 18 x  y     + 18 x  y   
                                  2  1          3  1          1  2          3  2          1  3          2  3
-->
						<img
							class="LaTeX SVG"
							src="./images/chapters/inflections/75fae2d0a94eae4addf074c294855fc7.svg"
							width="552px"
							height="97px"
							loading="lazy"
						/>
						<p>
							That is... unwieldy. So, we note that there are a lot of terms that involve multiplications involving x1, y1, and y4, which would all
							disappear if we axis-align our curve, which is why aligning is a great idea.
						</p>
					</div>

					<p>
						Aligning our curve so that three of the eight coefficients become zero, and observing that scale does not affect finding
						<code>t</code> values, we end up with the following simple term function for <em>C(t)</em>:
					</p>
					<!--
\setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
 
                                                                2
                               (3 x  y +2 x  y +3 x  y -x  y ) t  + (3 x  y -x  y -3 x  y ) t + (x  y -x  y )
                                   3  2    4  2    2  3  4  3           3  2  4  2    2  3        2  3  3  2
-->
					<img
						class="LaTeX SVG"
						src="./images/chapters/inflections/e50243eaa99b5acc08533dd2e9b71a74.svg"
						width="533px"
						height="20px"
						loading="lazy"
					/>
					<p>
						That's a lot easier to work with: we see a fair number of terms that we can compute and then cache, giving us the following
						simplification:
					</p>
					<!--
\setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
 
                                  a = x   · y  ╮
                                       3     2 │
                                  b = x   · y  │                             2
                                       4     2 ╞  C(t) = (-3a + 2b + 3c - d)t  + (3a - b - 3c)t + (c - a)
                                  c = x   · y  │
                                       2     3 │
                                  d = x   · y  │
                                       4     3 ╯
-->
					<img
						class="LaTeX SVG"
						src="./images/chapters/inflections/2dbf3071d74e2ba37ab888aaa3c1a17c.svg"
						width="467px"
						height="73px"
						loading="lazy"
					/>
					<p>This is a plain quadratic curve, and we know how to solve <em>C(t) = 0</em>; we use the quadratic formula:</p>
					<!--
\setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
 
                                                                                            ┌──────────┐
                                                                                            │ 2
                                    x = -3a + 2b + 3c - d ╮                            -y ±⟍│y  - 4 x z
                                    y =    3a - b - 3c    ╞  C(t) = 0  \Rightarrow t = ─────────────────
                                    z =       c - a       ╯                                   2x
-->
					<img
						class="LaTeX SVG"
						src="./images/chapters/inflections/d7d564126099bc0740058a7cdd744772.svg"
						width="405px"
						height="55px"
						loading="lazy"
					/>
					<p>
						We can easily compute this value <em>if</em> the discriminator isn't a negative number (because we only want real roots, not complex
						roots), and <em>if</em> <em>x</em> is not zero, because divisions by zero are rather useless.
					</p>
					<p>
						Taking that into account, we compute <em>t</em>, we disregard any <em>t</em> value that isn't in the Bézier interval [0,1], and we now
						know at which <em>t</em> value(s) our curve will inflect.
					</p>
					<graphics-element title="Finding cubic Bézier curve inflections" width="275" height="275" src="./chapters/inflections/inflection.js">
						<fallback-image>
							<span class="view-source">Scripts are disabled. Showing fallback image.</span>
							<img width="275px" height="275px" src="./images/chapters/inflections/726ece45630c43be14589c51f1606bd7.png" loading="lazy" />
							<label>Finding cubic Bézier curve inflections</label>
						</fallback-image></graphics-element
					>
				</section>
				<section id="canonical">
					<h1>
						<div class="nav"><a href="ja-JP/index.html#inflections">previous</a><a href="ja-JP/index.html#yforx">next</a></div>
						<a href="ja-JP/index.html#canonical">The canonical form (for cubic curves)</a>
					</h1>
					<p>
						While quadratic curves are relatively simple curves to analyze, the same cannot be said of the cubic curve. As a curvature is controlled
						by more than one control point, it exhibits all kinds of features like loops, cusps, odd colinear features, and as many as two inflection
						points because the curvature can change direction up to three times. Now, knowing what kind of curve we're dealing with means that some
						algorithms can be run more efficiently than if we have to implement them as generic solvers, so is there a way to determine the curve type
						without lots of work?
					</p>
					<p>
						As it so happens, the answer is yes, and the solution we're going to look at was presented by Maureen C. Stone from Xerox PARC and Tony D.
						deRose from the University of Washington in their joint paper
						<a href="https://graphics.pixar.com/people/derose/publications/CubicClassification/paper.pdf"
							>"A Geometric Characterization of Parametric Cubic curves"</a
						>. It was published in 1989, and defines curves as having a "canonical" form (i.e. a form that all curves can be reduced to) from which we
						can immediately tell what features a curve will have. So how does it work?
					</p>
					<p>
						The first observation that makes things work is that if we have a cubic curve with four points, we can apply a linear transformation to
						these points such that three of the points end up on (0,0), (0,1) and (1,1), with the last point then being "somewhere". After applying
						that transformation, the location of that last point can then tell us what kind of curve we're dealing with. Specifically, we see the
						following breakdown:
					</p>
					<graphics-element title="The canonical curve map" width="400" height="400" src="./chapters/canonical/canonical.js">
						<fallback-image>
							<span class="view-source">Scripts are disabled. Showing fallback image.</span>
							<img width="400px" height="400px" src="./images/chapters/canonical/c086e72bd8aaeab37436515ab251b2df.png" loading="lazy" />
							<label></label> </fallback-image
					></graphics-element>
					<p>This is a fairly funky image, so let's see what the various parts of it mean...</p>
					<p>
						We see the three fixed points at (0,0), (0,1) and (1,1). The various regions and boundaries indicate what property the original curve will
						have, if the fourth point is in/on that region or boundary. Specifically, if the fourth point is...
					</p>
					<ol>
						<li>
							<p>
								...anywhere inside the red zone, but not on its boundaries, the curve will either be self-intersecting (yielding a loop). We won't
								know <em>where</em> it self-intersects (in terms of <em>t</em> values), but we are guaranteed that it does.
							</p>
						</li>
						<li>
							<p>
								...on the left (red) edge of the red zone, the curve will have a cusp. We again don't know <em>where</em>, but we know there is one.
								This edge is described by the function:
							</p>
							<!--
\setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
 
                                                               2
                                                             -x  + 2x + 3
                                                         y = ────────────, { x ≤1 }
                                                                  4
-->
							<img
								class="LaTeX SVG"
								src="./images/chapters/canonical/674d251590411398d06fb99cba7920f7.svg"
								width="180px"
								height="37px"
								loading="lazy"
							/>
						</li>
						<li>
							<p>
								...on the almost circular, lower right (pink) edge, the curve's end point touches the curve, forming a loop. This edge is described by
								the function:
							</p>
							<!--
\setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
 
                                                          ┌──────────┐
                                                          │        2
                                                         ⟍│3(4x - x )  - x
                                                     y = ─────────────────, { 0 ≤x ≤1 }
                                                                 2
-->
							<img
								class="LaTeX SVG"
								src="./images/chapters/canonical/6959a552f2c90a2bcaa787c23e19f488.svg"
								width="231px"
								height="39px"
								loading="lazy"
							/>
						</li>
						<li>
							<p>...on the top (blue) edge, the curve's start point touches the curve, forming a loop. This edge is described by the function:</p>
							<!--
\setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
 
                                                                 2
                                                               -x  + 3x
                                                           y = ────────, { x ≤0 }
                                                                  3
-->
							<img
								class="LaTeX SVG"
								src="./images/chapters/canonical/464b4ec0b67f248459792752be86d46d.svg"
								width="153px"
								height="37px"
								loading="lazy"
							/>
						</li>
						<li>
							<p>...inside the lower (green) zone, past <code>y=1</code>, the curve will have a single inflection (switching concave/convex once).</p>
						</li>
						<li>
							<p>
								...between the left and lower boundaries (below the cusp line but above the single-inflection line), the curve will have two
								inflections (switching from concave to convex and then back again, or from convex to concave and then back again).
							</p>
						</li>
						<li><p>...anywhere on the right of self-intersection zone, the curve will have no inflections. It'll just be a simple arch.</p></li>
					</ol>
					<p>Of course, this map is fairly small, but the regions extend to infinity, with well defined boundaries.</p>
					<div class="note">
						<h3>Wait, where do those lines come from?</h3>
						<p>
							Without repeating the paper mentioned at the top of this section, the loop-boundaries come from rewriting the curve into canonical form,
							and then solving the formulae for which constraints must hold for which possible curve properties. In the paper these functions yield
							formulae for where you will find cusp points, or loops where we know t=0 or t=1, but those functions are derived for the full cubic
							expression, meaning they apply to t=-∞ to t=∞... For Bézier curves we only care about the "clipped interval" t=0 to t=1, so some of the
							properties that apply when you look at the curve over an infinite interval simply don't apply to the Bézier curve interval.
						</p>
						<p>
							The right bound for the loop region, indicating where the curve switches from "having inflections" to "having a loop", for the general
							cubic curve, is actually mirrored over x=1, but for Bézier curves this right half doesn't apply, so we don't need to pay attention to
							it. Similarly, the boundaries for t=0 and t=1 loops are also nice clean curves but get "cut off" when we only look at what the general
							curve does over the interval t=0 to t=1.
						</p>
						<p>
							For the full details, head over to the paper and read through sections 3 and 4. If you still remember your high school pre-calculus, you
							can probably follow along with this paper, although you might have to read it a few times before all the bits "click".
						</p>
					</div>

					<p>
						So now the question becomes: how do we manipulate our curve so that it fits this canonical form, with three fixed points, and one "free"
						point? Enter linear algebra. Don't worry, I'll be doing all the math for you, as well as show you what the effect is on our curves, but
						basically we're going to be using linear algebra, rather than calculus, because "it's way easier". Sometimes a calculus approach is very
						hard to work with, when the equivalent geometrical solution is super obvious.
					</p>
					<p>
						The approach is going to start with a curve that doesn't have all-colinear points (so we need to make sure the points don't all fall on a
						straight line), and then applying three graphics operations that you will probably have heard of: translation (moving all points by some
						fixed x- and y-distance), scaling (multiplying all points by some x and y scale factor), and shearing (an operation that turns rectangles
						into parallelograms).
					</p>
					<p>
						Step 1: we translate any curve by -p1.x and -p1.y, so that the curve starts at (0,0). We're going to make use of an interesting trick
						here, by pretending our 2D coordinates are 3D, with the <em>z</em> coordinate simply always being 1. This is an old trick in graphics to
						overcome the limitations of 2D transformations: without it, we can only turn (x,y) coordinates into new coordinates of the form (ax + by,
						cx + dy), which means we can't do translation, since that requires we end up with some kind of (x + a, y + b). If we add a bogus
						<em>z</em> coordinate that is always 1, then we can suddenly add arbitrary values. For example:
					</p>
					<!--
\setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
 
                              ┌ 1 0 a ┐    ┌  x  ┐   ┌ 1  · x + 0  · y + a  · z ┐   ┌ x + a  · 1 ┐   ┌ x + a ┐
                              │ 0 1 b │  · │  y  │ = │ 0  · x + 1  · y + b  · z │ = │ y + b  · 1 │ = │ y + b │
                              └ 0 0 1 ┘    └ z=1 ┘   └ 0  · x + 0  · y + 1  · z ┘   └   1  · z   ┘   └  z=1  ┘
-->
					<img class="LaTeX SVG" src="./images/chapters/canonical/7ed8b53100737cbf7d87aa6267395d2b.svg" width="464px" height="55px" loading="lazy" />
					<p>
						Sweet! <em>z</em> stays 1, so we can effectively ignore it entirely, but we added some plain values to our x and y coordinates. So, if we
						want to subtract p1.x and p1.y, we use:
					</p>
					<!--
\setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
 
                                      ┌ 1 0 -P   ┐            ┌ 1  · x + 0  · y - P    · 1 ┐   ┌ x - P   ┐
                                      │       1x │    ┌ x ┐   │                    1x      │   │      1x │
                                 T  = │ 0 1 -P   │  · │ y │ = │ 0  · x + 1  · y - P    · 1 │ = │ y - P   │
                                  1   │       1y │    └ 1 ┘   │                    1y      │   │      1y │
                                      └ 0 0  1   ┘            └  0  · x + 0  · y + 1  · 1  ┘   └    1    ┘
-->
					<img class="LaTeX SVG" src="./images/chapters/canonical/f855cbf1d73e4bb7bccbbd4721d95f41.svg" width="447px" height="57px" loading="lazy" />
					<p>
						Running all our coordinates through this transformation gives a new set of coordinates, let's call those <strong>U</strong>, where the
						first coordinate lies on (0,0), and the rest is still somewhat free. Our next job is to make sure point 2 ends up lying on the
						<em>x=0</em> line, so what we want is a transformation matrix that, when we run it, subtracts <em>x</em> from whatever <em>x</em> we
						currently have. This is called <a href="https://en.wikipedia.org/wiki/Shear_matrix">shearing</a>, and the typical x-shear matrix and its
						transformation looks like this:
					</p>
					<!--
\setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
 
                                                    ┌ 1 S 0 ┐    ┌ x ┐   ┌ x + S  · y ┐
                                                    │ 0 1 0 │  · │ y │ = │     y      │
                                                    └ 0 0 1 ┘    └ 1 ┘   └     1      ┘
-->
					<img class="LaTeX SVG" src="./images/chapters/canonical/2b6478075f2f9f5e5973e01b3b3a0c8b.svg" width="195px" height="53px" loading="lazy" />
					<p>
						So we want some shearing value that, when multiplied by <em>y</em>, yields <em>-x</em>, so our x coordinate becomes zero. That value is
						simply <em>-x/y</em>, because *-x/y * y = -x*. Done:
					</p>
					<!--
\setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
 
                                                                  ┌    U     ┐
                                                                  │     2x   │
                                                                  │ 1 -─── 0 │
                                                             T  = │    U     │
                                                              2   │     2y   │
                                                                  │ 0   1  0 │
                                                                  └ 0   0  1 ┘
-->
					<img class="LaTeX SVG" src="./images/chapters/canonical/ccbfd22cbccf633d182f7f451dee5164.svg" width="133px" height="67px" loading="lazy" />
					<p>
						Now, running this on all our points generates a new set of coordinates, let's call those <strong>V</strong>, which now have point 1 on
						(0,0) and point 2 on (0, some-value), and we wanted it at (0,1), so we need to
						<a href="https://en.wikipedia.org/wiki/Scaling_%28geometry%29">do some scaling</a> to make sure it ends up at (0,1). Additionally, we want
						point 3 to end up on (1,1), so we can also scale x to make sure its x-coordinate will be 1 after we run the transform. That means we'll be
						x-scaling by 1/point3<sub>x</sub>, and y-scaling by point2<sub>y</sub>. This is really easy:
					</p>
					<!--
\setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
 
                                                                  ┌  1        ┐
                                                                  │ ───  0  0 │
                                                                  │ V         │
                                                                  │  3x       │
                                                             T  = │      1    │
                                                              3   │  0  ─── 0 │
                                                                  │     V     │
                                                                  │      2y   │
                                                                  └  0   0  1 ┘
-->
					<img class="LaTeX SVG" src="./images/chapters/canonical/8e39a9e0c7469b4b45a260dd23bd4c6a.svg" width="137px" height="71px" loading="lazy" />
					<p>
						Then, finally, this generates a new set of coordinates, let's call those W, of which point 1 lies on (0,0), point 2 lies on (0,1), and
						point three lies on (1, ...) so all that's left is to make sure point 3 ends up at (1,1) - but we can't scale! Point 2 is already in the
						right place, and y-scaling would move it out of (0,1) again, so our only option is to y-shear point three, just like how we x-sheared
						point 2 earlier. In this case, we do the same trick, but with <code>y/x</code> rather than <code>x/y</code> because we're not x-shearing
						but y-shearing. Additionally, we don't actually want to end up at zero (which is what we did before) so we need to shear towards an
						offset, in this case 1:
					</p>
					<!--
\setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
 
                                                                 ┌    1    0 0 ┐
                                                                 │ 1 - W       │
                                                                 │      3y     │
                                                            T  = │ ─────── 1 0 │
                                                             4   │   W         │
                                                                 │    3x       │
                                                                 └    0    0 1 ┘
-->
					<img class="LaTeX SVG" src="./images/chapters/canonical/9420fd9d7a8de30714e23b8f31b3aa6d.svg" width="140px" height="65px" loading="lazy" />
					<p>
						And this generates our final set of four coordinates. Of these, we already know that points 1 through 3 are (0,0), (0,1) and (1,1), and
						only the last coordinate is "free". In fact, given any four starting coordinates, the resulting "transformation mapped" coordinate will
						be:
					</p>
					<!--
\setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
 
                                               ╭                           (-x +x )(-y +y )                ╮
                                               │                              1  2    1  4                 │
                                               │                -x  + x  - ────────────────                │
                                               │                  1    4        -y +y                      │
                                               │                                  1  2                     │
                                               │                ───────────────────────────                │
                                               │                         (-x +x )(-y +y )                  │
                                               │                            1  2    1  3                   │
                                               │                  -x +x -────────────────                  │
                                               │                    1  3      -y +y                        │
                               mapped  = (x) = │                                1  2                       │
                                     4    y    │            ╭     -y +y  ╮ ╭            (-x +x )(-y +y ) ╮ │
                                               │            │       1  3 │ │               1  2    1  4  │ │
                                               │            │ 1 - ────── │ │ -x  + x  - ──────────────── │ │
                                               │ (-y +y )   │     -y +y  │ │   1    4        -y +y       │ │
                                               │    1  4    ╰       1  2 ╯ ╰                   1  2      ╯ │
                                               │ ──────── + ────────────────────────────────────────────── │
                                               │  -y +y                       (-x +x )(-y +y )             │
                                               │    1  2                         1  2    1  3              │
                                               │                       -x +x -────────────────             │
                                               │                         1  3      -y +y                   │
                                               ╰                                     1  2                  ╯
-->
					<img class="LaTeX SVG" src="./images/chapters/canonical/e61fd49e554a0ffc7d64893c75cd376d.svg" width="455px" height="91px" loading="lazy" />
					<p>
						Okay, well, that looks plain ridiculous, but: notice that every coordinate value is being offset by the initial translation, and also
						notice that <em>a lot</em> of terms in that expression are repeated. Even though the maths looks crazy as a single expression, we can just
						pull this apart a little and end up with an easy-to-calculate bit of code!
					</p>
					<p>
						First, let's just do that translation step as a "preprocessing" operation so we don't have to subtract the values all the time. What does
						that leave?
					</p>
					<!--
 \setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
  
      ╭                 x   · y       x   · y              ╮
      │                  2     4       2     3             │
      │            x  - ──────── / x -────────             │   ╭         x           ╮
      │             4      y        3    y                 │   │          43         │                ╭      x   · y               x   · y  ╮
      │                     2             2                │   │                     │                │       2     4               2     3 │
... = │                                                    │ = │ y        ╭     y  ╮ │,  where  x   = │ x  - ──────── \middle / x -──────── │
      │ y    ╭     y  ╮    ╭      x   · y       x   · y  ╮ │   │  4       │      3 │ │           43   │  4      y                3    y     │
      │  4   │      3 │    │       2     4       2     3 │ │   │ ── + x   │ 1 - ── │ │                ╰          2                     2    ╯
      │ ── + │ 1 - ── │  · │ x  - ──────── / x -──────── │ │   │ y     43 │     y  │ │
      │ y    │     y  │    │  4      y        3    y     │ │   ╰  2       ╰      2 ╯ ╯
      ╰  2   ╰      2 ╯    ╰          2             2    ╯ ╯
-->
					<img class="LaTeX SVG" src="./images/chapters/canonical/5f174bc5019245f467ca63ae84b90a4b.svg" width="775px" height="67px" loading="lazy" />
					<p>
						Suddenly things look a lot simpler: the mapped x is fairly straight forward to compute, and we see that the mapped y actually contains the
						mapped x in its entirety, so we'll have that part already available when we need to evaluate it. In fact, let's pull out all those common
						factors to see just how simple this is:
					</p>
					<!--
\setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
 
                             ╭         x           ╮                 ╭ x  - x   · y   ╮           y                y 
                             │          43         │                 │  4    2     42 │            4                3
                       ... = │                     │,   where  x   = │ ────────────── │,    y   = ──,   and  y   = ──
                             │ y   + x   (1 - y  ) │            43   │ x  - x   · y   │      42   y           32   y 
                             ╰  42    43       32  ╯                 ╰  3    2     32 ╯            2                2
-->
					<img class="LaTeX SVG" src="./images/chapters/canonical/88e3fae7aeef6d7614290587422542c9.svg" width="563px" height="55px" loading="lazy" />
					<p>
						That's kind of super-simple to write out in code, I think you'll agree. Coding math tends to be easier than the formulae initially make it
						look!
					</p>
					<div class="note">
						<h3>How do you track all that?</h3>
						<p>
							Doing maths can be a pain, so whenever possible, I like to make computers do the work for me. Especially for things like this, I simply
							use <a href="https://www.wolfram.com/mathematica/">Mathematica</a>. Tracking all this math by hand is insane, and we invented computers,
							literally, to do this for us. I have no reason to use pen and paper when I can write out what I want to do in a program, and have the
							program do the math for me. And real math, too, with symbols, not with numbers. In fact,
							<a href="https://pomax.github.io/gh-weblog-2/downloads/canonical-curve.nb">here's</a> the Mathematica notebook if you want to see how
							this works for yourself.
						</p>
						<p>
							Now, I know, you're thinking "but Mathematica is super expensive!" and that's true, it's
							<a href="https://www.wolfram.com/mathematica-home-edition/">$344 for home use, up from $295 when I original wrote this</a>, but it's
							<strong>also</strong> <a href="https://www.wolfram.com/raspberry-pi/">free when you buy a $35 raspberry pi</a>. Obviously, I bought a
							raspberry pi, and I encourage you to do the same. With that, as long as you know what you want to <em>do</em>, Mathematica can just do
							it for you. And we don't have to be geniuses to work out what the maths looks like. That's what we have computers for.
						</p>
					</div>

					<p>
						So, let's write up a sketch that'll show us the canonical form for any curve drawn in blue, overlaid on our canonical map, so that we can
						immediately tell which features our curve must have, based on where the fourth coordinate is located on the map:
					</p>
					<graphics-element title="A cubic curve mapped to canonical form" width="800" height="400" src="./chapters/canonical/interactive.js">
						<fallback-image>
							<span class="view-source">Scripts are disabled. Showing fallback image.</span>
							<img width="800px" height="400px" src="./images/chapters/canonical/83fe2473e20ea68b768765129ee44ae4.png" loading="lazy" />
							<label></label> </fallback-image
					></graphics-element>
				</section>
				<section id="yforx">
					<h1>
						<div class="nav"><a href="ja-JP/index.html#canonical">previous</a><a href="ja-JP/index.html#arclength">next</a></div>
						<a href="ja-JP/index.html#yforx">Finding Y, given X</a>
					</h1>
					<p>
						One common task that pops up in things like CSS work, or parametric equalizers, or image leveling, or any other number of applications
						where Bézier curves are used as control curves in a way that there is really only ever one "y" value associated with one "x" value, you
						might want to cut out the middle man, as it were, and compute "y" directly based on "x". After all, the function looks simple enough,
						finding the "y" value should be simple too, right? Unfortunately, not really. However, it <em>is</em> possible and as long as you have
						some code in place to help, it's not a lot of a work either.
					</p>
					<p>
						We'll be tackling this problem in two stages: the first, which is the hard part, is figuring out which "t" value belongs to any given "x"
						value. For instance, have a look at the following graphic. On the left we have a Bézier curve that looks for all intents and purposes like
						it fits our criteria: every "x" has one and only one associated "y" value. On the right we see the function for just the "x" values:
						that's a cubic curve, but not a really crazy cubic curve. If you move the graphic's slider, you will see a red line drawn that corresponds
						to the <code>x</code> coordinate: this is a vertical line in the left graphic, and a horizontal line on the right.
					</p>
					<graphics-element
						title="Finding t, given x=x(t). Left: our curve, right: the function x=f(t)"
						width="550"
						height="275"
						src="./chapters/yforx/basics.js"
					>
						<fallback-image>
							<span class="view-source">Scripts are disabled. Showing fallback image.</span>
							<img width="550px" height="275px" src="./images/chapters/yforx/e469af5bf27a2c27d1dd6fc62a78ac27.png" loading="lazy" />
							<label></label>
						</fallback-image>
						<input type="range" min="0" max="1" step="0.01" class="slide-control" />
					</graphics-element>
					<p>
						Now, if you look more closely at that right graphic, you'll notice something interesting: if we treat the red line as "the x axis", then
						the point where the function crosses our line is really just a root for the cubic function x(t) through a shifted "x-axis"... and
						<a href="#extremities">we've already seen</a> how to calculate roots, so let's just run cubic root finding - and not even the complicated
						cubic case either: because of the kind of curve we're starting with, we <em>know</em> there is only root, simplifying the code we need!
					</p>
					<p>First, let's look at the function for x(t):</p>
					<!--
\setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
 
                                                x(t) = a(1-t)³ + 3b(1-t)²t + 3c(1-t)t² + dt³
-->
					<img class="LaTeX SVG" src="./images/chapters/yforx/316e7fae61e10014000d770209779ab6.svg" width="335px" height="19px" loading="lazy" />
					<p>
						We can rewrite this to a plain polynomial form, by just fully writing out the expansion and then collecting the polynomial factors, as:
					</p>
					<!--
\setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
 
                                      x(t) = (-a + 3b- 3c + d)t³ + (3a - 6b + 3c)t² + (-3a + 3b)t + a
-->
					<img class="LaTeX SVG" src="./images/chapters/yforx/4d23ee228c5b1cbc40e380496c2184d1.svg" width="445px" height="19px" loading="lazy" />
					<p>
						Nothing special here: that's a standard cubic polynomial in "power" form (i.e. all the terms are ordered by their power of
						<code>t</code>). So, given that <code>a</code>, <code>b</code>, <code>c</code>, <code>d</code>, <em>and</em> <code>x(t)</code> are all
						known constants, we can trivially rewrite this (by moving the <code>x(t)</code> across the equal sign) as:
					</p>
					<!--
\setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
 
                                     (-a + 3b - 3c + d)t³ + (3a - 6b + 3c)t² + (-3a + 3b)t + (a-x) = 0
-->
					<img class="LaTeX SVG" src="./images/chapters/yforx/699459d89ca6622c90c1e42e4aa03f32.svg" width="465px" height="19px" loading="lazy" />
					<p>
						You might be wondering "where did all the other 'minus x' for all the other values a, b, c, and d go?" and the answer there is that they
						all cancel out, so the only one we actually need to subtract is the one at the end. Handy! So now we just solve this equation using
						Cardano's algorithm, and we're left with some rather short code:
					</p>

					<table class="code">
						<tr>
							<td>1</td>
							<td rowspan="10">
								<textarea disabled rows="10" role="doc-example">
// prepare our values for root finding:
x = a value we already know
xcoord = our set of Bézier curve's x coordinates
foreach p in xcoord: p.x -= x

// find our root, of which we know there is exactly one:
t = getRoots(p[0], p[1], p[2], p[3])[0]

// find our answer:
y = curve.get(t).y</textarea
								>
							</td>
						</tr>
						<tr>
							<td>2</td>
						</tr>
						<tr>
							<td>3</td>
						</tr>
						<tr>
							<td>4</td>
						</tr>
						<tr>
							<td>5</td>
						</tr>
						<tr>
							<td>6</td>
						</tr>
						<tr>
							<td>7</td>
						</tr>
						<tr>
							<td>8</td>
						</tr>
						<tr>
							<td>9</td>
						</tr>
						<tr>
							<td>10</td>
						</tr>
					</table>

					<p>
						So the procedure is fairly straight forward: pick an <code>x</code>, find the associated <code>t</code> value, evaluate our curve
						<em>for</em> that <code>t</code> value, which gives us the curve's {x,y} coordinate, which means we know <code>y</code> for this
						<code>x</code>. Move the slider for the following graphic to see this in action:
					</p>
					<graphics-element title="Finding By(t), by finding t for a given x" width="275" height="275" src="./chapters/yforx/yforx.js">
						<fallback-image>
							<span class="view-source">Scripts are disabled. Showing fallback image.</span>
							<img width="275px" height="275px" src="./images/chapters/yforx/2fc5c57e5d1ed0eaa1655edc31026252.png" loading="lazy" />
							<label>Finding By(t), by finding t for a given x</label>
						</fallback-image>
						<input type="range" min="0" max="1" step="0.01" class="slide-control" />
					</graphics-element>
				</section>
				<section id="arclength">
					<h1>
						<div class="nav"><a href="ja-JP/index.html#yforx">previous</a><a href="ja-JP/index.html#arclengthapprox">next</a></div>
						<a href="ja-JP/index.html#arclength">Arc length</a>
					</h1>
					<p>
						How long is a Bézier curve? As it turns out, that's not actually an easy question, because the answer requires maths that —much like root
						finding— cannot generally be solved the traditional way. If we have a parametric curve with <em>f<sub>x</sub>(t)</em> and
						<em>f<sub>y</sub>(t)</em>, then the length of the curve, measured from start point to some point <em>t = z</em>, is computed using the
						following seemingly straight forward (if a bit overwhelming) formula:
					</p>
					<!--
\setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
 
                                                              ┌───────────────┐
                                                          ╭ z │      2       2
                                                          |   │f '(t) +f '(t)   dt
                                                          ╯ 0⟍│ x       y
-->
					<img class="LaTeX SVG" src="./images/chapters/arclength/59ebc3a7c3547a50998d1ea3664fb688.svg" width="140px" height="33px" loading="lazy" />
					<p>or, more commonly written using Leibnitz notation as:</p>
					<!--
\setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
 
                                                                  ┌─────────────────┐
                                                              ╭ z │       2        2
                                                    length =  |  ⟍│(dx/dt) +(dy/dt)   dt
                                                              ╯ 0
-->
					<img class="LaTeX SVG" src="./images/chapters/arclength/2f80643c66d8f1448b13537a7b24eb45.svg" width="245px" height="35px" loading="lazy" />
					<p>
						This formula says that the length of a parametric curve is in fact equal to the <strong>area</strong> underneath a function that looks a
						remarkable amount like Pythagoras' rule for computing the diagonal of a straight angled triangle. This sounds pretty simple, right? Sadly,
						it's far from simple... cutting straight to after the chase is over: for quadratic curves, this formula generates an
						<a
							href="https://www.wolframalpha.com/input/?i=antiderivative+for+sqrt((2*(1-t)*t*B+%2B+t%5E2*C)%27%5E2+%2B+(2*(1-t)*t*E)%27%5E2)&incParTime=true"
							>unwieldy computation</a
						>, and we're simply not going to implement things that way. For cubic Bézier curves, things get even more fun, because there is no "closed
						form" solution, meaning that due to the way calculus works, there is no generic formula that allows you to calculate the arc length. Let
						me just repeat this, because it's fairly crucial:
						<strong
							><em
								>for cubic and higher Bézier curves, there is no way to solve this function if you want to use it "for all possible coordinates"</em
							></strong
						>.
					</p>
					<p>Seriously: <a href="https://en.wikipedia.org/wiki/Abel%E2%80%93Ruffini_theorem">It cannot be done</a>.</p>
					<p>
						So we turn to numerical approaches again. The method we'll look at here is the
						<a href="https://www.youtube.com/watch?v=unWguclP-Ds&feature=BFa&list=PLC8FC40C714F5E60F&index=1">Gauss quadrature</a>. This approximation
						is a really neat trick, because for any <em>n<sup>th</sup></em> degree polynomial it finds approximated values for an integral really
						efficiently. Explaining this procedure in length is way beyond the scope of this page, so if you're interested in finding out why it
						works, I can recommend the University of South Florida video lecture on the procedure, linked in this very paragraph. The general solution
						we're looking for is the following:
					</p>
					<!--
    \setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
     
     ┌─────────────────┐
╭ 1  │       2        2        ╭ 1
|   ⟍│(dx/dt) +(dy/dt)   dt =  |   f(t) dt  ≃ ┌ \undersetstrip 1 \underbrace C   · f(t )   + ...  + \undersetstrip n \underbrace C   · f(t )  ┐ =
╯ -1                           ╯ -1           └                               1       1                                           n       n   ┘
                                                                                   __ n
                                           \undersetstrips 1 through n \underbrace ❯      C   · f(t )   
                                                                                   ‾‾ i=1  i       i
-->
					<img class="LaTeX SVG" src="./images/chapters/arclength/f251e86158649c0e57f7a772ebff83b4.svg" width="636px" height="71px" loading="lazy" />
					<p>
						In plain text: an integral function can always be treated as the sum of an (infinite) number of (infinitely thin) rectangular strips
						sitting "under" the function's plotted graph. To illustrate this idea, the following graph shows the integral for a sinusoid function. The
						more strips we use (and of course the more we use, the thinner they get) the closer we get to the true area under the curve, and thus the
						better the approximation:
					</p>
					<div class="figure">
						<graphics-element
							title="A function's approximated integral"
							width="275"
							height="275"
							src="./chapters/arclength/draw-slices.js"
							data-steps="10"
						>
							<fallback-image>
								<span class="view-source">Scripts are disabled. Showing fallback image.</span>
								<img width="275px" height="275px" src="./images/chapters/arclength/56533f47e73ad9fea08fa9bb3f597d49.png" loading="lazy" />
								<label>A function's approximated integral</label>
							</fallback-image></graphics-element
						>
						<graphics-element title="A better approximation" width="275" height="275" src="./chapters/arclength/draw-slices.js" data-steps="24">
							<fallback-image>
								<span class="view-source">Scripts are disabled. Showing fallback image.</span>
								<img width="275px" height="275px" src="./images/chapters/arclength/5ce02cbdbc47585c588f2656d5161a32.png" loading="lazy" />
								<label>A better approximation</label>
							</fallback-image></graphics-element
						>
						<graphics-element title="An even better approximation" width="275" height="275" src="./chapters/arclength/draw-slices.js" data-steps="99">
							<fallback-image>
								<span class="view-source">Scripts are disabled. Showing fallback image.</span>
								<img width="275px" height="275px" src="./images/chapters/arclength/fe2663b205d14c157a5a02bfbbd55987.png" loading="lazy" />
								<label>An even better approximation</label>
							</fallback-image></graphics-element
						>
					</div>

					<p>
						Now, infinitely many terms to sum and infinitely thin rectangles are not something that computers can work with, so instead we're going to
						approximate the infinite summation by using a sum of a finite number of "just thin" rectangular strips. As long as we use a high enough
						number of thin enough rectangular strips, this will give us an approximation that is pretty close to what the real value is.
					</p>
					<p>
						So, the trick is to come up with useful rectangular strips. A naive way is to simply create <em>n</em> strips, all with the same width,
						but there is a far better way using special values for <em>C</em> and <em>f(t)</em> depending on the value of <em>n</em>, which indicates
						how many strips we'll use, and it's called the Legendre-Gauss quadrature.
					</p>
					<p>
						This approach uses strips that are <em>not</em> spaced evenly, but instead spaces them in a special way based on describing the function
						as a polynomial (the more strips, the more accurate the polynomial), and then computing the exact integral for that polynomial. We're
						essentially performing arc length computation on a flattened curve, but flattening it based on the intervals dictated by the
						Legendre-Gauss solution.
					</p>
					<div class="note">
						<p>
							Note that one requirement for the approach we'll use is that the integral must run from -1 to 1. That's no good, because we're dealing
							with Bézier curves, and the length of a section of curve applies to values which run from 0 to "some value smaller than or equal to 1"
							(let's call that value <em>z</em>). Thankfully, we can quite easily transform any integral interval to any other integral interval, by
							shifting and scaling the inputs. Doing so, we get the following:
						</p>
						<!--
\setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
 
                                         ┌─────────────────┐
                                     ╭ z │       2        2
                                     |  ⟍│(dx/dt) +(dy/dt)   dt                                        
                                     ╯ 0
                                         z    ┌        ╭ z         z ╮                ╭ z         z ╮ ┐
                                     ≃ \ ─  · │ C   · f│ ─  · t  + ─ │ + ... + C   · f│ ─  · t  + ─ │ │
                                         2    └  1     ╰ 2     1   2 ╯          n     ╰ 2     n   2 ╯ ┘
                                        z    __ n         ╭ z         z ╮
                                    = \ ─  · ❯     C   · f│ ─  · t  + ─ │                              
                                        2    ‾‾ i=1 i     ╰ 2     i   2 ╯
-->
						<img
							class="LaTeX SVG"
							src="./images/chapters/arclength/0748ad25185548150b6c1c4c7039207e.svg"
							width="341px"
							height="72px"
							loading="lazy"
						/>
						<p>
							That may look a bit more complicated, but the fraction involving <em>z</em> is a fixed number, so the summation, and the evaluation of
							the <em>f(t)</em> values are still pretty simple.
						</p>
						<p>
							So, what do we need to perform this calculation? For one, we'll need an explicit formula for <em>f(t)</em>, because that derivative
							notation is handy on paper, but not when we have to implement it. We'll also need to know what these <em>C<sub>i</sub></em> and
							<em>t<sub>i</sub></em> values should be. Luckily, that's less work because there are actually many tables available that give these
							values, for any <em>n</em>, so if we want to approximate our integral with only two terms (which is a bit low, really) then
							<a href="./legendre-gauss.html">these tables</a> would tell us that for <em>n=2</em> we must use the following values:
						</p>
						<!--
\setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
 
                                                                C  = 1     
                                                                 1
                                                                C  = 1     
                                                                 2
                                                                        1
                                                                t  = - ────
                                                                 1      ┌─┐
                                                                       ⟍│3
                                                                        1
                                                                t  = + ────
                                                                 2      ┌─┐
                                                                       ⟍│3
-->
						<img class="LaTeX SVG" src="./images/chapters/arclength/a91fbfb7abc38ff712ef660d85679f2e.svg" width="63px" height="93px" loading="lazy" />
						<p>
							Which means that in order for us to approximate the integral, we must plug these values into the approximate function, which gives us:
						</p>
						<!--
\setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
 
                                    ┌─────────────────┐
                                ╭ z │       2        2       z    ┌  ╭ z     -1    z ╮    ╭ z     1     z ╮ ┐
                                |  ⟍│(dx/dt) +(dy/dt)   dt ≃ ─  · │ f│ ─  · ──── + ─ │ + f│ ─  · ──── + ─ │ │
                                ╯ 0                          2    │  │ 2     ┌─┐   2 │    │ 2     ┌─┐   2 │ │
                                                                  └  ╰      ⟍│3      ╯    ╰      ⟍│3      ╯ ┘
-->
						<img
							class="LaTeX SVG"
							src="./images/chapters/arclength/046bbb52e8c8ed617fdf3a4fd18d62e1.svg"
							width="476px"
							height="44px"
							loading="lazy"
						/>
						<p>
							We can program that pretty easily, provided we have that <em>f(t)</em> available, which we do, as we know the full description for the
							Bézier curve functions B<sub>x</sub>(t) and B<sub>y</sub>(t).
						</p>
					</div>

					<p>
						If we use the Legendre-Gauss values for our <em>C</em> values (thickness for each strip) and <em>t</em> values (location of each strip),
						we can determine the approximate length of a Bézier curve by computing the Legendre-Gauss sum. The following graphic shows a cubic curve,
						with its computed lengths; Go ahead and change the curve, to see how its length changes. One thing worth trying is to see if you can make
						a straight line, and see if the length matches what you'd expect. What if you form a line with the control points on the outside, and the
						start/end points on the inside?
					</p>
					<graphics-element title="Arc length for a Bézier curve" width="275" height="275" src="./chapters/arclength/arclength.js">
						<fallback-image>
							<span class="view-source">Scripts are disabled. Showing fallback image.</span>
							<img width="275px" height="275px" src="./images/chapters/arclength/fa4c587126e8097206b88d9ea51974ca.png" loading="lazy" />
							<label>Arc length for a Bézier curve</label>
						</fallback-image></graphics-element
					>
				</section>
				<section id="arclengthapprox">
					<h1>
						<div class="nav"><a href="ja-JP/index.html#arclength">previous</a><a href="ja-JP/index.html#curvature">next</a></div>
						<a href="ja-JP/index.html#arclengthapprox">Approximated arc length</a>
					</h1>
					<p>
						Sometimes, we don't actually need the precision of a true arc length, and we can get away with simply computing the approximate arc length
						instead. The by far fastest way to do this is to flatten the curve and then simply calculate the linear distance from point to point. This
						will come with an error, but this can be made arbitrarily small by increasing the segment count.
					</p>
					<p>
						If we combine the work done in the previous sections on curve flattening and arc length computation, we can implement these with minimal
						effort:
					</p>
					<div class="figure">
						<graphics-element
							title="Approximate quadratic curve arc length"
							width="275"
							height="275"
							src="./chapters/arclengthapprox/approximate.js"
							data-type="quadratic"
						>
							<fallback-image>
								<span class="view-source">Scripts are disabled. Showing fallback image.</span>
								<img width="275px" height="275px" src="./images/chapters/arclengthapprox/3fc083ea7bdcc6b021560f2f2491f8aa.png" loading="lazy" />
								<label>Approximate quadratic curve arc length</label>
							</fallback-image>
							<input type="range" min="2" max="24" step="1" value="4" class="slide-control" />
						</graphics-element>
						<graphics-element
							title="Approximate cubic curve arc length"
							width="275"
							height="275"
							src="./chapters/arclengthapprox/approximate.js"
							data-type="cubic"
						>
							<fallback-image>
								<span class="view-source">Scripts are disabled. Showing fallback image.</span>
								<img width="275px" height="275px" src="./images/chapters/arclengthapprox/537260c4aa9e98ffdea7c8120afbd427.png" loading="lazy" />
								<label>Approximate cubic curve arc length</label>
							</fallback-image>
							<input type="range" min="2" max="32" step="1" value="8" class="slide-control" />
						</graphics-element>
					</div>

					<p>
						You may notice that even though the error in length is actually pretty significant in absolute terms, even at a low number of segments we
						get a length that agrees with the true length when it comes to just the integer part of the arc length. Quite often, approximations can
						drastically speed things up!
					</p>
				</section>
				<section id="curvature">
					<h1>
						<div class="nav"><a href="ja-JP/index.html#arclengthapprox">previous</a><a href="ja-JP/index.html#tracing">next</a></div>
						<a href="ja-JP/index.html#curvature">Curvature of a curve</a>
					</h1>
					<p>
						If we have two curves, and we want to line them in up in a way that "looks right", what would we use as metric to let a computer decide
						what "looks right" means?
					</p>
					<p>
						For instance, we can start by ensuring that the two curves share an end coordinate, so that there is no "gap" between the end of one and
						the start of the next curve, but that won't guarantee that things look right: both curves can be going in wildly different directions, and
						the resulting joined geometry will have a corner in it, rather than a smooth transition from one curve to the next.
					</p>
					<p>
						What we want is to ensure that the <a href="https://en.wikipedia.org/wiki/Curvature">curvature</a> at the transition from one curve to the
						next "looks good". So, we start with a shared coordinate, and then also require that derivatives for both curves match at that coordinate.
						That way, we're assured that their tangents line up, which must mean the curve transition is perfectly smooth. We can even make the
						second, third, etc. derivatives match up for better and better transitions.
					</p>
					<p>Problem solved!</p>
					<p>
						However, there's a problem with this approach: if we think about this a little more, we realise that "what a curve looks like" and its
						derivative values are pretty much entirely unrelated. After all, the section on <a href="#reordering">reordering curves</a> showed us that
						the same looking curve can have an infinite number of curve expressions of arbitrarily high Bézier degree, and each of those will have
						<em>wildly</em> different derivative values.
					</p>
					<p>
						So what we really want is some kind of expression that's not based on any particular expression of <code>t</code>, but is based on
						something that is invariant to the <em>kind</em> of function(s) we use to draw our curve. And the prime candidate for this is our curve
						expression, reparameterised for distance: no matter what order of Bézier curve we use, if we were able to rewrite it as a function of
						distance-along-the-curve, all those different degree Bézier functions would end up being <em>the same</em> function for "coordinate at
						some distance D along the curve".
					</p>
					<p>We've seen this before... that's the arc length function.</p>
					<p>
						So you might think that in order to find the curvature of a curve, we now need to solve the arc length function itself, and that this
						would be quite a problem because we just saw that there is no way to actually do that. Thankfully, we don't. We only need to know the
						<em>form</em> of the arc length function, which we saw above and is fairly simple, rather than needing to <em>solve</em> the arc length
						function. If we start with the arc length expression and the
						<a href="https://mathworld.wolfram.com/Curvature.html">run through the steps necessary</a> to determine <em>its</em> derivative (with an
						alternative, shorter demonstration of how to do this found
						<a href="https://math.stackexchange.com/questions/275248/deriving-curvature-formula/275324#275324">over on Stackexchange</a>), then the
						integral that was giving us so much problems in solving the arc length function disappears entirely (because of the
						<a href="https://en.wikipedia.org/wiki/Fundamental_theorem_of_calculus">fundamental theorem of calculus</a>), and what we're left with us
						some surprisingly simple maths that relates curvature (denoted as κ, "kappa") to—and this is the truly surprising bit—a specific
						combination of derivatives of our original function.
					</p>
					<p>Let me highlight what just happened, because it's pretty special:</p>
					<ol>
						<li>we wanted to make curves line up, and initially thought to match the curves' derivatives, but</li>
						<li>that turned out to be a really bad choice, so instead</li>
						<li>we picked a function that is basically impossible to work with, and then <em>worked with that</em>, which</li>
						<li>gives us a simple formula that is <em>and expression using the curves' derivatives</em>.</li>
					</ol>
					<p><em>That's crazy!</em></p>
					<p>
						But that's also one of the things that makes maths so powerful: even if your initial ideas are off the mark, you might be much closer than
						you thought you were, and the journey from "thinking we're completely wrong" to "actually being remarkably close to being right" is where
						we can find a lot of insight.
					</p>
					<p>So, what does the function look like? This:</p>
					<!--
\setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
 
                                                                    x'y'' - x''y'
                                                           \kappa = ─────────────
                                                                              3
                                                                              ─
                                                                        2   2 2
                                                                     (x' +y' ) 
-->
					<img class="LaTeX SVG" src="./images/chapters/curvature/060acd6ff0a050fe4d98a7802a2b3a3f.svg" width="113px" height="47px" loading="lazy" />
					<p>
						Which is really just a "short form" that glosses over the fact that we're dealing with functions of <code>t</code>, so let's expand that a
						tiny bit:
					</p>
					<!--
\setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
 
                                                             B '(t)B ''(t) - B ''(t)B '(t)
                                                              x     y         x      y
                                                 \kappa(t) = ─────────────────────────────
                                                                                   3
                                                                                   ─
                                                                         2       2 2
                                                                  (B '(t) +B '(t) ) 
                                                                    x       y
-->
					<img class="LaTeX SVG" src="./images/chapters/curvature/afd8cb8b0fe291ff703752c1c9cc33d4.svg" width="239px" height="55px" loading="lazy" />
					<p>
						And while that's a little more verbose, it's still just as simple to work with as the first function: the curvature at some point on any
						(and this cannot be overstated: <em>any</em>) curve is a ratio between the first and second derivative cross product, and something that
						looks oddly similar to the standard Euclidean distance function. And nothing in these functions is hard to calculate either: for Bézier
						curves, simply knowing our curve coordinates means <a href="#derivatives">we know what the first and second derivatives are</a>, and so
						evaluating this function for any <strong>t</strong> value is just a matter of basic arithematics.
					</p>
					<p>In fact, let's just implement it right now:</p>

					<table class="code">
						<tr>
							<td>1</td>
							<td rowspan="7">
								<textarea disabled rows="7" role="doc-example">
function kappa(t, B):
  d = B.getDerivative(t)
  dd = B.getSecondDerivative(t)
  numerator = d.x * dd.y - dd.x * d.y
  denominator = pow(d.x*d.x + d.y*d.y, 3/2)
  if denominator is 0: return NaN;
  return numerator / denominator</textarea
								>
							</td>
						</tr>
						<tr>
							<td>2</td>
						</tr>
						<tr>
							<td>3</td>
						</tr>
						<tr>
							<td>4</td>
						</tr>
						<tr>
							<td>5</td>
						</tr>
						<tr>
							<td>6</td>
						</tr>
						<tr>
							<td>7</td>
						</tr>
					</table>

					<p>
						That was easy! (Well okay, that "not a number" value will need to be taken into account by downstream code, but that's a reality of
						programming anyway)
					</p>
					<p>
						With all of that covered, let's line up some curves! The following graphic gives you two curves that look identical, but use quadratic and
						cubic functions, respectively. As you can see, despite their derivatives being necessarily different, their curvature (thanks to being
						derived based on maths that "ignores" specific function derivative, and instead gives a formula that smooths out any differences) is
						exactly the same. And because of that, we can put them together such that the point where they overlap has the same curvature for both
						curves, giving us the smoothest transition.
					</p>
					<graphics-element
						title="Matching curvatures for a quadratic and cubic Bézier curve"
						width="825"
						height="275"
						src="./chapters/curvature/curvature.js"
					>
						<fallback-image>
							<span class="view-source">Scripts are disabled. Showing fallback image.</span>
							<img width="825px" height="275px" src="./images/chapters/curvature/4f2647446363ca5d93b11e414fd976df.png" loading="lazy" />
							<label></label> </fallback-image
					></graphics-element>
					<p>
						One thing you may have noticed in this sketch is that sometimes the curvature looks fine, but seems to be pointing in the wrong direction,
						making it hard to line up the curves properly. A way around that, of course, is to show the curvature on both sides of the curve, so let's
						just do that. But let's take it one step further: we can also compute the associated "radius of curvature", which gives us the implicit
						circle that "fits" the curve's curvature at any point, using what is possibly the simplest bit of maths found in this entire primer:
					</p>
					<!--
\setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
 
                                                                         1
                                                              R(t) = ─────────
                                                                     \kappa(t)
-->
					<img class="LaTeX SVG" src="./images/chapters/curvature/561ab3a938d655550de0abf458ac2494.svg" width="81px" height="37px" loading="lazy" />
					<p>
						So let's revisit the previous graphic with the curvature visualised on both sides of our curves, as well as showing the circle that "fits"
						our curve at some point that we can control by using a slider:
					</p>
					<graphics-element
						title="(Easier) curvature matching for a quadratic and cubic Bézier curve"
						width="825"
						height="275"
						src="./chapters/curvature/curvature.js"
						data-omni="true"
					>
						<fallback-image>
							<span class="view-source">Scripts are disabled. Showing fallback image.</span>
							<img width="825px" height="275px" src="./images/chapters/curvature/392624cedf7c78aed6d4c6065a014b42.png" loading="lazy" />
							<label></label>
						</fallback-image>
						<input type="range" min="0" max="2" step="0.0005" value="0" class="slide-control" />
					</graphics-element>
				</section>
				<section id="tracing">
					<h1>
						<div class="nav"><a href="ja-JP/index.html#curvature">previous</a><a href="ja-JP/index.html#intersections">next</a></div>
						<a href="ja-JP/index.html#tracing">Tracing a curve at fixed distance intervals</a>
					</h1>
					<p>
						Say you want to draw a curve with a dashed line, rather than a solid line, or you want to move something along the curve at fixed distance
						intervals over time, like a train along a track, and you want to use Bézier curves.
					</p>
					<p>Now you have a problem.</p>
					<p>
						The reason you have a problem is that Bézier curves are parametric functions with non-linear behaviour, whereas moving a train along a
						track is about as close to a practical example of linear behaviour as you can get. The problem we're faced with is that we can't just pick
						<code>t</code> values at some fixed interval and expect the Bézier functions to generate points that are spaced a fixed distance apart. In
						fact, let's look at the relation between "distance long a curve" and "<code>t</code> value", by plotting them against one another.
					</p>
					<p>
						The following graphic shows a particularly illustrative curve, and it's distance-for-t plot. For linear traversal, this line needs to be
						straight, running from (0,0) to (length,1). That is, it's safe to say, not what we'll see: we'll see something very wobbly, instead. To
						make matters even worse, the distance-for-t function is also of a much higher order than our curve is: while the curve we're using for
						this exercise is a cubic curve, which can switch concave/convex form twice at best, the distance function is our old friend the arc length
						function, which can have more inflection points.
					</p>
					<graphics-element title="The t-for-distance function" width="550" height="275" src="./chapters/tracing/distance-function.js">
						<fallback-image>
							<span class="view-source">Scripts are disabled. Showing fallback image.</span>
							<img width="550px" height="275px" src="./images/chapters/tracing/d6239520389637a3c42e76ee44d86c41.png" loading="lazy" />
							<label></label> </fallback-image
					></graphics-element>
					<p>
						So, how do we "cut up" the arc length function at regular intervals, when we can't really work with it? We basically cheat: we run through
						the curve using <code>t</code> values, determine the distance-for-this-<code>t</code>-value at each point we generate during the run, and
						then we find "the closest <code>t</code> value that matches some required distance" using those values instead. If we have a low number of
						points sampled, we can then even refine which <code>t</code> value "should" work for our desired distance by interpolating between two
						points, but if we have a high enough number of samples, we don't even need to bother.
					</p>
					<p>
						So let's do exactly that: the following graph is similar to the previous one, showing how we would have to "chop up" our distance-for-t
						curve in order to get regularly spaced points on the curve. It also shows what using those <code>t</code> values on the real curve looks
						like, by coloring each section of curve between two distance markers differently:
					</p>
					<graphics-element title="Fixed-interval coloring a curve" width="825" height="275" src="./chapters/tracing/tracing.js">
						<fallback-image>
							<span class="view-source">Scripts are disabled. Showing fallback image.</span>
							<img width="825px" height="275px" src="./images/chapters/tracing/1cd7304fb8d044835bfbc305ca5e5d10.png" loading="lazy" />
							<label></label>
						</fallback-image>
						<input type="range" min="2" max="24" step="1" value="8" class="slide-control" />
					</graphics-element>
					<p>Use the slider to increase or decrease the number of equidistant segments used to colour the curve.</p>
					<p>
						However, are there better ways? One such way is discussed in "<a
							href="https://www.geometrictools.com/Documentation/MovingAlongCurveSpecifiedSpeed.pdf"
							>Moving Along a Curve with Specified Speed</a
						>" by David Eberly of Geometric Tools, LLC, but basically because we have no explicit length function (or rather, one we don't have to
						constantly compute for different intervals), you may simply be better off with a traditional lookup table (LUT).
					</p>
				</section>
				<section id="intersections">
					<h1>
						<div class="nav"><a href="ja-JP/index.html#tracing">previous</a><a href="ja-JP/index.html#curveintersection">next</a></div>
						<a href="ja-JP/index.html#intersections">Intersections</a>
					</h1>
					<p>
						Let's look at some more things we will want to do with Bézier curves. Almost immediately after figuring out how to get bounding boxes to
						work, people tend to run into the problem that even though the minimal bounding box (based on rotation) is tight, it's not sufficient to
						perform true collision detection. It's a good first step to make sure there <em>might</em> be a collision (if there is no bounding box
						overlap, there can't be one), but in order to do real collision detection we need to know whether or not there's an intersection on the
						actual curve.
					</p>
					<p>
						We'll do this in steps, because it's a bit of a journey to get to curve/curve intersection checking. First, let's start simple, by
						implementing a line-line intersection checker. While we can solve this the traditional calculus way (determine the functions for both
						lines, then compute the intersection by equating them and solving for two unknowns), linear algebra actually offers a nicer solution.
					</p>
					<h3>Line-line intersections</h3>
					<p>
						If we have two line segments with two coordinates each, segments A-B and C-D, we can find the intersection of the lines these segments are
						an intervals on by linear algebra, using the procedure outlined in this
						<a href="https://www.topcoder.com/community/competitive-programming/tutorials/geometry-concepts-line-intersection-and-its-applications/"
							>top coder</a
						>
						article. Of course, we need to make sure that the intersection isn't just on the lines our line segments lie on, but actually on our line
						segments themselves. So after we find the intersection, we need to verify that it lies without the bounds of our original line segments.
					</p>
					<p>
						The following graphic implements this intersection detection, showing a red point for an intersection on the lines our segments lie on
						(thus being a virtual intersection point), and a green point for an intersection that lies on both segments (being a real intersection
						point).
					</p>
					<graphics-element title="Line/line intersections" width="275" height="275" src="./chapters/intersections/line-line.js">
						<fallback-image>
							<span class="view-source">Scripts are disabled. Showing fallback image.</span>
							<img width="275px" height="275px" src="./images/chapters/intersections/b3f61036d8dc9888a6a64a1171583dd1.png" loading="lazy" />
							<label>Line/line intersections</label>
						</fallback-image></graphics-element
					>
					<div class="howtocode">
						<h3>Implementing line-line intersections</h3>
						<p>
							Let's have a look at how to implement a line-line intersection checking function. The basics are covered in the article mentioned above,
							but sometimes you need more function signatures, because you might not want to call your function with eight distinct parameters. Maybe
							you're using point structs for the line. Let's get coding:
						</p>

						<table class="code">
							<tr>
								<td>1</td>
								<td rowspan="17">
									<textarea disabled rows="17" role="doc-example">
lli8 = function(x1,y1,x2,y2,x3,y3,x4,y4):
  var nx=(x1*y2-y1*x2)*(x3-x4)-(x1-x2)*(x3*y4-y3*x4),
      ny=(x1*y2-y1*x2)*(y3-y4)-(y1-y2)*(x3*y4-y3*x4),
      d=(x1-x2)*(y3-y4)-(y1-y2)*(x3-x4);
  if d=0:
    return false
  return point(nx/d, ny/d)

lli4 = function(p1, p2, p3, p4):
  var x1 = p1.x, y1 = p1.y,
      x2 = p2.x, y2 = p2.y,
      x3 = p3.x, y3 = p3.y,
      x4 = p4.x, y4 = p4.y;
  return lli8(x1,y1,x2,y2,x3,y3,x4,y4)

lli = function(line1, line2):
  return lli4(line1.p1, line1.p2, line2.p1, line2.p2)</textarea
									>
								</td>
							</tr>
							<tr>
								<td>2</td>
							</tr>
							<tr>
								<td>3</td>
							</tr>
							<tr>
								<td>4</td>
							</tr>
							<tr>
								<td>5</td>
							</tr>
							<tr>
								<td>6</td>
							</tr>
							<tr>
								<td>7</td>
							</tr>
							<tr>
								<td>8</td>
							</tr>
							<tr>
								<td>9</td>
							</tr>
							<tr>
								<td>10</td>
							</tr>
							<tr>
								<td>11</td>
							</tr>
							<tr>
								<td>12</td>
							</tr>
							<tr>
								<td>13</td>
							</tr>
							<tr>
								<td>14</td>
							</tr>
							<tr>
								<td>15</td>
							</tr>
							<tr>
								<td>16</td>
							</tr>
							<tr>
								<td>17</td>
							</tr>
						</table>
					</div>

					<h3>What about curve-line intersections?</h3>
					<p>
						Curve/line intersection is more work, but we've already seen the techniques we need to use in order to perform it: first we
						translate/rotate both the line and curve together, in such a way that the line coincides with the x-axis. This will position the curve in
						a way that makes it cross the line at points where its y-function is zero. By doing this, the problem of finding intersections between a
						curve and a line has now become the problem of performing root finding on our translated/rotated curve, as we already covered in the
						section on finding extremities.
					</p>
					<div class="figure">
						<graphics-element
							title="Quadratic curve/line intersections"
							width="275"
							height="275"
							src="./chapters/intersections/curve-line.js"
							data-type="quadratic"
						>
							<fallback-image>
								<span class="view-source">Scripts are disabled. Showing fallback image.</span>
								<img width="275px" height="275px" src="./images/chapters/intersections/9b70fb7b03f082882515e55c0a1eacff.png" loading="lazy" />
								<label>Quadratic curve/line intersections</label>
							</fallback-image></graphics-element
						>
						<graphics-element
							title="Cubic curve/line intersections"
							width="275"
							height="275"
							src="./chapters/intersections/curve-line.js"
							data-type="cubic"
						>
							<fallback-image>
								<span class="view-source">Scripts are disabled. Showing fallback image.</span>
								<img width="275px" height="275px" src="./images/chapters/intersections/7196d3dec75d53f5df9d9c832ac3c493.png" loading="lazy" />
								<label>Cubic curve/line intersections</label>
							</fallback-image></graphics-element
						>
					</div>

					<p>
						Curve/curve intersection, however, is more complicated. Since we have no straight line to align to, we can't simply align one of the
						curves and be left with a simple procedure. Instead, we'll need to apply two techniques we've met before: de Casteljau's algorithm, and
						curve splitting.
					</p>
				</section>
				<section id="curveintersection">
					<h1>
						<div class="nav"><a href="ja-JP/index.html#intersections">previous</a><a href="ja-JP/index.html#abc">next</a></div>
						<a href="ja-JP/index.html#curveintersection">Curve/curve intersection</a>
					</h1>
					<p>
						Using de Casteljau's algorithm to split the curve we can now implement curve/curve intersection finding using a "divide and conquer"
						technique:
					</p>
					<ol>
						<li>
							Take two curves <em>C<sub>1</sub></em> and <em>C<sub>2</sub></em
							>, and treat them as a pair.
						</li>
						<li>If their bounding boxes overlap, split up each curve into two sub-curves</li>
						<li>
							With <em>C<sub>1.1</sub></em
							>, <em>C<sub>1.2</sub></em
							>, <em>C<sub>2.1</sub></em> and <em>C<sub>2.2</sub></em
							>, form four new pairs (<em>C<sub>1.1</sub></em
							>,<em>C<sub>2.1</sub></em
							>), (<em>C<sub>1.1</sub></em
							>, <em>C<sub>2.2</sub></em
							>), (<em>C<sub>1.2</sub></em
							>,<em>C<sub>2.1</sub></em
							>), and (<em>C<sub>1.2</sub></em
							>,<em>C<sub>2.2</sub></em
							>).
						</li>
						<li>
							For each pair, check whether their bounding boxes overlap.
							<ol>
								<li>If their bounding boxes do not overlap, discard the pair, as there is no intersection between this pair of curves.</li>
								<li>If there <em>is</em> overlap, rerun all steps for this pair.</li>
							</ol>
						</li>
						<li>
							Once the sub-curves we form are so small that they effectively occupy sub-pixel areas, we consider an intersection found, noting that we
							might have a cluster of multiple intersections at the sub-pixel level, out of which we pick one to act as "found" <code>t</code> value
							(we can either throw all but one away, we can average the cluster's <code>t</code> values, or you can do something even more creative).
						</li>
					</ol>
					<p>
						This algorithm will start with a single pair, "balloon" until it runs in parallel for a large number of potential sub-pairs, and then
						taper back down as it homes in on intersection coordinates, ending up with as many pairs as there are intersections.
					</p>
					<p>
						The following graphic applies this algorithm to a pair of cubic curves, one step at a time, so you can see the algorithm in action. Click
						the button to run a single step in the algorithm, after setting up your curves in some creative arrangement. You can also change the value
						that is used in step 5 to determine whether the curves are small enough. Manipulating the curves or changing the threshold will reset the
						algorithm, so you can try this with lots of different curves.
					</p>
					<p>(can you find the configuration that yields the maximum number of intersections between two cubic curves? Nine intersections!)</p>
					<graphics-element title="Curve/curve intersections" width="825" height="275" src="./chapters/curveintersection/curve-curve.js">
						<fallback-image>
							<span class="view-source">Scripts are disabled. Showing fallback image.</span>
							<img width="825px" height="275px" src="./images/chapters/curveintersection/b155682162a5b6da6d40c7b531164a7e.png" loading="lazy" />
							<label></label>
						</fallback-image>
						<button class="next">Advance one step</button>
						<input type="range" min="0.01" max="5" step="0.01" value="1" class="slide-control" />
					</graphics-element>
					<p>
						Finding self-intersections is effectively the same procedure, except that we're starting with a single curve, so we need to turn that into
						two separate curves first. This is trivially achieved by splitting at an inflection point, or if there are none, just splitting at
						<code>t=0.5</code> first, and then running the exact same algorithm as above, with all non-overlapping curve pairs getting removed at each
						iteration, and each successive step homing in on the curve's self-intersection points.
					</p>
				</section>
				<section id="abc">
					<h1>
						<div class="nav"><a href="ja-JP/index.html#curveintersection">previous</a><a href="ja-JP/index.html#pointcurves">next</a></div>
						<a href="ja-JP/index.html#abc">The projection identity</a>
					</h1>
					<p>
						De Casteljau's algorithm is the pivotal algorithm when it comes to Bézier curves. You can use it not just to split curves, but also to
						draw them efficiently (especially for high-order Bézier curves), as well as to come up with curves based on three points and a tangent.
						Particularly this last thing is really useful because it lets us "mold" a curve, by picking it up at some point, and dragging that point
						around to change the curve's shape.
					</p>
					<p>How does that work? Succinctly: we run de Casteljau's algorithm in reverse!</p>
					<p>
						In order to run de Casteljau's algorithm in reverse, we need a few basic things: a start and end point, a point on the curve that want to
						be moving around, which has an associated <em>t</em> value, and a point we've not explicitly talked about before, and as far as I know has
						no explicit name, but lives one iteration higher in the de Casteljau process then our on-curve point does. I like to call it "A" for
						reasons that will become obvious.
					</p>
					<p>
						So let's use graphics instead of text to see where this "A" is, because text only gets us so far: move the sliders for the following
						graphics to see what, given specific <code>t</code> value, our <code>A</code> coordinate is. As well as some other coordinates, which
						taken together let us derive a value that the graphics call "ratio": if you move the curve's points around, A, B, and C will move, what
						happens to that value?
					</p>
					<div class="figure">
						<graphics-element
							inline="{true}"
							title="Projections in a quadratic Bézier curve"
							width="275"
							height="275"
							src="./chapters/abc/abc.js"
							data-type="quadratic"
						>
							<fallback-image>
								<span class="view-source">Scripts are disabled. Showing fallback image.</span>
								<img width="275px" height="275px" src="./images/chapters/abc/7a69dd4350ddda5701712e1d3b46b863.png" loading="lazy" />
								<label>Projections in a quadratic Bézier curve</label>
							</fallback-image>
							<input type="range" min="0" max="1" step="0.01" value="0.5" class="slide-control" />
						</graphics-element>
						<graphics-element
							inline="{true}"
							title="Projections in a cubic Bézier curve"
							width="275"
							height="275"
							src="./chapters/abc/abc.js"
							data-type="cubic"
						>
							<fallback-image>
								<span class="view-source">Scripts are disabled. Showing fallback image.</span>
								<img width="275px" height="275px" src="./images/chapters/abc/eeec7cf16fb22c666e0143a3a030731f.png" loading="lazy" />
								<label>Projections in a cubic Bézier curve</label>
							</fallback-image>
							<input type="range" min="0" max="1" step="0.01" value="0.5" class="slide-control" />
						</graphics-element>
					</div>

					<p>So these graphics show us several things:</p>
					<ol>
						<li>a point at the tip of the curve construction's "hat": let's call that <code>A</code>, as well as</li>
						<li>our on-curve point give our chosen <code>t</code> value: let's call that <code>B</code>, and finally,</li>
						<li>
							a point that we get by projecting A, through B, onto the line between the curve's start and end points: let's call that <code>C</code>.
						</li>
						<li>
							for both quadratic and cubic curves, two points <code>e1</code> and <code>e2</code>, which represent the single-to-last step in de
							Casteljau's algorithm: in the last step, we find <code>B</code> at <code>(1-t) * e1 + t * e2</code>.
						</li>
						<li>
							for cubic curves, also the points <code>v1</code> and <code>v2</code>, which together with <code>A</code> represent the first step in de
							Casteljau's algorithm: in the next step, we find <code>e1</code> and <code>e2</code>.
						</li>
					</ol>
					<p>
						These three values A, B, and C allow us to derive an important identity formula for quadratic and cubic Bézier curves: for any point on
						the curve with some <code>t</code> value, the ratio of distances from A to B and B to C is fixed: if some <code>t</code> value sets up a C
						that is 20% away from the start and 80% away from the end, then <em>it doesn't matter where the start, end, or control points are</em>;
						for that <code>t</code> value, <code>C</code> will <em>always</em> lie at 20% from the start and 80% from the end point. Go ahead, pick an
						on-curve point in either graphic and then move all the other points around: if you only move the control points, start and end won't move,
						and so neither will C, and if you move either start or end point, C will move but its relative position will not change.
					</p>
					<p>
						So, how can we compute <code>C</code>? We start with our observation that <code>C</code> always lies somewhere between the start and ends
						points, so logically <code>C</code> will have a function that interpolates between those two coordinates:
					</p>
					<!--
\setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
 
                                                   C = u(t)  · P      + (1-u(t))  · P   
                                                                start                end
-->
					<img class="LaTeX SVG" src="./images/chapters/abc/6a65a8327c06bc6f14cc4e0751d8e49e.svg" width="236px" height="16px" loading="lazy" />
					<p>
						If we can figure out what the function <code>u(t)</code> looks like, we'll be done. Although we do need to remember that this
						<code>u(t)</code> will have a different for depending on whether we're working with quadratic or cubic curves.
						<a href="https://mathoverflow.net/questions/122257/finding-the-formula-for-bezier-curve-ratios-hull-point-point-baseline"
							>Running through the maths</a
						>
						(with thanks to Boris Zbarsky) shows us the following two formulae:
					</p>
					<!--
\setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
 
                                                                               2
                                                                          (1-t) 
                                                        u(t)          = ───────────
                                                            quadratic    2        2
                                                                        t  + (1-t) 
-->
					<img class="LaTeX SVG" src="./images/chapters/abc/c10cf18edeffed67dc94d250310db475.svg" width="188px" height="41px" loading="lazy" />
					<p>And</p>
					<!--
\setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
 
                                                                             3
                                                                        (1-t) 
                                                          u(t)      = ───────────
                                                              cubic    3        3
                                                                      t  + (1-t) 
-->
					<img class="LaTeX SVG" src="./images/chapters/abc/50543216f39c1b10af7cf4823844dd31.svg" width="167px" height="41px" loading="lazy" />
					<p>
						So, if we know the start and end coordinates, and we know the <em>t</em> value, we know C, without having to calculate the
						<code>A</code> or even <code>B</code> coordinates. In fact, we can do the same for the ratio function: as another function of
						<code>t</code>, we technically don't need to know what <code>A</code> or <code>B</code> or <code>C</code> are, we can express it was a
						pure function of <code>t</code>, too.
					</p>
					<p>We start by observing that, given <code>A</code>, <code>B</code>, and <code>C</code>, the following always holds:</p>
					<!--
\setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
 
                                                               distance(B,C)
                                                    ratio(t) = ───────────── = Constant
                                                               distance(A,B)
-->
					<img class="LaTeX SVG" src="./images/chapters/abc/b9854fbcb1096f736607d292dbe48371.svg" width="251px" height="39px" loading="lazy" />
					<p>Working out the maths for this, we see the following two formulae for quadratic and cubic curves:</p>
					<!--
\setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
 
                                                                         2        2
                                                                        t  + (1-t)  - 1
                                                   ratio(t)          = |───────────────|
                                                           quadratic       2        2
                                                                          t  + (1-t) 
-->
					<img class="LaTeX SVG" src="./images/chapters/abc/f78ce50f725f208f25090abc7fd741b7.svg" width="245px" height="41px" loading="lazy" />
					<p>And</p>
					<!--
\setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
 
                                                                       3        3
                                                                      t  + (1-t)  - 1
                                                     ratio(t)      = |───────────────|
                                                             cubic       3        3
                                                                        t  + (1-t) 
-->
					<img class="LaTeX SVG" src="./images/chapters/abc/c018aab3952ea9193848564aab12b241.svg" width="223px" height="41px" loading="lazy" />
					<p>
						Which now leaves us with some powerful tools: given thee points (start, end, and "some point on the curve"), as well as a
						<code>t</code> value, we can <em>construct</em> curves: we can compute <code>C</code> using the start and end points, and our
						<code>u(t)</code> function, and once we have <code>C</code>, we can use our on-curve point (<code>B</code>) and the
						<code>ratio(t)</code> function to find <code>A</code>:
					</p>
					<!--
\setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
 
                                                               C - B          B - C
                                                      A = B - ──────── = B + ────────
                                                              ratio(t)       ratio(t)
-->
					<img class="LaTeX SVG" src="./images/chapters/abc/bb8674f5f36b054b7734e34b91ed924f.svg" width="217px" height="37px" loading="lazy" />
					<p>
						With <code>A</code> found, finding <code>e1</code> and <code>e2</code> for quadratic curves is a matter of running the linear
						interpolation with <code>t</code> between start and <code>A</code> to yield <code>e1</code>, and between <code>A</code> and end to yield
						<code>e2</code>. For cubic curves, there is no single pair of points that can act as <code>e1</code> and <code>e2</code>: as long as the
						distance ratio between <code>e1</code> to <code>B</code> and <code>B</code> to <code>e2</code> is the Bézier ratio <code>(1-t):t</code>,
						we can reverse engineer <code>v1</code> and <code>v2</code>:
					</p>
					<!--
\setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
 
                                                            ╭          A' - e 
                                                            │                1
                                                            │ v = A' - ───────
                                                            ╡  1        1 - t  
                                                            │          A' - e 
                                                            │                2
                                                            │ v = A' - ───────
                                                            ╰  2          t
-->
					<img class="LaTeX SVG" src="./images/chapters/abc/eccc1bdb9423bbfe2d42418fc8a7dd24.svg" width="132px" height="75px" loading="lazy" />
					<p>And then reverse engineer the curve's control control points:</p>
					<!--
\setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
 
                                                         ╭              v  - start
                                                         │               1
                                                         │ C '= start + ──────────
                                                         ╡  1               t      
                                                         │            v  - end
                                                         │             2
                                                         │ C '= end + ────────    
                                                         ╰  2          1 - t
-->
					<img class="LaTeX SVG" src="./images/chapters/abc/c14d8ce6eccca2c8063af40e5ac0bfd4.svg" width="164px" height="73px" loading="lazy" />
					<p>
						So: if we have a curve's start and end point, then for any <code>t</code> value we implicitly know all the ABC values, which (combined
						with an educated guess on appropriate <code>e1</code> and <code>e2</code> coordinates for cubic curves) gives us the necessary information
						to reconstruct a curve's "de Casteljau skeleton". Which means that we can now do several things: we can "fit" curves using only three
						points, which means we can also "mold" curves by moving an on-curve point but leaving its start and end point, and then reconstructing the
						curve based on where we moved the on-curve point to. These are very useful things, and we'll look at both in the next few sections.
					</p>
				</section>
				<section id="pointcurves">
					<h1>
						<div class="nav"><a href="ja-JP/index.html#abc">previous</a><a href="ja-JP/index.html#projections">next</a></div>
						<a href="ja-JP/index.html#pointcurves">Creating a curve from three points</a>
					</h1>
					<p>
						Given the preceding section, you might be wondering if we can use that knowledge to just "create" curves by placing some points and having
						the computer do the rest, to which the answer is: that's exactly what we can now do!
					</p>
					<p>
						For quadratic curves, things are pretty easy. Technically, we'll need a <code>t</code> value in order to compute the ratio function used
						in computing the ABC coordinates, but we can just as easily approximate one by treating the distance between the start and
						<code>B</code> point, and <code>B</code> and end point as a ratio, using
					</p>
					<!--
\setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
 
                                                           ╭ d = || Start - B||
                                                           │  1
                                                           │ d = || End - B||  
                                                           │  2
                                                           ╡      d             
                                                           │       1
                                                           │  t= ─────         
                                                           │     d +d 
                                                           ╰      1  2
-->
					<img
						class="LaTeX SVG"
						src="./images/chapters/pointcurves/f8182445c1cd7ae9f368b88fa7090e53.svg"
						width="119px"
						height="84px"
						loading="lazy"
					/>
					<p>
						With this code in place, creating a quadratic curve from three points is literally just computing the ABC values, and using
						<code>A</code> as our curve's control point:
					</p>
					<graphics-element title="Fitting a quadratic Bézier curve" width="275" height="275" src="./chapters/pointcurves/quadratic.js">
						<fallback-image>
							<span class="view-source">Scripts are disabled. Showing fallback image.</span>
							<img width="275px" height="275px" src="./images/chapters/pointcurves/067a3df30e32708fc0d13f8eb78c0b05.png" loading="lazy" />
							<label>Fitting a quadratic Bézier curve</label>
						</fallback-image></graphics-element
					>
					<p>
						For cubic curves we need to do a little more work, but really only just a little. We're first going to assume that a decent curve through
						the three points should approximate a circular arc, which first requires knowing how to fit a circle to three points. You may remember (if
						you ever learned it!) that a line between two points on a circle is called a
						<a href="https://en.wikipedia.org/wiki/Chord_%28geometry%29">chord</a>, and that one property of chords is that the line from the center
						of any chord, perpendicular to that chord, passes through the center of the circle.
					</p>
					<p>
						That means that if we have have three points on a circle, we have three (different) chords, and consequently, three (different) lines that
						go from those chords through the center of the circle: if we find two of those lines, then their intersection will be our circle's center,
						and the circle's radius will—by definition!—be the distance from the center to any of our three points:
					</p>
					<graphics-element title="Finding a circle through three points" width="275" height="275" src="./chapters/pointcurves/circle.js">
						<fallback-image>
							<span class="view-source">Scripts are disabled. Showing fallback image.</span>
							<img width="275px" height="275px" src="./images/chapters/pointcurves/43875f6ad588bfd04cdb65b591a62052.png" loading="lazy" />
							<label>Finding a circle through three points</label>
						</fallback-image></graphics-element
					>
					<p>
						With that covered, we now also know the tangent line to our point <code>B</code>, because the tangent to any point on the circle is a line
						through that point, perpendicular to the line from that point to the center. That just leaves marking appropriate points
						<code>e1</code> and <code>e2</code> on that tangent, so that we can construct a new cubic curve hull. We use the approach as we did for
						quadratic curves to automatically determine a reasonable <code>t</code> value, and then our <code>e1</code> and
						<code>e2</code> coordinates must obey the standard de Casteljau rule for linear interpolation:
					</p>
					<!--
\setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
 
                                                           ╭ e = B + t  · d    
                                                           ╡  1                 
                                                           │ e = B - (1-t)  · d
                                                           ╰  2
-->
					<img
						class="LaTeX SVG"
						src="./images/chapters/pointcurves/8ffdd4a58cbd0fc24caef781f23a7950.svg"
						width="139px"
						height="40px"
						loading="lazy"
					/>
					<p>
						Where <code>d</code> is the total length of the line segment from <code>e1</code> to <code>e2</code>. So how long do we make that? There
						are again all kinds of approaches we can take, and a simple-but-effective one is to set the length of that segment to "one third the
						length of the baseline". This forces <code>e1</code> and <code>e2</code> to always be the "linear curve" distance apart, which means if we
						place our three points on a line, it will actually <em>look</em> like a line. Nice! The last thing we'll need to do is make sure to flip
						the sign of <code>d</code> depending on which side of the baseline our <code>B</code> is located, so we don't up creating a funky curve
						with a loop in it. To do this, we can use the <a href="https://en.wikipedia.org/wiki/Atan2">atan2</a> function:
					</p>
					<!--
\setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
 
                                  \phi = (atan2(E -S , E -S ) - atan2(B -S , B -S ) + 2 \pi)   mod  2 \pi
                                                 y  y   x  x           y  y   x  x
-->
					<img
						class="LaTeX SVG"
						src="./images/chapters/pointcurves/a5cd63b54be6b554290c38787cfbbabd.svg"
						width="488px"
						height="24px"
						loading="lazy"
					/>
					<p>
						This angle φ will be between 0 and π if <code>B</code> is "above" the baseline (rotating all three points so that the start is on the left
						and the end is the right), so we can use a relatively straight forward check to make sure we're using the correct sign for our value
						<code>d</code>:
					</p>
					<!--
\setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
 
                                                  d = {  d  if  0 ≤\phi ≤\pi             
                                                        -d  if  \phi < 0 \lor \phi > \pi
-->
					<img
						class="LaTeX SVG"
						src="./images/chapters/pointcurves/4fe687c8a65265a2a755ba5841d0e31d.svg"
						width="177px"
						height="40px"
						loading="lazy"
					/>
					<p>The result of this approach looks as follows:</p>
					<graphics-element
						title="Finding the cubic e₁ and e₂ given three points "
						width="275"
						height="275"
						src="./chapters/pointcurves/circle.js"
						data-show-curve="true"
					>
						<fallback-image>
							<span class="view-source">Scripts are disabled. Showing fallback image.</span>
							<img width="275px" height="275px" src="./images/chapters/pointcurves/75f7b5b31e98444e13f17e5c3e5b7322.png" loading="lazy" />
							<label>Finding the cubic e₁ and e₂ given three points </label>
						</fallback-image></graphics-element
					>
					<p>
						It is important to remember that even though we're using a circular arc to come up with decent <code>e1</code> and <code>e2</code> terms,
						we're <em>not</em> trying to perfectly create a circular arc with a cubic curve (which is good, because we can't;
						<a href="#arcapproximation">more on that later</a>), we're <em>only</em> trying to come up with some reasonable <code>e1</code> and
						<code>e2</code> points so we can construct a new cubic curve... so now that we have those: let's see what kind of cubic curve that gives
						us:
					</p>
					<graphics-element title="Fitting a quadratic Bézier curve" width="275" height="275" src="./chapters/pointcurves/cubic.js">
						<fallback-image>
							<span class="view-source">Scripts are disabled. Showing fallback image.</span>
							<img width="275px" height="275px" src="./images/chapters/pointcurves/eab6ea46fa93030e03ec0ef7deb571dc.png" loading="lazy" />
							<label>Fitting a quadratic Bézier curve</label>
						</fallback-image></graphics-element
					>
					<p>That looks perfectly serviceable!</p>
					<p>
						Of course, we can take this one step further: we can't just "create" curves, we also have (almost!) all the tools available to "mold"
						curves, where we can reshape a curve by dragging a point on the curve around while leaving the start and end fixed, effectively molding
						the shape as if it were clay or the like. We'll see the last tool we need to do that in the next section, and then we'll look at
						implementing curve molding in the section after that, so read on!
					</p>
				</section>
				<section id="projections">
					<h1>
						<div class="nav"><a href="ja-JP/index.html#pointcurves">previous</a><a href="ja-JP/index.html#molding">next</a></div>
						<a href="ja-JP/index.html#projections">Projecting a point onto a Bézier curve</a>
					</h1>
					<p>
						Before we can move on to actual curve molding, it'll be good if know how to actually be able to find "some point on the curve" that we're
						trying to click on. After all, if all we have is our Bézier coordinates, that is not in itself enough to figure out which point on the
						curve our cursor will be closest to. So, how do we project points onto a curve?
					</p>
					<p>
						If the Bézier curve is of low enough order, we might be able to
						<a href="https://web.archive.org/web/20140713004709/http://jazzros.blogspot.com/2011/03/projecting-point-on-bezier-curve.html"
							>work out the maths for how to do this</a
						>, and get a perfect <code>t</code> value back, but in general this is an incredibly hard problem and the easiest solution is, really, a
						numerical approach again. We'll be finding our ideal <code>t</code> value using a
						<a href="https://en.wikipedia.org/wiki/Binary_search_algorithm">binary search</a>. First, we do a coarse distance-check based on
						<code>t</code> values associated with the curve's "to draw" coordinates (using a lookup table, or LUT). This is pretty fast:
					</p>

					<table class="code">
						<tr>
							<td>1</td>
							<td rowspan="7">
								<textarea disabled rows="7" role="doc-example">
p = some point to project onto the curve
d = some initially huge value
i = 0
for (coordinate, index) in LUT:
  if distance(coordinate, p) < d:
    d = distance(coordinate, p)
    i = index</textarea
								>
							</td>
						</tr>
						<tr>
							<td>2</td>
						</tr>
						<tr>
							<td>3</td>
						</tr>
						<tr>
							<td>4</td>
						</tr>
						<tr>
							<td>5</td>
						</tr>
						<tr>
							<td>6</td>
						</tr>
						<tr>
							<td>7</td>
						</tr>
					</table>

					<p>
						After this runs, we know that <code>LUT[i]</code> is the coordinate on the curve <em>in our LUT</em> that is closest to the point we want
						to project, so that's a pretty good initial guess as to what the best projection onto our curve is. To refine it, we note that LUT[i] is a
						better guess than both LUT[i-1] and LUT[i+1], but there might be an even better projection <em>somewhere else</em> between those two
						values, so that's what we're going to be testing for, using a variation of the binary search.
					</p>
					<ol>
						<li>
							we start with our point <code>p</code>, and the <code>t</code> values <code>t1=LUT[i-1].t</code> and <code>t2=LUT[i+1].t</code>, which
							span an interval <code>v = t2-t1</code>.
						</li>
						<li>
							we test this interval in five spots: the start, middle, and end (which we already have), and the two points in between the middle and
							start/end points
						</li>
						<li>
							we then check which of these five points is the closest to our original point <code>p</code>, and then repeat step 1 with the points
							before and after the closest point we just found.
						</li>
					</ol>
					<p>
						This makes the interval we check smaller and smaller at each iteration, and we can keep running the three steps until the interval becomes
						so small as to lead to distances that are, for all intents and purposes, the same for all points.
					</p>
					<p>
						So, let's see that in action: in this case, I'm going to arbitrarily say that if we're going to run the loop until the interval is smaller
						than 0.001, and show you what that means for projecting your mouse cursor or finger tip onto a rather complex Bézier curve (which, of
						course, you can reshape as you like). Also shown are the original three points that our coarse check finds.
					</p>
					<graphics-element title="Projecting a point onto a Bézier curve" width="400" height="400" src="./chapters/projections/project.js">
						<fallback-image>
							<span class="view-source">Scripts are disabled. Showing fallback image.</span>
							<img width="400px" height="400px" src="./images/chapters/projections/3cc334d0ebc01cc5352e23ed47bc5414.png" loading="lazy" />
							<label></label> </fallback-image
					></graphics-element>
				</section>
				<section id="molding">
					<h1>
						<div class="nav"><a href="ja-JP/index.html#projections">previous</a><a href="ja-JP/index.html#curvefitting">next</a></div>
						<a href="ja-JP/index.html#molding">Molding a curve</a>
					</h1>
					<p>
						Armed with knowledge of the "ABC" relation, point-on-curve projection, and guestimating reasonable looking helper values for cubic curve
						construction, we can finally cover curve molding: updating a curve's shape interactively, by dragging points on the curve around.
					</p>
					<p>
						For quadratic curve, this is a really simple trick: we project our cursor onto the curve, which gives us a <code>t</code> value and
						initial <code>B</code> coordinate. We don't even need the latter: with our <code>t</code> value and "wherever the cursor is" as target
						<code>B</code>, we can compute the associated <code>C</code>:
					</p>
					<!--
\setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
 
                                                   C = u(t)   · Start + (1-u(t) )  · End
                                                           q                   q
-->
					<img class="LaTeX SVG" src="./images/chapters/molding/70262c533569a7da06cc1b950e932d6f.svg" width="248px" height="24px" loading="lazy" />
					<p>And then the associated <code>A</code>:</p>
					<!--
\setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
 
                                                               C - B           B - C
                                                     A = B - ───────── = B + ─────────
                                                             ratio(t)        ratio(t) 
                                                                     q               q
-->
					<img class="LaTeX SVG" src="./images/chapters/molding/6f12fcc00f4106bbc920d7451398d3b2.svg" width="231px" height="41px" loading="lazy" />
					<p>And we're done, because that's our new quadratic control point!</p>
					<graphics-element
						title="Molding a quadratic Bézier curve"
						width="825"
						height="275"
						src="./chapters/molding/molding.js"
						data-type="quadratic"
					>
						<fallback-image>
							<span class="view-source">Scripts are disabled. Showing fallback image.</span>
							<img width="825px" height="275px" src="./images/chapters/molding/2bd215d1db191b52a89a94727b6aa5ce.png" loading="lazy" />
							<label></label> </fallback-image
					></graphics-element>
					<p>
						As before, cubic curves are a bit more work, because while it's easy to find our initial <code>t</code> value and ABC values, getting
						those all-important <code>e1</code> and <code>e2</code> coordinates is going to pose a bit of a problem... in the section on curve
						creation, we were free to pick an appropriate <code>t</code> value ourselves, which allowed us to find appropriate <code>e1</code> and
						<code>e2</code> coordinates. That's great, but when we're curve molding we don't have that luxury: whatever point we decide to start
						moving around already has its own <code>t</code> value, and its own <code>e1</code> and <code>e2</code> values, and those may not make
						sense for the rest of the curve.
					</p>
					<p>
						For example, let's see what happens if we just "go with what we get" when we pick a point and start moving it around, preserving its
						<code>t</code> value and <code>e1</code>/<code>e2</code> coordinates:
					</p>
					<graphics-element title="Molding a cubic Bézier curve" width="825" height="275" src="./chapters/molding/molding.js" data-type="cubic">
						<fallback-image>
							<span class="view-source">Scripts are disabled. Showing fallback image.</span>
							<img width="825px" height="275px" src="./images/chapters/molding/a54f990aa49fb9ea8200b59259f955f3.png" loading="lazy" />
							<label></label> </fallback-image
					></graphics-element>
					<p>
						That looks reasonable, close to the original point, but the further we drag our point, the less "useful" things become. Especially if we
						drag our point across the baseline, rather than turning into a nice curve.
					</p>
					<p>
						One way to combat this might be to combine the above approach with the approach from the
						<a href="#pointcurves">creating curves</a> section: generate both the "unchanged <code>t</code>/<code>e1</code>/<code>e2</code>" curve, as
						well as the "idealized" curve through the start/cursor/end points, with idealized <code>t</code> value, and then interpolating between
						those two curves:
					</p>
					<graphics-element
						title="Molding a cubic Bézier curve"
						width="825"
						height="275"
						src="./chapters/molding/molding.js"
						data-type="cubic"
						data-interpolated="true"
					>
						<fallback-image>
							<span class="view-source">Scripts are disabled. Showing fallback image.</span>
							<img width="825px" height="275px" src="./images/chapters/molding/1039d0bb0e49cfb472c2fa37f9010190.png" loading="lazy" />
							<label></label>
						</fallback-image>
						<input type="range" min="10" max="200" step="1" value="100" class="slide-control" />
					</graphics-element>
					<p>
						The slide controls the "falloff distance" relative to where the original point on the curve is, so that as we drag our point around, it
						interpolates with a bias towards "preserving <code>t</code>/<code>e1</code>/<code>e2</code>" closer to the original point, and bias
						towards "idealized" form the further away we move our point, with anything that's further than our falloff distance simply
						<em>being</em> the idealized curve. We don't even try to interpolate at that point.
					</p>
					<p>
						A more advanced way to try to smooth things out is to implement <em>continuous</em> molding, where we constantly update the curve as we
						move around, and constantly change what our <code>B</code> point is, based on constantly projecting the cursor on the curve
						<em>as we're updating it</em> - this is, you won't be surprised to learn, tricky, and beyond the scope of this section: interpolation
						(with a reasonable distance) will do for now!
					</p>
				</section>
				<section id="curvefitting">
					<h1>
						<div class="nav"><a href="ja-JP/index.html#molding">previous</a><a href="ja-JP/index.html#catmullconv">next</a></div>
						<a href="ja-JP/index.html#curvefitting">Curve fitting</a>
					</h1>
					<p>
						Given the previous section, one question you might have is "what if I don't want to guess <code>t</code> values?". After all, plenty of
						graphics packages do automated curve fitting, so how can we implement that in a way that just finds us reasonable <code>t</code> values
						all on its own?
					</p>
					<p>
						And really this is just a variation on the question "how do I get the curve through these X points?", so let's look at that. Specifically,
						let's look at the answer: "curve fitting". This is in fact a rather rich field in geometry, applying to anything from data modelling to
						path abstraction to "drawing", so there's a fair number of ways to do curve fitting, but we'll look at one of the most common approaches:
						something called a <a href="https://en.wikipedia.org/wiki/Least_squares">least squares</a>
						<a href="https://en.wikipedia.org/wiki/Polynomial_regression">polynomial regression</a>. In this approach, we look at the number of points
						we have in our data set, roughly determine what would be an appropriate order for a curve that would fit these points, and then tackle the
						question "given that we want an <code>nth</code> order curve, what are the coordinates we can find such that our curve is "off" by the
						least amount?".
					</p>
					<p>
						Now, there are many ways to determine how "off" points are from the curve, which is where that "least squares" term comes in. The most
						common tool in the toolbox is to minimise the <em>squared distance</em> between each point we have, and the corresponding point on the
						curve we end up "inventing". A curve with a snug fit will have zero distance between those two, and a bad fit will have non-zero distances
						between every such pair. It's a workable metric. You might wonder why we'd need to square, rather than just ensure that distance is a
						positive value (so that the total error is easy to compute by just summing distances) and the answer really is "because it tends to be a
						little better". There's lots of literature on the web if you want to deep-dive the specific merits of least squared error metrics versus
						least absolute error metrics, but those are <em>well</em> beyond the scope of this material.
					</p>
					<p>
						So let's look at what we end up with in terms of curve fitting if we start with the idea of performing least squares Bézier fitting. We're
						going to follow a procedure similar to the one described by Jim Herold over on his
						<a href="https://web.archive.org/web/20180403213813/http://jimherold.com/2012/04/20/least-squares-bezier-fit/"
							>"Least Squares Bézier Fit"</a
						>
						article, and end with some nice interactive graphics for doing some curve fitting.
					</p>
					<p>
						Before we begin, we're going to use the curve in matrix form. In the <a href="#matrix">section on matrices</a>, I mentioned that some
						things are easier if we use the matrix representation of a Bézier curve rather than its calculus form, and this is one of those things.
					</p>
					<p>
						As such, the first step in the process is expressing our Bézier curve as powers/coefficients/coordinate matrix <strong>T x M x C</strong>,
						by expanding the Bézier functions.
					</p>
					<div class="note">
						<h2>Revisiting the matrix representation</h2>
						<p>
							Rewriting Bézier functions to matrix form is fairly easy, if you first expand the function, and then arrange them into a multiple line
							form, where each line corresponds to a power of t, and each column is for a specific coefficient. First, we expand the function:
						</p>
						<!--
\setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
 
                                                                   2                    2
                                                B         = a (1-t)  + 2 b (1-t) t + c t    
                                                 quadratic                                  
                                                                        2            2     2
                                                          = a - 2at + at  + 2bt - 2bt  + ct 
-->
						<img
							class="LaTeX SVG"
							src="./images/chapters/curvefitting/31d659cbc72bf304abf4c9a75b6b81de.svg"
							width="295px"
							height="43px"
							loading="lazy"
						/>
						<p>And then we (trivially) rearrange the terms across multiple lines:</p>
						<!--
\setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
 
                                                        B         =a               
                                                         quadratic
                                                                   - 2at+ 2bt      
                                                                       2     2    2
                                                                   + at - 2bt + ct 
-->
						<img
							class="LaTeX SVG"
							src="./images/chapters/curvefitting/a6faaf6083c818431988fef49421cc47.svg"
							width="216px"
							height="64px"
							loading="lazy"
						/>
						<p>
							This rearrangement has "factors of t" at each row (the first row is t⁰, i.e. "1", the second row is t¹, i.e. "t", the third row is t²)
							and "coefficient" at each column (the first column is all terms involving "a", the second all terms involving "b", the third all terms
							involving "c").
						</p>
						<p>With that arrangement, we can easily decompose this as a matrix multiplication:</p>
						<!--
\setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
 
                                                                 ┌  a   0  0 ┐                 ┌  1  0 0 ┐    ┌ a ┐
                         B         = T  · M  · C = ┌      2 ┐  · │ -2a  2b 0 │ = ┌      2 ┐  · │ -2  2 0 │  · │ b │
                          quadratic                └ 1 t t  ┘    └  a  -2b c ┘   └ 1 t t  ┘    └  1 -2 1 ┘    └ c ┘
-->
						<img
							class="LaTeX SVG"
							src="./images/chapters/curvefitting/505ab1ada6a187e9ba392d19739ac2c5.svg"
							width="572px"
							height="53px"
							loading="lazy"
						/>
						<p>We can do the same for the cubic curve, of course. We know the base function for cubics:</p>
						<!--
\setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
 
                                                            3          2             2     3
                                               B     =a(1-t)  + 3b(1-t)  t + 3c(1-t)t  + dt 
                                                cubic
-->
						<img
							class="LaTeX SVG"
							src="./images/chapters/curvefitting/06605e008956609e8844ef95697c9096.svg"
							width="355px"
							height="19px"
							loading="lazy"
						/>
						<p>So we write out the expansion and rearrange:</p>
						<!--
\setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
 
                                                       B     =a                     
                                                        cubic
                                                              - 3at + 3bt           
                                                                   2     2    2     
                                                              + 3at - 6bt +3ct      
                                                                  3      3    3    3
                                                              - at  + 3bt -3ct + dt 
-->
						<img
							class="LaTeX SVG"
							src="./images/chapters/curvefitting/7c6b50cee5dc685515943a199d7a65fc.svg"
							width="248px"
							height="87px"
							loading="lazy"
						/>
						<p>Which we can then decompose:</p>
						<!--
\setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
 
                                                                              ┌  1  0  0 0 ┐    ┌ a ┐
                                       B     = T  · M  · C = ┌      2  3 ┐  · │ -3  3  0 0 │  · │ b │
                                        cubic                └ 1 t t  t  ┘    │  3 -6  3 0 │    │ c │
                                                                              └ -1  3 -3 1 ┘    └ d ┘
-->
						<img
							class="LaTeX SVG"
							src="./images/chapters/curvefitting/9651a687e1522b00bcba063881230902.svg"
							width="404px"
							height="72px"
							loading="lazy"
						/>
						<p>And, of course, we can do this for quartic curves too (skipping the expansion step):</p>
						<!--
\setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
 
                                                                              ┌  1  0   0   0 0 ┐    ┌ a ┐
                                                                              │ -4  4   0   0 0 │    │ b │
                                  B       = T  · M  · C = ┌      2  3  4 ┐  · │  6 -12  6   0 0 │  · │ c │
                                   quartic                └ 1 t t  t  t  ┘    │ -4  12 -12  4 0 │    │ d │
                                                                              └  1  -4  6  -4 1 ┘    └ e ┘
-->
						<img
							class="LaTeX SVG"
							src="./images/chapters/curvefitting/409d10c3005b0c93489d72a5dba692d7.svg"
							width="491px"
							height="92px"
							loading="lazy"
						/>
						<p>
							And so and on so on. Now, let's see how to use these <strong>T</strong>, <strong>M</strong>, and <strong>C</strong>, to do some curve
							fitting.
						</p>
					</div>

					<p>
						Let's get started: we're going to assume we picked the right order curve: for <code>n</code> points we're fitting an <code>n-1</code
						><sup>th</sup> order curve, so we "start" with a vector <strong>P</strong> that represents the coordinates we already know, and for which
						we want to do curve fitting:
					</p>
					<!--
\setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
 
                                                                    ┌ p   ┐
                                                                    │  1  │
                                                                    │ p   │
                                                                P = │  2  │
                                                                    │ ... │
                                                                    │ p   │
                                                                    └  n  ┘
-->
					<img
						class="LaTeX SVG"
						src="./images/chapters/curvefitting/b017da988c9a778a4ce6a6f4ea4790d4.svg"
						width="63px"
						height="73px"
						loading="lazy"
					/>
					<p>
						Next, we need to figure out appropriate <code>t</code> values for each point in the curve, because we need something that lets us tie "the
						actual coordinate" to "some point on the curve". There's a fair number of different ways to do this (and a large part of optimizing "the
						perfect fit" is about picking appropriate <code>t</code> values), but in this case let's look at two "obvious" choices:
					</p>
					<ol>
						<li>equally spaced <code>t</code> values, and</li>
						<li><code>t</code> values that align with distance along the polygon.</li>
					</ol>
					<p>
						The first one is really simple: if we have <code>n</code> points, then we'll just assign each point <code>i</code> a <code>t</code> value
						of <code>(i-1)/(n-1)</code>. So if we have four points, the first point will have <code>t=(1-1)/(4-1)=0/3</code>, the second point will
						have <code>t=(2-1)/(4-1)=1/3</code>, the third point will have <code>t=2/3</code>, and the last point will be <code>t=1</code>. We're just
						straight up spacing the <code>t</code> values to match the number of points we have.
					</p>
					<p>
						The second one is a little more interesting: since we're doing polynomial regression, we might as well exploit the fact that our base
						coordinates just constitute a collection of line segments. At the first point, we're fixing t=0, and the last point, we want t=1, and
						anywhere in between we're simply going to say that <code>t</code> is equal to the distance along the polygon, scaled to the [0,1] domain.
					</p>
					<p>To get these values, we first compute the general "distance along the polygon" matrix:</p>
					<!--
\setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
 
                                                                     ╭            d  = 0
                                      D = ┌ d  d  ... d  ┐,   where  ╡             1                 
                                          └  1  2      n ┘           │ d  = d    +  length(p   , p )
                                                                     ╰  i    i-1            i-1   i
-->
					<img
						class="LaTeX SVG"
						src="./images/chapters/curvefitting/2f82371abb7835f9b9d440dc5dd151a8.svg"
						width="395px"
						height="40px"
						loading="lazy"
					/>
					<p>
						Where <code>length()</code> is literally just that: the length of the line segment between the point we're looking at, and the previous
						point. This isn't quite enough, of course: we still need to make sure that all the values between <code>i=1</code> and
						<code>i=n</code> fall in the [0,1] interval, so we need to scale all values down by whatever the total length of the polygon is:
					</p>
					<!--
\setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
 
                                                                              ╭    s  = 0
                                                                              │     1
                                               S = ┌ s  s  ... s  ┐,   where  ╡ s  = d  / d  
                                                   └  1  2      n ┘           │  i    i    n
                                                                              │    s  = 1
                                                                              ╰     n
-->
					<img
						class="LaTeX SVG"
						src="./images/chapters/curvefitting/6f734d319a1cfe0de76574a65abb07e1.svg"
						width="272px"
						height="55px"
						loading="lazy"
					/>
					<p>
						And now we can move on to the actual "curve fitting" part: what we want is a function that lets us compute "ideal" control point values
						such that if we build a Bézier curve with them, that curve passes through all our original points. Or, failing that, have an overall error
						distance that is as close to zero as we can get it. So, let's write out what the error distance looks like.
					</p>
					<p>
						As mentioned before, this function is really just "the distance between the actual coordinate, and the coordinate that the curve evaluates
						to for the associated <code>t</code> value", which we'll square to get rid of any pesky negative signs:
					</p>
					<!--
\setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
 
                                                                                  2
                                                        E(C)  = (p  -  Bézier(s )) 
                                                            i     i            i
-->
					<img
						class="LaTeX SVG"
						src="./images/chapters/curvefitting/464dbfb5adb6233108053dfac6fa4fe5.svg"
						width="177px"
						height="23px"
						loading="lazy"
					/>
					<p>
						Since this function only deals with individual coordinates, we'll need to sum over all coordinates in order to get the full error
						function. So, we literally just do that; the total error function is simply the sum of all these individual errors:
					</p>
					<!--
\setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
 
                                                            __ n                     2
                                                     E(C) = ❯      (p  -  Bézier(s )) 
                                                            ‾‾ i=1   i            i
-->
					<img
						class="LaTeX SVG"
						src="./images/chapters/curvefitting/940455f4016ab1be6d46c6f176fd2f76.svg"
						width="195px"
						height="41px"
						loading="lazy"
					/>
					<p>
						And here's the trick that justifies using matrices: while we can work with individual values using calculus, with matrices we can compute
						as many values as we make our matrices big, all at the "same time", We can replace the individual terms p<sub>i</sub> with the full
						<strong>P</strong> coordinate matrix, and we can replace Bézier(s<sub>i</sub>) with the matrix representation
						<strong>T x M x C</strong> we talked about before, which gives us:
					</p>
					<!--
\setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
 
                                                                             2
                                                             E(C) = (P - TMC) 
-->
					<img
						class="LaTeX SVG"
						src="./images/chapters/curvefitting/7b0199bb515d2754c03d8f796b29febf.svg"
						width="141px"
						height="21px"
						loading="lazy"
					/>
					<p>In which we can replace the rather cumbersome "squaring" operation with a more conventional matrix equivalent:</p>
					<!--
\setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
 
                                                                        T
                                                        E(C) = (P - TMC)  (P - TMC)
-->
					<img
						class="LaTeX SVG"
						src="./images/chapters/curvefitting/8068231b915832938136d5833f74751d.svg"
						width="225px"
						height="21px"
						loading="lazy"
					/>
					<p>
						Here, the letter <code>T</code> is used instead of the number 2, to represent the
						<a href="https://en.wikipedia.org/wiki/Transpose">matrix transpose</a>; each row in the original matrix becomes a column in the transposed
						matrix instead (row one becomes column one, row two becomes column two, and so on).
					</p>
					<p>
						This leaves one problem: <strong>T</strong> isn't actually the matrix we want: we don't want symbolic <code>t</code> values, we want the
						actual numerical values that we computed for <strong>S</strong>, so we need to form a new matrix, which we'll call 𝕋, that makes use of
						those, and then use that 𝕋 instead of <strong>T</strong> in our error function:
					</p>
					<!--
\setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
 
                                                         ┌    0    1      n-2   n-1  ┐
                                                         │   s    s  ... s     s     │
                                                         │    1    1      1     1    │
                                                         │                           │
                                                     𝕋 = │ \vdots    ...      \vdots │
                                                         │                           │
                                                         │    0    1      n-2   n-1  │
                                                         │   s    s  ... s     s     │
                                                         └    n    n      n     n    ┘
-->
					<img
						class="LaTeX SVG"
						src="./images/chapters/curvefitting/4dd55c228a26bb50da912a45e8721024.svg"
						width="201px"
						height="96px"
						loading="lazy"
					/>
					<p>Which, because of the first and last values in <strong>S</strong>, means:</p>
					<!--
\setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
 
                                                        ┌    1     0  ...   0    0    ┐
                                                        │                  n-2   n-1  │
                                                        │    1    s       s     s     │
                                                        │          2       2     2    │
                                                    𝕋 = │ \vdots      ...      \vdots │
                                                        │                  n-2   n-1  │
                                                        │    1   s        s     s     │
                                                        │         n-1      n-1   n-1  │
                                                        └    1     1  ...   1    1    ┘
-->
					<img
						class="LaTeX SVG"
						src="./images/chapters/curvefitting/38bb81bdd3eaa72c2336514187aa374b.svg"
						width="212px"
						height="92px"
						loading="lazy"
					/>
					<p>Now we can properly write out the error function as matrix operations:</p>
					<!--
\setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
 
                                                                        T
                                                        E(C) = (P - 𝕋MC)  (P - 𝕋MC)
-->
					<img
						class="LaTeX SVG"
						src="./images/chapters/curvefitting/989f2ad06ae308f71cef527a5594129a.svg"
						width="231px"
						height="21px"
						loading="lazy"
					/>
					<p>
						So, we have our error function: we now need to figure out the expression for where that function has minimal value, e.g. where the error
						between the true coordinates and the coordinates generated by the curve fitting is smallest. Like in standard calculus, this requires
						taking the derivative, and determining where that derivative is zero:
					</p>
					<!--
\setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
 
                                                          ∂E          T
                                                          ── = 0 = -2𝕋  (P - 𝕋MC)
                                                          ∂C
-->
					<img
						class="LaTeX SVG"
						src="./images/chapters/curvefitting/ea24b0e42f0a89464bda275ac8f9bacf.svg"
						width="197px"
						height="36px"
						loading="lazy"
					/>
					<div class="note">
						<h2>Where did this derivative come from?</h2>
						<p>
							That... is a good question. In fact, when trying to run through this approach, I ran into the same question! And you know what? I
							straight up had no idea. I'm decent enough at calculus, I'm decent enough at linear algebra, and I just don't know.
						</p>
						<p>
							So I did what I always do when I don't understand something: I asked someone to help me understand how things work. In this specific
							case, I
							<a href="https://math.stackexchange.com/questions/2825438/how-do-you-compute-the-derivative-of-a-matrix-algebra-expression"
								>posted a question</a
							>
							to <a href="https://math.stackexchange.com">Math.stackexchange</a>, and received a answer that goes into way more detail than I had
							hoped to receive.
						</p>
						<p>
							Is that answer useful to you? Probably: no. At least, not unless you like understanding maths on a recreational level. And I do mean
							maths in general, not just basic algebra. But it does help in giving us a reference in case you ever wonder "Hang on. Why was that
							true?". There are answers. They might just require some time to come to understand.
						</p>
					</div>

					<p>
						Now, given the above derivative, we can rearrange the terms (following the rules of matrix algebra) so that we end up with an expression
						for <strong>C</strong>:
					</p>
					<!--
\setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
 
                                                                -1   T   -1  T
                                                           C = M   (𝕋  𝕋)   𝕋  P
-->
					<img
						class="LaTeX SVG"
						src="./images/chapters/curvefitting/9dec10b81a61b456ca1550cd9b7ba513.svg"
						width="168px"
						height="27px"
						loading="lazy"
					/>
					<p>
						Here, the "to the power negative one" is the notation for the
						<a href="https://en.wikipedia.org/wiki/Invertible_matrix">matrix inverse</a>. But that's all we have to do: we're done. Starting with
						<strong>P</strong> and inventing some <code>t</code> values based on the polygon the coordinates in <strong>P</strong> define, we can
						compute the corresponding Bézier coordinates <strong>C</strong> that specify a curve that goes through our points. Or, if it can't go
						through them exactly, as near as possible.
					</p>
					<p>
						So before we try that out, how much code is involved in implementing this? Honestly, that answer depends on how much you're going to be
						writing yourself. If you already have a matrix maths library available, then really not that much code at all. On the other hand, if you
						are writing this from scratch, you're going to have to write some utility functions for doing your matrix work for you, so it's really
						anywhere from 50 lines of code to maybe 200 lines of code. Not a bad price to pay for being able to fit curves to pre-specified
						coordinates.
					</p>
					<p>
						So let's try it out! The following graphic lets you place points, and will start computing exact-fit curves once you've placed at least
						three. You can click for more points, and the code will simply try to compute an exact fit using a Bézier curve of the appropriate order.
						Four points? Cubic Bézier. Five points? Quartic. And so on. Of course, this does break down at some point: depending on where you place
						your points, it might become mighty hard for the fitter to find an exact fit, and things might actually start looking horribly off once
						there's enough points for compound
						<a href="https://en.wikipedia.org/wiki/Round-off_error#Floating-point_number_system">floating point rounding errors</a> to start making a
						difference (which is around 10~11 points).
					</p>
					<graphics-element title="Fitting a Bézier curve" width="550" height="275" src="./chapters/curvefitting/curve-fitting.js">
						<fallback-image>
							<span class="view-source">Scripts are disabled. Showing fallback image.</span>
							<img width="550px" height="275px" src="./images/chapters/curvefitting/798f3d7151dfb2887c7881a08e65cdd3.png" loading="lazy" />
							<label></label>
						</fallback-image>
						<button class="toggle">toggle</button>
						<!-- additional sliders will get created on the fly -->
					</graphics-element>
					<p>
						You'll note there is a convenient "toggle" buttons that lets you toggle between equidistant <code>t</code> values, and distance ratio
						along the polygon formed by the points. Arguably more interesting is that once you have points to abstract a curve, you also get
						<em>direct control</em> over the time values through sliders for each, because if the time values are our degree of freedom, you should be
						able to freely manipulate them and see what the effect on your curve is.
					</p>
				</section>
				<section id="catmullconv">
					<h1>
						<div class="nav"><a href="ja-JP/index.html#curvefitting">previous</a><a href="ja-JP/index.html#catmullfitting">next</a></div>
						<a href="ja-JP/index.html#catmullconv">Bézier curves and Catmull-Rom curves</a>
					</h1>
					<p>
						Taking an excursion to different splines, the other common design curve is the
						<a href="https://en.wikipedia.org/wiki/Cubic_Hermite_spline#Catmull.E2.80.93Rom_spline">Catmull-Rom spline</a>, which unlike Bézier curves
						pass <em>through</em> each control point, so they offer a kind of "built-in" curve fitting.
					</p>
					<p>
						In fact, let's start with just playing with one: the following graphic has a predefined curve that you manipulate the points for, and lets
						you add points by clicking/tapping the background, as well as let you control "how fast" the curve passes through its point using the
						tension slider. The tenser the curve, the more the curve tends towards straight lines from one point to the next.
					</p>
					<graphics-element title="A Catmull-Rom curve" width="275" height="275" src="./chapters/catmullconv/catmull-rom.js">
						<fallback-image>
							<span class="view-source">Scripts are disabled. Showing fallback image.</span>
							<img width="275px" height="275px" src="./images/chapters/catmullconv/aa46749b9469341d9249ca452390d875.png" loading="lazy" />
							<label>A Catmull-Rom curve</label>
						</fallback-image>
						<input type="range" min="0.1" max="1" step="0.01" value="0.5" class="slide-control tension" />
					</graphics-element>
					<p>
						Now, it may look like Catmull-Rom curves are very different from Bézier curves, because these curves can get very long indeed, but what
						looks like a single Catmull-Rom curve is actually a <a href="https://en.wikipedia.org/wiki/Spline_(mathematics)">spline</a>: a single
						curve built up of lots of identically-computed pieces, similar to if you just took a whole bunch of Bézier curves, placed them end to end,
						and lined up their control points so that things look like a single curve. For a Catmull-Rom curve, each "piece" between two points is
						defined by the point's coordinates, and the tangent for those points, the latter of which
						<a href="https://en.wikipedia.org/wiki/Cubic_Hermite_spline#Catmull%E2%80%93Rom_spline">can trivially be derived</a> from knowing the
						previous and next point:
					</p>
					<!--
\setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
 
                                                              ┌  V  = P       ┐
                                                              │   1    2      │
                                               ┌ P  ┐         │  V  = P       │
                                               │  1 │         │   2    3      │
                                               │ P  │         │       P  - P  │
                                               │  2 │       = │        3    1 │             
                                               │ P  │points   │ V'  = ─────── │point-tangent
                                               │  3 │         │   1      2    │
                                               │ P  │         │       P  - P  │
                                               └  4 ┘         │        4    2 │
                                                              │ V'  = ─────── │
                                                              └   2      2    ┘
-->
					<img
						class="LaTeX SVG"
						src="./images/chapters/catmullconv/00357d2a2168fe313cd0b38d95a1a681.svg"
						width="287px"
						height="88px"
						loading="lazy"
					/>
					<p>
						One downside of this is that—as you may have noticed from the graphic—the first and last point of the overall curve don't actually join up
						with the rest of the curve: they don't have a previous/next point respectively, and so there is no way to calculate what their tangent
						should be. Which also makes it rather tricky to fit a Catmull-Rom curve to three points like we were able to do for Bézier curves. More on
						that in <a href="#catmullfitting">the next section</a>.
					</p>
					<p>
						In fact, before we move on, let's look at how to actually draw the basic form of these curves (I say basic, because there are a number of
						variations that make things
						<a href="https://en.wikipedia.org/wiki/Centripetal_Catmull%E2%80%93Rom_spline#Definition">considerable</a> more
						<a href="https://en.wikipedia.org/wiki/Kochanek%E2%80%93Bartels_spline">complex</a>):
					</p>

					<table class="code">
						<tr>
							<td>1</td>
							<td rowspan="19">
								<textarea disabled rows="19" role="doc-example">
tension = some value greater than 0, defaulting to 1
points = a list of at least 4 coordinates

for p = 1 to points.length-3 (inclusive):
       p0 = points[p-1]
  v1 = p1 = points[p]
  v2 = p2 = points[p+1]
       p3 = points[p+2]

  s = 2 * tension
  dv1 = (p2-p0) / s
  dv2 = (p3-p1) / s

  for t = 0 to 1 (inclusive):
    c0 = 2*t^3 - 3*t^2 + 1,
    c1 = t^3 - 2*t^2 + t,
    c2 = -2*t^3 + 3*t^2,
    c3 = t^3 - t^2
    point(c0 * v1 + c1 * dv1 + c2 * v2 + c3 * dv2)</textarea
								>
							</td>
						</tr>
						<tr>
							<td>2</td>
						</tr>
						<tr>
							<td>3</td>
						</tr>
						<tr>
							<td>4</td>
						</tr>
						<tr>
							<td>5</td>
						</tr>
						<tr>
							<td>6</td>
						</tr>
						<tr>
							<td>7</td>
						</tr>
						<tr>
							<td>8</td>
						</tr>
						<tr>
							<td>9</td>
						</tr>
						<tr>
							<td>10</td>
						</tr>
						<tr>
							<td>11</td>
						</tr>
						<tr>
							<td>12</td>
						</tr>
						<tr>
							<td>13</td>
						</tr>
						<tr>
							<td>14</td>
						</tr>
						<tr>
							<td>15</td>
						</tr>
						<tr>
							<td>16</td>
						</tr>
						<tr>
							<td>17</td>
						</tr>
						<tr>
							<td>18</td>
						</tr>
						<tr>
							<td>19</td>
						</tr>
					</table>

					<p>
						Now, since a Catmull-Rom curve is a form of <a href="https://en.wikipedia.org/wiki/Cubic_Hermite_spline">cubic Hermite spline</a>, and as
						cubic Bézier curves are <em>also</em> a form of cubic Hermite spline, we run into an interesting bit of maths programming: we can convert
						one to the other and back, and the maths for doing so is surprisingly simple!
					</p>
					<p>The main difference between Catmull-Rom curves and Bézier curves is "what the points mean":</p>
					<ul>
						<li>
							A cubic Bézier curve is defined by a start point, a control point that implies the tangent at the start, a control point that implies
							the tangent at the end, and an end point, plus a characterizing matrix that we can multiply by that point vector to get on-curve
							coordinates.
						</li>
						<li>
							A Catmull-Rom curve is defined by a start point, a tangent that for that starting point, an end point, and a tangent for that end point,
							plus a characteristic matrix that we can multiple by the point vector to get on-curve coordinates.
						</li>
					</ul>
					<p>
						Those are <em>very</em> similar, so let's see exactly <em>how</em> similar they are. We've already see the matrix form for Bézier curves,
						so how different is the matrix form for Catmull-Rom curves?:
					</p>
					<!--
\setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
 
                                                                                            ┌ V   ┐
                                                                                            │  1  │
                                                                         ┌  1  0  0 0  ┐    │ V   │
                                        CatmullRom(t) = ┌      2  3 ┐  · │  0  0  1 0  │  · │  2  │
                                                        └ 1 t t  t  ┘    │ -3  3 -2 -1 │    │ V'  │
                                                                         └  2 -2  1 1  ┘    │   1 │
                                                                                            │ V'  │
                                                                                            └   2 ┘
-->
					<img
						class="LaTeX SVG"
						src="./images/chapters/catmullconv/8d3a5ca7188f53b914229133b3dbe5fe.svg"
						width="409px"
						height="75px"
						loading="lazy"
					/>
					<p>
						That's pretty dang similar. So the question is: how can we convert that expression with Catmull-Rom matrix and vector into an expression
						of the Bézier matrix and vector? The short answer is of course "by using linear algebra", but the longer answer is the rest of this
						section, and involves some maths that you may not even care for: if you just want to know the (incredibly simple) conversions between the
						two curve forms, feel free to skip to the end of the following explanation, but if you want to <em>how</em> we can get one from the
						other... let's get mathing!
					</p>
					<div class="note">
						<h2>Deriving the conversion formulae</h2>
						<p>
							In order to convert between Catmull-Rom curves and Bézier curves, we need to know two things. Firstly, how to express the Catmull-Rom
							curve using a "set of four coordinates", rather than a mix of coordinates and tangents, and secondly, how to convert those Catmull-Rom
							coordinates to and from Bézier form.
						</p>
						<p>
							We start with the first part, to figure out how we can go from Catmull-Rom <strong>V</strong> coordinates to Bézier
							<strong>P</strong> coordinates, by applying "some matrix <strong>T</strong>". We don't know what that <strong>T</strong> is yet, but
							we'll get to that:
						</p>
						<!--
\setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
 
                                                                            ┌   P     ┐
                                                                            │    2    │
                                                    ┌ V   ┐        ┌ P  ┐   │   P     │
                                                    │  1  │        │  1 │   │    3    │
                                                    │ V   │        │ P  │   │ P  - P  │
                                                    │  2  │ = T  · │  2 │ = │  3    1 │
                                                    │ V'  │        │ P  │   │ ─────── │
                                                    │   1 │        │  3 │   │    2    │
                                                    │ V'  │        │ P  │   │ P  - P  │
                                                    └   2 ┘        └  4 ┘   │  4    2 │
                                                                            │ ─────── │
                                                                            └    2    ┘
-->
						<img
							class="LaTeX SVG"
							src="./images/chapters/catmullconv/b94a4dafc12ba7e4fbf3aff924f55464.svg"
							width="187px"
							height="83px"
							loading="lazy"
						/>
						<p>
							So, this mapping says that in order to map a Catmull-Rom "point + tangent" vector to something based on an "all coordinates" vector, we
							need to determine the mapping matrix such that applying <em>T</em> yields P2 as start point, P3 as end point, and two tangents based on
							the lines between P1 and P3, and P2 nd P4, respectively.
						</p>
						<p>Computing <em>T</em> is really more "arranging the numbers":</p>
						<!--
\setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
 
                                    ┌   P     ┐
                                    │    2    │
                           ┌ P  ┐   │   P     │   ┌  0  · P1 + 1  · P2 + 0  · P3 + 0  · P4 ┐   ┌  0  1 0 0 ┐    ┌ P  ┐
                           │  1 │   │    3    │   │  0  · P1 + 0  · P2 + 1  · P3 + 0  · P4 │   │  0  0 1 0 │    │  1 │
                           │ P  │   │ P  - P  │   │ -1                   1                 │   │ -1    1   │    │ P  │
                      T  · │  2 │ = │  3    1 │ = │ ──  · P1 + 0  · P2 + ─  · P3 + 0  · P4 │ = │ ──  0 ─ 0 │  · │  2 │
                           │ P  │   │ ─────── │   │ 2                    2                 │   │ 2     2   │    │ P  │
                           │  3 │   │    2    │   │           -1                   1       │   │    -1   1 │    │  3 │
                           │ P  │   │ P  - P  │   │  0  · P1  ──  · P2 + 0  · P3 + ─  · P4 │   │  0 ── 0 ─ │    │ P  │
                           └  4 ┘   │  4    2 │   └           2                    2       ┘   └    2    2 ┘    └  4 ┘
                                    │ ─────── │
                                    └    2    ┘
-->
						<img
							class="LaTeX SVG"
							src="./images/chapters/catmullconv/a55773fdcdfd99947acc4f86ad2d4a3d.svg"
							width="591px"
							height="83px"
							loading="lazy"
						/>
						<p>Thus:</p>
						<!--
\setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
 
                                                                 ┌  0  1 0 0 ┐
                                                                 │  0  0 1 0 │
                                                                 │ -1    1   │
                                                             T = │ ──  0 ─ 0 │
                                                                 │ 2     2   │
                                                                 │    -1   1 │
                                                                 │  0 ── 0 ─ │
                                                                 └    2    2 ┘
-->
						<img
							class="LaTeX SVG"
							src="./images/chapters/catmullconv/7bab9dd3da654b05fa065076894e2d82.svg"
							width="143px"
							height="81px"
							loading="lazy"
						/>
						<p>
							However, we're not <em>quite</em> done, because Catmull-Rom curves have that "tension" parameter, written as τ (a lowercase"tau"), which
							is a scaling factor for the tangent vectors: the bigger the tension, the smaller the tangents, and the smaller the tension, the bigger
							the tangents. As such, the tension factor goes in the denominator for the tangents, and before we continue, let's add that tension
							factor into both our coordinate vector representation, and mapping matrix <em>T</em>:
						</p>
						<!--
\setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
 
                                                          ┌   P     ┐
                                                          │    2    │
                                                ┌ V   ┐   │   P     │        ┌  0  1  0 0  ┐
                                                │  1  │   │    3    │        │  0  0  1 0  │
                                                │ V   │   │ P  - P  │        │ -1    1     │
                                                │  2  │ = │  3    1 │ ,\ T = │ ──  0 ── 0  │
                                                │ V'  │   │ ─────── │        │ 2τ    2τ    │
                                                │   1 │   │   2τ    │        │    -1    1  │
                                                │ V'  │   │ P  - P  │        │  0 ──  0 ── │
                                                └   2 ┘   │  4    2 │        └    2τ    2τ ┘
                                                          │ ─────── │
                                                          └   2τ    ┘
-->
						<img
							class="LaTeX SVG"
							src="./images/chapters/catmullconv/8de53f207d68b25854a5f0b924ac6010.svg"
							width="285px"
							height="84px"
							loading="lazy"
						/>
						<p>
							With the mapping matrix properly done, let's rewrite the "point + tangent" Catmull-Rom matrix form to a matrix form in terms of four
							coordinates, and see what we end up with:
						</p>
						<!--
\setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
 
                                                                                            ┌ V   ┐
                                                                                            │  1  │
                                                                         ┌  1  0  0 0  ┐    │ V   │
                                        CatmullRom(t) = ┌      2  3 ┐  · │  0  0  1 0  │  · │  2  │
                                                        └ 1 t t  t  ┘    │ -3  3 -2 -1 │    │ V'  │
                                                                         └  2 -2  1 1  ┘    │   1 │
                                                                                            │ V'  │
                                                                                            └   2 ┘
-->
						<img
							class="LaTeX SVG"
							src="./images/chapters/catmullconv/1f9fc156aeed9eb092573cd7446593d9.svg"
							width="409px"
							height="75px"
							loading="lazy"
						/>
						<p>Replace point/tangent vector with the expression for all-coordinates:</p>
						<!--
\setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
 
                                                                                   ┌  0  1  0 0  ┐    ┌ P  ┐
                                                                                   │  0  0  1 0  │    │  1 │
                                                                ┌  1  0  0 0  ┐    │ -1    1     │    │ P  │
                               CatmullRom(t) = ┌      2  3 ┐  · │  0  0  1 0  │  · │ ──  0 ── 0  │  · │  2 │
                                               └ 1 t t  t  ┘    │ -3  3 -2 -1 │    │ 2τ    2τ    │    │ P  │
                                                                └  2 -2  1 1  ┘    │    -1    1  │    │  3 │
                                                                                   │  0 ──  0 ── │    │ P  │
                                                                                   └    2τ    2τ ┘    └  4 ┘
-->
						<img
							class="LaTeX SVG"
							src="./images/chapters/catmullconv/defc6fa4b51fa3c1945d15449f0f392d.svg"
							width="549px"
							height="81px"
							loading="lazy"
						/>
						<p>and merge the matrices:</p>
						<!--
\setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
 
                                                                      ┌  0    1      0   0  ┐
                                                                      │ -1          1       │    ┌ P  ┐
                                                                      │ ──    0     ──   0  │    │  1 │
                                                                      │ 2τ          2τ      │    │ P  │
                                     CatmullRom(t) = ┌      2  3 ┐  · │  1 1           1 -1 │  · │  2 │
                                                     └ 1 t t  t  ┘    │  ─ ── - 3  3 - ─ ── │    │ P  │
                                                                      │  τ 2t          t 2t │    │  3 │
                                                                      │ -1     1  1      1  │    │ P  │
                                                                      │ ── 2 - ── ── - 2 ── │    └  4 ┘
                                                                      └ 2t     2τ 2τ     2t ┘
-->
						<img
							class="LaTeX SVG"
							src="./images/chapters/catmullconv/8a2a00812363fe1a6cfa7f81b48d31d1.svg"
							width="455px"
							height="84px"
							loading="lazy"
						/>
						<p>This looks a lot like the Bézier matrix form, which as we saw in the chapter on Bézier curves, should look like this:</p>
						<!--
\setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
 
                                                                                           ┌ P  ┐
                                                                                           │  1 │
                                                                         ┌  1  0  0 0 ┐    │ P  │
                                            Bézier(t) = ┌      2  3 ┐  · │ -3  3  0 0 │  · │  2 │
                                                        └ 1 t t  t  ┘    │  3 -6  3 0 │    │ P  │
                                                                         └ -1  3 -3 1 ┘    │  3 │
                                                                                           │ P  │
                                                                                           └  4 ┘
-->
						<img
							class="LaTeX SVG"
							src="./images/chapters/catmullconv/c1f8861583b4176a9b607aa6a05f9356.svg"
							width="353px"
							height="73px"
							loading="lazy"
						/>
						<p>So, if we want to express a Catmull-Rom curve using a Bézier curve, we'll need to turn this Catmull-Rom bit:</p>
						<!--
\setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
 
                                                     ┌  0    1      0   0  ┐
                                                     │ -1          1       │    ┌ P  ┐
                                                     │ ──    0     ──   0  │    │  1 │
                                                     │ 2τ          2τ      │    │ P  │
                                                     │  1 1           1 -1 │  · │  2 │
                                                     │  ─ ── - 3  3 - ─ ── │    │ P  │
                                                     │  τ 2t          t 2t │    │  3 │
                                                     │ -1     1  1      1  │    │ P  │
                                                     │ ── 2 - ── ── - 2 ── │    └  4 ┘
                                                     └ 2t     2τ 2τ     2t ┘
-->
						<img
							class="LaTeX SVG"
							src="./images/chapters/catmullconv/574bed6665be06b309b8da722c616a41.svg"
							width="227px"
							height="84px"
							loading="lazy"
						/>
						<p>Into something that looks like this:</p>
						<!--
\setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
 
                                                                            ┌ P  ┐
                                                                            │  1 │
                                                          ┌  1  0  0 0 ┐    │ P  │
                                                          │ -3  3  0 0 │  · │  2 │
                                                          │  3 -6  3 0 │    │ P  │
                                                          └ -1  3 -3 1 ┘    │  3 │
                                                                            │ P  │
                                                                            └  4 ┘
-->
						<img
							class="LaTeX SVG"
							src="./images/chapters/catmullconv/fe2e6fd487df224b2f55a601898ce333.svg"
							width="167px"
							height="73px"
							loading="lazy"
						/>
						<p>And the way we do that is with a fairly straight forward bit of matrix rewriting. We start with the equality we need to ensure:</p>
						<!--
\setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
 
                                     ┌  0    1      0   0  ┐
                                     │ -1          1       │    ┌ P  ┐                          ┌ P  ┐
                                     │ ──    0     ──   0  │    │  1 │                          │  1 │
                                     │ 2τ          2τ      │    │ P  │   ┌  1  0  0 0 ┐         │ P  │
                                     │  1 1           1 -1 │  · │  2 │ = │ -3  3  0 0 │  · V  · │  2 │
                                     │  ─ ── - 3  3 - ─ ── │    │ P  │   │  3 -6  3 0 │         │ P  │
                                     │  τ 2t          t 2t │    │  3 │   └ -1  3 -3 1 ┘         │  3 │
                                     │ -1     1  1      1  │    │ P  │                          │ P  │
                                     │ ── 2 - ── ── - 2 ── │    └  4 ┘                          └  4 ┘
                                     └ 2t     2τ 2τ     2t ┘
-->
						<img
							class="LaTeX SVG"
							src="./images/chapters/catmullconv/b59ff8d654e65df4c874901983208893.svg"
							width="440px"
							height="84px"
							loading="lazy"
						/>
						<p>Then we remove the coordinate vector from both sides without affecting the equality:</p>
						<!--
\setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
 
                                               ┌  0    1      0   0  ┐
                                               │ -1          1       │
                                               │ ──    0     ──   0  │
                                               │ 2τ          2τ      │   ┌  1  0  0 0 ┐
                                               │  1 1           1 -1 │ = │ -3  3  0 0 │  · V
                                               │  ─ ── - 3  3 - ─ ── │   │  3 -6  3 0 │
                                               │  τ 2t          t 2t │   └ -1  3 -3 1 ┘
                                               │ -1     1  1      1  │
                                               │ ── 2 - ── ── - 2 ── │
                                               └ 2t     2τ 2τ     2t ┘
-->
						<img
							class="LaTeX SVG"
							src="./images/chapters/catmullconv/65e589eafae8ff2f39392d8143d2845c.svg"
							width="353px"
							height="84px"
							loading="lazy"
						/>
						<p>Then we can "get rid of" the Bézier matrix on the right by left-multiply both with the inverse of the Bézier matrix:</p>
						<!--
\setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
 
                                               ┌  0    1      0   0  ┐
                                               │ -1          1       │
                                               │ ──    0     ──   0  │
                          ┌  1  0  0 0 ┐ -1    │ 2τ          2τ      │    ┌  1  0  0 0 ┐ -1    ┌  1  0  0 0 ┐
                          │ -3  3  0 0 │     · │  1 1           1 -1 │ =  │ -3  3  0 0 │     · │ -3  3  0 0 │  · V
                          │  3 -6  3 0 │       │  ─ ── - 3  3 - ─ ── │    │  3 -6  3 0 │       │  3 -6  3 0 │
                          └ -1  3 -3 1 ┘       │  τ 2t          t 2t │    └ -1  3 -3 1 ┘       └ -1  3 -3 1 ┘
                                               │ -1     1  1      1  │
                                               │ ── 2 - ── ── - 2 ── │
                                               └ 2t     2τ 2τ     2t ┘
-->
						<img
							class="LaTeX SVG"
							src="./images/chapters/catmullconv/917b176a45959b026c56f81999505dc7.svg"
							width="657px"
							height="88px"
							loading="lazy"
						/>
						<p>
							A matrix times its inverse is the matrix equivalent of 1, and because "something times 1" is the same as "something", so we can just
							outright remove any matrix/inverse pair:
						</p>
						<!--
\setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
 
                                                                   ┌  0    1      0   0  ┐
                                                                   │ -1          1       │
                                                                   │ ──    0     ──   0  │
                                              ┌  1  0  0 0 ┐ -1    │ 2τ          2τ      │
                                              │ -3  3  0 0 │     · │  1 1           1 -1 │ = V
                                              │  3 -6  3 0 │       │  ─ ── - 3  3 - ─ ── │
                                              └ -1  3 -3 1 ┘       │  τ 2t          t 2t │
                                                                   │ -1     1  1      1  │
                                                                   │ ── 2 - ── ── - 2 ── │
                                                                   └ 2t     2τ 2τ     2t ┘
-->
						<img
							class="LaTeX SVG"
							src="./images/chapters/catmullconv/4e0da16710a7339f04dd844c7705423e.svg"
							width="369px"
							height="88px"
							loading="lazy"
						/>
						<p>And now we're <em>basically</em> done. We just multiply those two matrices and we know what <em>V</em> is:</p>
						<!--
\setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
 
                                                            ┌  0  1  0 0  ┐
                                                            │ -1    1     │
                                                            │ ──  1 ── 0  │
                                                            │ 6τ    6τ    │ = V
                                                            │    1     -1 │
                                                            │  0 ──  1 ── │
                                                            │    6τ    6τ │
                                                            └  0  0  1 0  ┘
-->
						<img
							class="LaTeX SVG"
							src="./images/chapters/catmullconv/1cef6bbf7b3d10e8c0aaecfac816cc86.svg"
							width="161px"
							height="77px"
							loading="lazy"
						/>
						<p>We now have the final piece of our function puzzle. Let's run through each step.</p>
						<ol>
							<li>Start with the Catmull-Rom function:</li>
						</ol>
						<!--
\setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
 
                                                                                            ┌ V   ┐
                                                                                            │  1  │
                                                                         ┌  1  0  0 0  ┐    │ V   │
                                        CatmullRom(t) = ┌      2  3 ┐  · │  0  0  1 0  │  · │  2  │
                                                        └ 1 t t  t  ┘    │ -3  3 -2 -1 │    │ V'  │
                                                                         └  2 -2  1 1  ┘    │   1 │
                                                                                            │ V'  │
                                                                                            └   2 ┘
-->
						<img
							class="LaTeX SVG"
							src="./images/chapters/catmullconv/1f9fc156aeed9eb092573cd7446593d9.svg"
							width="409px"
							height="75px"
							loading="lazy"
						/>
						<ol start="2">
							<li>rewrite to pure coordinate form:</li>
						</ol>
						<!--
\setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
 
                                                                                   ┌   P     ┐
                                                                                   │    2    │
                                                                                   │   P     │
                                                                                   │    3    │
                                                                ┌  1  0  0 0  ┐    │ P  - P  │
                                             = ┌      2  3 ┐  · │  0  0  1 0  │  · │  3    1 │
                                               └ 1 t t  t  ┘    │ -3  3 -2 -1 │    │ ─────── │
                                                                └  2 -2  1 1  ┘    │   2τ    │
                                                                                   │ P  - P  │
                                                                                   │  4    2 │
                                                                                   │ ─────── │
                                                                                   └   2τ    ┘
-->
						<img
							class="LaTeX SVG"
							src="./images/chapters/catmullconv/211dadbb9d0f6b2e381f18ea3c4d12fb.svg"
							width="324px"
							height="84px"
							loading="lazy"
						/>
						<ol start="3">
							<li>rewrite for "normal" coordinate vector:</li>
						</ol>
						<!--
\setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
 
                                                                            ┌  0  1  0 0  ┐    ┌ P  ┐
                                                                            │  0  0  1 0  │    │  1 │
                                                         ┌  1  0  0 0  ┐    │ -1    1     │    │ P  │
                                      = ┌      2  3 ┐  · │  0  0  1 0  │  · │ ──  0 ── 0  │  · │  2 │
                                        └ 1 t t  t  ┘    │ -3  3 -2 -1 │    │ 2τ    2τ    │    │ P  │
                                                         └  2 -2  1 1  ┘    │    -1    1  │    │  3 │
                                                                            │  0 ──  0 ── │    │ P  │
                                                                            └    2τ    2τ ┘    └  4 ┘
-->
						<img
							class="LaTeX SVG"
							src="./images/chapters/catmullconv/a8158b35ec221cccff51a53cdc7f440b.svg"
							width="441px"
							height="81px"
							loading="lazy"
						/>
						<ol start="4">
							<li>merge the inner matrices:</li>
						</ol>
						<!--
\setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
 
                                                               ┌  0    1      0   0  ┐
                                                               │ -1          1       │    ┌ P  ┐
                                                               │ ──    0     ──   0  │    │  1 │
                                                               │ 2τ          2τ      │    │ P  │
                                            = ┌      2  3 ┐  · │  1 1           1 -1 │  · │  2 │
                                              └ 1 t t  t  ┘    │  ─ ── - 3  3 - ─ ── │    │ P  │
                                                               │  τ 2t          t 2t │    │  3 │
                                                               │ -1     1  1      1  │    │ P  │
                                                               │ ── 2 - ── ── - 2 ── │    └  4 ┘
                                                               └ 2t     2τ 2τ     2t ┘
-->
						<img
							class="LaTeX SVG"
							src="./images/chapters/catmullconv/53f216327c0bbcf02b2a331fbf44d389.svg"
							width="348px"
							height="84px"
							loading="lazy"
						/>
						<ol start="5">
							<li>rewrite for Bézier matrix form:</li>
						</ol>
						<!--
\setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
 
                                                                            ┌  0  1  0 0  ┐    ┌ P  ┐
                                                                            │ -1    1     │    │  1 │
                                                          ┌  1  0  0 0 ┐    │ ──  1 ── 0  │    │ P  │
                                       = ┌      2  3 ┐  · │ -3  3  0 0 │  · │ 6τ    6τ    │  · │  2 │
                                         └ 1 t t  t  ┘    │  3 -6  3 0 │    │    1     -1 │    │ P  │
                                                          └ -1  3 -3 1 ┘    │  0 ──  1 ── │    │  3 │
                                                                            │    6τ    6τ │    │ P  │
                                                                            └  0  0  1 0  ┘    └  4 ┘
-->
						<img
							class="LaTeX SVG"
							src="./images/chapters/catmullconv/4c8684109149b0dc79f5583a5912fcd9.svg"
							width="431px"
							height="77px"
							loading="lazy"
						/>
						<ol start="6">
							<li>and transform the coordinates so we have a "pure" Bézier expression:</li>
						</ol>
						<!--
\setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
 
                                                                                 ┌     P       ┐
                                                                                 │      2      │
                                                                                 │      P -P   │
                                                                                 │       3  1  │
                                                               ┌  1  0  0 0 ┐    │ P  + ────── │
                                            = ┌      2  3 ┐  · │ -3  3  0 0 │  · │  2   6  · τ │
                                              └ 1 t t  t  ┘    │  3 -6  3 0 │    │      P -P   │
                                                               └ -1  3 -3 1 ┘    │       4  2  │
                                                                                 │ P  - ────── │
                                                                                 │  3   6  · τ │
                                                                                 │     P       │
                                                                                 └      3      ┘
-->
						<img
							class="LaTeX SVG"
							src="./images/chapters/catmullconv/157b287d6b74109d8c8b634990ea6549.svg"
							width="348px"
							height="81px"
							loading="lazy"
						/>
						<p>And we're done: we finally know how to convert these two curves!</p>
					</div>

					<p>
						If we have a Catmull-Rom curve defined by four coordinates P<sub>1</sub> through P<sub>4</sub>, then we can draw that curve using a Bézier
						curve that has the vector:
					</p>
					<!--
\setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
 
                                                                         ┌     P       ┐
                                                                         │      2      │
                                            ┌ P  ┐                       │      P -P   │
                                            │  1 │                       │       3  1  │
                                            │ P  │                       │ P  + ────── │
                                            │  2 │           \Rightarrow │  2   6  · τ │       
                                            │ P  │CatmullRom             │      P -P   │ Bézier
                                            │  3 │                       │       4  2  │
                                            │ P  │                       │ P  - ────── │
                                            └  4 ┘                       │  3   6  · τ │
                                                                         │     P       │
                                                                         └      3      ┘
-->
					<img
						class="LaTeX SVG"
						src="./images/chapters/catmullconv/c0e30b49fbfce6f6b3c81eaa6ca5154f.svg"
						width="249px"
						height="85px"
						loading="lazy"
					/>
					<p>
						Similarly, if we have a Bézier curve defined by four coordinates P<sub>1</sub> through P<sub>4</sub>, we can draw that using a standard
						tension Catmull-Rom curve with the following coordinate values:
					</p>
					<!--
\setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
 
                                          ┌ P  ┐                    ┌       P         ┐
                                          │  1 │                    │        1        │
                                          │ P  │                    │       P         │
                                          │  2 │        \Rightarrow │        4        │          
                                          │ P  │ Bézier             │ P  + 3(P  - P ) │CatmullRom
                                          │  3 │                    │  4      1    2  │
                                          │ P  │                    │ P  + 3(P  - P ) │
                                          └  4 ┘                    └  1      4    3  ┘
-->
					<img
						class="LaTeX SVG"
						src="./images/chapters/catmullconv/d09e7466c267614c89ead28d6a900ba1.svg"
						width="284px"
						height="77px"
						loading="lazy"
					/>
					<p>Or, if your API allows you to specify Catmull-Rom curves using plain coordinates:</p>
					<!--
\setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
 
                                          ┌ P  ┐                    ┌ P  + 6(P  - P ) ┐
                                          │  1 │                    │  4      1    2  │
                                          │ P  │                    │       P         │
                                          │  2 │        \Rightarrow │        1        │          
                                          │ P  │ Bézier             │       P         │CatmullRom
                                          │  3 │                    │        4        │
                                          │ P  │                    │ P  + 6(P  - P ) │
                                          └  4 ┘                    └  1      4    3  ┘
-->
					<img
						class="LaTeX SVG"
						src="./images/chapters/catmullconv/9593c057c84ebf9beb70fd57a11c7e12.svg"
						width="284px"
						height="77px"
						loading="lazy"
					/>
				</section>
				<section id="catmullfitting">
					<h1>
						<div class="nav"><a href="ja-JP/index.html#catmullconv">previous</a><a href="ja-JP/index.html#polybezier">next</a></div>
						<a href="ja-JP/index.html#catmullfitting">Creating a Catmull-Rom curve from three points</a>
					</h1>
					<p>
						Much shorter than the previous section: we saw that Catmull-Rom curves need at least 4 points to draw anything sensible, so how do we
						create a Catmull-Rom curve from three points?
					</p>
					<p>Short and sweet: we don't.</p>
					<p>
						We run through the maths that lets us <a href="#pointcurves">create a cubic Bézier curve</a>, and then convert its coordinates to
						Catmull-Rom form using the conversion formulae we saw above.
					</p>
				</section>
				<section id="polybezier">
					<h1>
						<div class="nav"><a href="ja-JP/index.html#catmullfitting">previous</a><a href="ja-JP/index.html#offsetting">next</a></div>
						<a href="ja-JP/index.html#polybezier">Forming poly-Bézier curves</a>
					</h1>
					<p>
						Much like lines can be chained together to form polygons, Bézier curves can be chained together to form poly-Béziers, and the only trick
						required is to make sure that:
					</p>
					<ol>
						<li>the end point of each section is the starting point of the following section, and</li>
						<li>the derivatives across that dual point line up.</li>
					</ol>
					<p>Unless you want sharp corners, of course. Then you don't even need 2.</p>
					<p>
						We'll cover three forms of poly-Bézier curves in this section. First, we'll look at the kind that just follows point 1. where the end
						point of a segment is the same point as the start point of the next segment. This leads to poly-Béziers that are pretty hard to work with,
						but they're the easiest to implement:
					</p>
					<graphics-element
						title="Unlinked quadratic poly-Bézier"
						width="275"
						height="275"
						src="./chapters/polybezier/poly.js"
						data-type="quadratic"
						data-link="coordinate"
					>
						<fallback-image>
							<span class="view-source">Scripts are disabled. Showing fallback image.</span>
							<img width="275px" height="275px" src="./images/chapters/polybezier/41522a397171423e8a465dc8c74f6e87.png" loading="lazy" />
							<label>Unlinked quadratic poly-Bézier</label>
						</fallback-image></graphics-element
					>
					<graphics-element
						title="Unlinked cubic poly-Bézier"
						width="275"
						height="275"
						src="./chapters/polybezier/poly.js"
						data-type="cubic"
						data-link="coordinate"
					>
						<fallback-image>
							<span class="view-source">Scripts are disabled. Showing fallback image.</span>
							<img width="275px" height="275px" src="./images/chapters/polybezier/6fb33629373d7a731b6ac3f5365cb9f0.png" loading="lazy" />
							<label>Unlinked cubic poly-Bézier</label>
						</fallback-image></graphics-element
					>
					<p>
						Dragging the control points around only affects the curve segments that the control point belongs to, and moving an on-curve point leaves
						the control points where they are, which is not the most useful for practical modelling purposes. So, let's add in the logic we need to
						make things a little better. We'll start by linking up control points by ensuring that the "incoming" derivative at an on-curve point is
						the same as it's "outgoing" derivative:
					</p>
					<!--
\setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
 
                                                             B'(1)  = B'(0)   
                                                                  n        n+1
-->
					<img class="LaTeX SVG" src="./images/chapters/polybezier/a37252ff55837b918d9d64078ae92ae7.svg" width="124px" height="17px" loading="lazy" />
					<p>
						We can effect this quite easily, because we know that the vector from a curve's last control point to its last on-curve point is equal to
						the derivative vector. If we want to ensure that the first control point of the next curve matches that, all we have to do is mirror that
						last control point through the last on-curve point. And mirroring any point A through any point B is really simple:
					</p>
					<!--
\setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
 
                                                           ┌ B  + (B  - A ) ┐   ┌ 2B  - A  ┐
                                                Mirrored = │  x     x    x  │ = │   x    x │
                                                           │ B  + (B  - A ) │   │ 2B  - A  │
                                                           └  y     y    y  ┘   └   y    y ┘
-->
					<img class="LaTeX SVG" src="./images/chapters/polybezier/ec93d3c42f0ae52a05d0aff9739675e5.svg" width="304px" height="40px" loading="lazy" />
					<p>
						So let's implement that and see what it gets us. The following two graphics show a quadratic and a cubic poly-Bézier curve again, but this
						time moving the control points around moves others, too. However, you might see something unexpected going on for quadratic curves...
					</p>
					<graphics-element
						title="Connected quadratic poly-Bézier"
						width="275"
						height="275"
						src="./chapters/polybezier/poly.js"
						data-type="quadratic"
						data-link="derivative"
					>
						<fallback-image>
							<span class="view-source">Scripts are disabled. Showing fallback image.</span>
							<img width="275px" height="275px" src="./images/chapters/polybezier/db04f805f42bdc9a1b7ec4d6b401d853.png" loading="lazy" />
							<label>Connected quadratic poly-Bézier</label>
						</fallback-image></graphics-element
					>
					<graphics-element
						title="Connected cubic poly-Bézier"
						width="275"
						height="275"
						src="./chapters/polybezier/poly.js"
						data-type="cubic"
						data-link="derivative"
					>
						<fallback-image>
							<span class="view-source">Scripts are disabled. Showing fallback image.</span>
							<img width="275px" height="275px" src="./images/chapters/polybezier/fe41b628f46f7035d151a8210d30111f.png" loading="lazy" />
							<label>Connected cubic poly-Bézier</label>
						</fallback-image></graphics-element
					>
					<p>
						As you can see, quadratic curves are particularly ill-suited for poly-Bézier curves, as all the control points are effectively linked.
						Move one of them, and you move all of them. Not only that, but if we move the on-curve points, it's possible to get a situation where a
						control point cannot satisfy the constraint that it's the reflection of its two neighbouring control points... This means that we cannot
						use quadratic poly-Béziers for anything other than really, really simple shapes. And even then, they're probably the wrong choice. Cubic
						curves are pretty decent, but the fact that the derivatives are linked means we can't manipulate curves as well as we might if we relaxed
						the constraints a little.
					</p>
					<p>So: let's relax the requirement a little.</p>
					<p>
						We can change the constraint so that we still preserve the <em>angle</em> of the derivatives across sections (so transitions from one
						section to the next will still look natural), but give up the requirement that they should also have the same <em>vector length</em>.
						Doing so will give us a much more useful kind of poly-Bézier curve:
					</p>
					<graphics-element
						title="Angularly connected quadratic poly-Bézier"
						width="275"
						height="275"
						src="./chapters/polybezier/poly.js"
						data-type="quadratic"
						data-link="direction"
					>
						<fallback-image>
							<span class="view-source">Scripts are disabled. Showing fallback image.</span>
							<img width="275px" height="275px" src="./images/chapters/polybezier/777f3814965c39ec3cdbb13eab0c4eeb.png" loading="lazy" />
							<label>Angularly connected quadratic poly-Bézier</label>
						</fallback-image></graphics-element
					>
					<graphics-element
						title="Angularly connected cubic poly-Bézier"
						width="275"
						height="275"
						src="./chapters/polybezier/poly.js"
						data-type="cubic"
						data-link="direction"
					>
						<fallback-image>
							<span class="view-source">Scripts are disabled. Showing fallback image.</span>
							<img width="275px" height="275px" src="./images/chapters/polybezier/f6c55cbc66333b6630939f67fc20e086.png" loading="lazy" />
							<label>Angularly connected cubic poly-Bézier</label>
						</fallback-image></graphics-element
					>
					<p>
						Cubic curves are now better behaved when it comes to dragging control points around, but the quadratic poly-Bézier still has the problem
						that moving one control points will move the control points and may ending up defining "the next" control point in a way that doesn't
						work. Quadratic curves really aren't very useful to work with...
					</p>
					<p>
						Finally, we also want to make sure that moving the on-curve coordinates preserves the relative positions of the associated control points.
						With that, we get to the kind of curve control that you might be familiar with from applications like Photoshop, Inkscape, Blender, etc.
					</p>
					<graphics-element
						title="Standard connected quadratic poly-Bézier"
						width="275"
						height="275"
						src="./chapters/polybezier/poly.js"
						data-type="quadratic"
						data-link="conventional"
					>
						<fallback-image>
							<span class="view-source">Scripts are disabled. Showing fallback image.</span>
							<img width="275px" height="275px" src="./images/chapters/polybezier/b3aebf7803f4430187c249a891095062.png" loading="lazy" />
							<label>Standard connected quadratic poly-Bézier</label>
						</fallback-image></graphics-element
					>
					<graphics-element
						title="Standard connected cubic poly-Bézier"
						width="275"
						height="275"
						src="./chapters/polybezier/poly.js"
						data-type="cubic"
						data-link="conventional"
					>
						<fallback-image>
							<span class="view-source">Scripts are disabled. Showing fallback image.</span>
							<img width="275px" height="275px" src="./images/chapters/polybezier/1b94c6ada011bd8e50330e31a851a62e.png" loading="lazy" />
							<label>Standard connected cubic poly-Bézier</label>
						</fallback-image></graphics-element
					>
					<p>
						Again, we see that cubic curves are now rather nice to work with, but quadratic curves have a new, very serious problem: we can move an
						on-curve point in such a way that we can't compute what needs to "happen next". Move the top point down, below the left and right points,
						for instance. There is no way to preserve correct control points without a kink at the bottom point. Quadratic curves: just not that
						good...
					</p>
					<p>
						A final improvement is to offer fine-level control over which points behave which, so that you can have "kinks" or individually controlled
						segments when you need them, with nicely well-behaved curves for the rest of the path. Implementing that, is left as an exercise for the
						reader.
					</p>
				</section>
				<section id="offsetting">
					<h1>
						<div class="nav"><a href="ja-JP/index.html#polybezier">previous</a><a href="ja-JP/index.html#graduatedoffset">next</a></div>
						<a href="ja-JP/index.html#offsetting">Curve offsetting</a>
					</h1>
					<p>
						Perhaps you're like me, and you've been writing various small programs that use Bézier curves in some way or another, and at some point
						you make the step to implementing path extrusion. But you don't want to do it pixel based; you want to stay in the vector world. You find
						that extruding lines is relatively easy, and tracing outlines is coming along nicely (although junction caps and fillets are a bit of a
						hassle), and then you decide to do things properly and add Bézier curves to the mix. Now you have a problem.
					</p>
					<p>
						Unlike lines, you can't simply extrude a Bézier curve by taking a copy and moving it around, because of the curvatures; rather than a
						uniform thickness, you get an extrusion that looks too thin in places, if you're lucky, but more likely will self-intersect. The trick,
						then, is to scale the curve, rather than simply copying it. But how do you scale a Bézier curve?
					</p>
					<p>
						Bottom line: <strong>you can't</strong>. So you cheat. We're not going to do true curve scaling, or rather curve offsetting, because
						that's impossible. Instead we're going to try to generate 'looks good enough' offset curves.
					</p>
					<div class="note">
						<h3>"What do you mean, you can't? Prove it."</h3>
						<p>
							First off, when I say "you can't," what I really mean is "you can't offset a Bézier curve with another Bézier curve", not even by using
							a really high order curve. You can find the function that describes the offset curve, but it won't be a polynomial, and as such it
							cannot be represented as a Bézier curve, which <strong>has</strong> to be a polynomial. Let's look at why this is:
						</p>
						<p>
							From a mathematical point of view, an offset curve <code>O(t)</code> is a curve such that, given our original curve <code>B(t)</code>,
							any point on <code>O(t)</code> is a fixed distance <code>d</code> away from coordinate <code>B(t)</code>. So let's math that:
						</p>
						<!--
\setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
 
                                                              O(t) = B(t) + d
-->
						<img
							class="LaTeX SVG"
							src="./images/chapters/offsetting/3c80407cfd0bd8c8ebea239272aeabe5.svg"
							width="108px"
							height="16px"
							loading="lazy"
						/>
						<p>
							However, we're working in 2D, and <code>d</code> is a single value, so we want to turn it into a vector. If we want a point distance
							<code>d</code> "away" from the curve <code>B(t)</code> then what we really mean is that we want a point at <code>d</code> times the
							"normal vector" from point <code>B(t)</code>, where the "normal" is a vector that runs perpendicular ("at a right angle") to the tangent
							at <code>B(t)</code>. Easy enough:
						</p>
						<!--
\setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
 
                                                          O(t) = B(t) + d  · N(t)
-->
						<img
							class="LaTeX SVG"
							src="./images/chapters/offsetting/de8cdb128273beff2d98534b9f090b85.svg"
							width="151px"
							height="16px"
							loading="lazy"
						/>
						<p>
							Now this still isn't very useful unless we know what the formula for <code>N(t)</code> is, so let's find out. <code>N(t)</code> runs
							perpendicular to the original curve tangent, and we know that the tangent is simply <code>B'(t)</code>, so we could just rotate that 90
							degrees and be done with it. However, we need to ensure that <code>N(t)</code> has the same magnitude for every <code>t</code>, or the
							offset curve won't be at a uniform distance, thus not being an offset curve at all. The easiest way to guarantee this is to make sure
							<code>N(t)</code> always has length 1, which we can achieve by dividing <code>B'(t)</code> by its magnitude:
						</p>
						<!--
\setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
 
                                                                    ╭   B'(t)    ╮
                                                          N(t) \bot │ ────────── │
                                                                    ╰ || B'(t)|| ╯
-->
						<img
							class="LaTeX SVG"
							src="./images/chapters/offsetting/57e62f3f2f7526b2cf7c1b276c17e472.svg"
							width="120px"
							height="40px"
							loading="lazy"
						/>
						<p>
							Determining the length requires computing an arc length, and this is where things get Tricky with a capital T. First off, to compute arc
							length from some start <code>a</code> to end <code>b</code>, we must use the formula we saw earlier. Noting that "length" is usually
							denoted with double vertical bars:
						</p>
						<!--
\setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
 
                                                                         ┌───────────┐
                                                                    ╭ b  │   2      2
                                                     || f(x,y)|| =  |    │f '  + f '  
                                                                    ╯ a ⟍│ x      y
-->
						<img
							class="LaTeX SVG"
							src="./images/chapters/offsetting/cf8e602eb0595cf4d9b851c6bda741af.svg"
							width="169px"
							height="36px"
							loading="lazy"
						/>
						<p>
							So if we want the length of the tangent, we plug in <code>B'(t)</code>, with <code>t = 0</code> as start and <code>t = 1</code> as end:
						</p>
						<!--
\setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
 
                                                                     ┌───────────────────┐
                                                                ╭ 1  │       2          2
                                                  || B'(t)|| =  |    │B ''(t)  + B ''(t)  
                                                                ╯ 0 ⟍│ x          y
-->
						<img
							class="LaTeX SVG"
							src="./images/chapters/offsetting/af4b584bb280cc941603255f62c9cc1a.svg"
							width="209px"
							height="36px"
							loading="lazy"
						/>
						<p>
							And that's where things go wrong. It doesn't even really matter what the second derivative for <code>B(t)</code> is, that square root is
							screwing everything up, because it turns our nice polynomials into things that are no longer polynomials.
						</p>
						<p>
							There is a small class of polynomials where the square root is also a polynomial, but they're utterly useless to us: any polynomial with
							unweighted binomial coefficients has a square root that is also a polynomial. Now, you might think that Bézier curves are just fine
							because they do, but they don't; remember that only the <strong>base</strong> function has binomial coefficients. That's before we
							factor in our coordinates, which turn it into a non-binomial polygon. The only way to make sure the functions stay binomial is to make
							all our coordinates have the same value. And that's not a curve, that's a point. We can already create offset curves for points, we call
							them circles, and they have much simpler functions than Bézier curves.
						</p>
						<p>
							So, since the tangent length isn't a polynomial, the normalised tangent won't be a polynomial either, which means
							<code>N(t)</code> won't be a polynomial, which means that <code>d</code> times <code>N(t)</code> won't be a polynomial, which means
							that, ultimately, <code>O(t)</code> won't be a polynomial, which means that even if we can determine the function for
							<code>O(t)</code> just fine (and that's far from trivial!), it simply cannot be represented as a Bézier curve.
						</p>
						<p>
							And that's one reason why Bézier curves are tricky: there are actually a <em>lot</em> of curves that cannot be represented as a Bézier
							curve at all. They can't even model their own offset curves. They're weird that way. So how do all those other programs do it? Well,
							much like we're about to do, they cheat. We're going to approximate an offset curve in a way that will look relatively close to what the
							real offset curve would look like, if we could compute it.
						</p>
					</div>

					<p>
						So, you cannot offset a Bézier curve perfectly with another Bézier curve, no matter how high-order you make that other Bézier curve.
						However, we can chop up a curve into "safe" sub-curves (where "safe" means that all the control points are always on a single side of the
						baseline, and the midpoint of the curve at <code>t=0.5</code> is roughly in the center of the polygon defined by the curve coordinates)
						and then point-scale each sub-curve with respect to its scaling origin (which is the intersection of the point normals at the start and
						end points).
					</p>
					<p>
						A good way to do this reduction is to first find the curve's extreme points, as explained in the earlier section on curve extremities, and
						use these as initial splitting points. After this initial split, we can check each individual segment to see if it's "safe enough" based
						on where the center of the curve is. If the on-curve point for <code>t=0.5</code> is too far off from the center, we simply split the
						segment down the middle. Generally this is more than enough to end up with safe segments.
					</p>
					<p>
						The following graphics show off curve offsetting, and you can use the slider to control the distance at which the curve gets offset. The
						curve first gets reduced to safe segments, each of which is then offset at the desired distance. Especially for simple curves,
						particularly easily set up for quadratic curves, no reduction is necessary, but the more twisty the curve gets, the more the curve needs
						to be reduced in order to get segments that can safely be scaled.
					</p>
					<graphics-element
						title="Offsetting a quadratic Bézier curve"
						width="275"
						height="275"
						src="./chapters/offsetting/offsetting.js"
						data-type="quadratic"
					>
						<fallback-image>
							<span class="view-source">Scripts are disabled. Showing fallback image.</span>
							<img width="275px" height="275px" src="./images/chapters/offsetting/03b8e0849e7c8ba64d8c076f47fe2ec7.png" loading="lazy" />
							<label>Offsetting a quadratic Bézier curve</label>
						</fallback-image>
						<input type="range" min="5" max="50" step="1" value="20" class="slide-control" />
					</graphics-element>
					<graphics-element
						title="Offsetting a cubic Bézier curve"
						width="275"
						height="275"
						src="./chapters/offsetting/offsetting.js"
						data-type="cubic"
					>
						<fallback-image>
							<span class="view-source">Scripts are disabled. Showing fallback image.</span>
							<img width="275px" height="275px" src="./images/chapters/offsetting/4c4738b6bf9f83eded12d680a29e337b.png" loading="lazy" />
							<label>Offsetting a cubic Bézier curve</label>
						</fallback-image>
						<input type="range" min="5" max="50" step="1" value="20" class="slide-control" />
					</graphics-element>
					<p>
						You may notice that this may still lead to small 'jumps' in the sub-curves when moving the curve around. This is caused by the fact that
						we're still performing a naive form of offsetting, moving the control points the same distance as the start and end points. If the curve
						is large enough, this may still lead to incorrect offsets.
					</p>
				</section>
				<section id="graduatedoffset">
					<h1>
						<div class="nav"><a href="ja-JP/index.html#offsetting">previous</a><a href="ja-JP/index.html#circles">next</a></div>
						<a href="ja-JP/index.html#graduatedoffset">Graduated curve offsetting</a>
					</h1>
					<p>
						What if we want to do graduated offsetting, starting at some distance <code>s</code> but ending at some other distance <code>e</code>?
						Well, if we can compute the length of a curve (which we can if we use the Legendre-Gauss quadrature approach) then we can also determine
						how far "along the line" any point on the curve is. With that knowledge, we can offset a curve so that its offset curve is not uniformly
						wide, but graduated between with two different offset widths at the start and end.
					</p>
					<p>
						Like normal offsetting we cut up our curve in sub-curves, and then check at which distance along the original curve each sub-curve starts
						and ends, as well as to which point on the curve each of the control points map. This gives us the distance-along-the-curve for each
						interesting point in the sub-curve. If we call the total length of all sub-curves seen prior to seeing "the current" sub-curve
						<code>S</code> (and if the current sub-curve is the first one, <code>S</code> is zero), and we call the full length of our original curve
						<code>L</code>, then we get the following graduation values:
					</p>
					<ul>
						<li>start: map <code>S</code> from interval (<code>0,L</code>) to interval <code>(s,e)</code></li>
						<li>c1: <code>map(&lt;strong&gt;S+d1&lt;/strong&gt;, 0,L, s,e)</code>, d1 = distance along curve to projection of c1</li>
						<li>c2: <code>map(&lt;strong&gt;S+d2&lt;/strong&gt;, 0,L, s,e)</code>, d2 = distance along curve to projection of c2</li>
						<li>...</li>
						<li>end: <code>map(&lt;strong&gt;S+length(subcurve)&lt;/strong&gt;, 0,L, s,e)</code></li>
					</ul>
					<p>
						At each of the relevant points (start, end, and the projections of the control points onto the curve) we know the curve's normal, so
						offsetting is simply a matter of taking our original point, and moving it along the normal vector by the offset distance for each point.
						Doing so will give us the following result (these have with a starting width of 0, and an end width of 40 pixels, but can be controlled
						with your up and down arrow keys):
					</p>
					<graphics-element
						title="Offsetting a quadratic Bézier curve"
						width="275"
						height="275"
						src="./chapters/graduatedoffset/offsetting.js"
						data-type="quadratic"
					>
						<fallback-image>
							<span class="view-source">Scripts are disabled. Showing fallback image.</span>
							<img width="275px" height="275px" src="./images/chapters/graduatedoffset/8cc724d5343c65685d88c92b2d069a2a.png" loading="lazy" />
							<label>Offsetting a quadratic Bézier curve</label>
						</fallback-image>
						<input type="range" min="5" max="50" step="1" value="20" class="slide-control" />
					</graphics-element>
					<graphics-element
						title="Offsetting a cubic Bézier curve"
						width="275"
						height="275"
						src="./chapters/graduatedoffset/offsetting.js"
						data-type="cubic"
					>
						<fallback-image>
							<span class="view-source">Scripts are disabled. Showing fallback image.</span>
							<img width="275px" height="275px" src="./images/chapters/graduatedoffset/17bf62e05a1fc3387b0c210f2decff45.png" loading="lazy" />
							<label>Offsetting a cubic Bézier curve</label>
						</fallback-image>
						<input type="range" min="5" max="50" step="1" value="20" class="slide-control" />
					</graphics-element>
				</section>
				<section id="circles">
					<h1>
						<div class="nav"><a href="ja-JP/index.html#graduatedoffset">previous</a><a href="ja-JP/index.html#circles_cubic">next</a></div>
						<a href="ja-JP/index.html#circles">Circles and quadratic Bézier curves</a>
					</h1>
					<p>
						Circles and Bézier curves are very different beasts, and circles are infinitely easier to work with than Bézier curves. Their formula is
						much simpler, and they can be drawn more efficiently. But, sometimes you don't have the luxury of using circles, or ellipses, or arcs.
						Sometimes, all you have are Bézier curves. For instance, if you're doing font design, fonts have no concept of geometric shapes, they only
						know straight lines, and Bézier curves. OpenType fonts with TrueType outlines only know quadratic Bézier curves, and OpenType fonts with
						Type 2 outlines only know cubic Bézier curves. So how do you draw a circle, or an ellipse, or an arc?
					</p>
					<p>You approximate.</p>
					<p>
						We already know that Bézier curves cannot model all curves that we can think of, and this includes perfect circles, as well as ellipses,
						and their arc counterparts. However, we can certainly approximate them to a degree that is visually acceptable. Quadratic and cubic curves
						offer us different curvature control, so in order to approximate a circle we will first need to figure out what the error is if we try to
						approximate arcs of increasing degree with quadratic and cubic curves, and where the coordinates even lie.
					</p>
					<p>
						Since arcs are mid-point-symmetrical, we need the control points to set up a symmetrical curve. For quadratic curves this means that the
						control point will be somewhere on a line that intersects the baseline at a right angle. And we don't get any choice on where that will
						be, since the derivatives at the start and end point have to line up, so our control point will lie at the intersection of the tangents at
						the start and end point.
					</p>
					<p>
						First, let's try to fit the quadratic curve onto a circular arc. In the following sketch you can move the mouse around over a unit circle,
						to see how well, or poorly, a quadratic curve can approximate the arc from (1,0) to where your mouse cursor is:
					</p>
					<graphics-element title="Quadratic Bézier arc approximation" width="400" height="400" src="./chapters/circles/arc-approximation.js">
						<fallback-image>
							<span class="view-source">Scripts are disabled. Showing fallback image.</span>
							<img width="400px" height="400px" src="./images/chapters/circles/08ca09aacb271735e063e7e8d941a195.png" loading="lazy" />
							<label></label>
						</fallback-image>
						<input type="range" min="-3.1415" max="3.1415" step="0.01" value="-0.7854" class="slide-control" />
					</graphics-element>
					<p>
						As you can see, things go horribly wrong quite quickly; even trying to approximate a quarter circle using a quadratic curve is a bad idea.
						An eighth of a turns might look okay, but how okay is okay? Let's apply some maths and find out. What we're interested in is how far off
						our on-curve coordinates are with respect to a circular arc, given a specific start and end angle. We'll be looking at how much space
						there is between the circular arc, and the quadratic curve's midpoint.
					</p>
					<p>
						We start out with our start and end point, and for convenience we will place them on a unit circle (a circle around 0,0 with radius 1), at
						some angle <em>φ</em>:
					</p>
					<!--
\setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
 
                                                           S = \begin{pmatrix} 1
                                              0 \end{pmatrix}  ,  \ E = \begin{pmatrix} cos(φ)
                                                            sin(φ) \end{pmatrix}
-->
					<img class="LaTeX SVG" src="./images/chapters/circles/7ab3da0922477af4cc09f5852100976b.svg" width="175px" height="40px" loading="lazy" />
					<p>What we want to find is the intersection of the tangents, so we want a point C such that:</p>
					<!--
\setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
 
                                                       C = S + a  · \begin{pmatrix} 0
                                         1 \end{pmatrix}  ,  \ C = E + b  · \begin{pmatrix} -sin(φ)
                                                            cos(φ) \end{pmatrix}
-->
					<img class="LaTeX SVG" src="./images/chapters/circles/d4bfb47b623c968e3231566c9705c6c4.svg" width="284px" height="40px" loading="lazy" />
					<p>
						i.e. we want a point that lies on the vertical line through S (at some distance <em>a</em> from S) and also lies on the tangent line
						through E (at some distance <em>b</em> from E). Solving this gives us:
					</p>
					<!--
\setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
 
                                                     ╭ C  = 1 = cos(φ) + b  · -sin(φ)
                                                     ╡  x                             
                                                     │ C  = a = sin(φ) + b  · cos(φ) 
                                                     ╰  y
-->
					<img class="LaTeX SVG" src="./images/chapters/circles/8237af1396bb567d70c8b5e4dd7f8115.svg" width="219px" height="40px" loading="lazy" />
					<p>First we solve for <em>b</em>:</p>
					<!--
\setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
 
                          1 = cos(φ) + b  · -sin(φ)  → \ 1 - cos(φ) = -b  · sin(φ)  → \ -1 + cos(φ) = b  · sin(φ)
-->
					<img class="LaTeX SVG" src="./images/chapters/circles/1829e42ea956ee4df0e45d9ac5334ef7.svg" width="560px" height="17px" loading="lazy" />
					<p>which yields:</p>
					<!--
\setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
 
                                                                    cos(φ)-1
                                                                b = ────────
                                                                     sin(φ)
-->
					<img class="LaTeX SVG" src="./images/chapters/circles/06369b00338310df0a810c592485aa0a.svg" width="101px" height="39px" loading="lazy" />
					<p>which we can then substitute in the expression for <em>a</em>:</p>
					<!--
\setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
 
                                                      a= sin(φ) + b  · cos(φ)          
                                                                  -1 + cos(φ)
                                                     ..= sin(φ) + ───────────  · cos(φ)
                                                                    sin(φ)
                                                                               2
                                                                  -cos(φ) + cos (φ)
                                                     ..= sin(φ) + ─────────────────    
                                                                       sin(φ)          
                                                            2         2
                                                         sin (φ) + cos (φ) - cos(φ)
                                                     ..= ──────────────────────────    
                                                                   sin(φ)
                                                         1 - cos(φ)
                                                      a= ──────────                    
                                                           sin(φ)
-->
					<img class="LaTeX SVG" src="./images/chapters/circles/5a23f3bc298c85540c6dd18e304d9224.svg" width="231px" height="195px" loading="lazy" />
					<p>
						A quick check shows that plugging these values for <em>a</em> and <em>b</em> into the expressions for C<sub>x</sub> and C<sub>y</sub> give
						the same x/y coordinates for both "<em>a</em> away from A" and "<em>b</em> away from B", so let's continue: now that we know the
						coordinate values for C, we know where our on-curve point T for <em>t=0.5</em> (or angle φ/2) is, because we can just evaluate the Bézier
						polynomial, and we know where the circle arc's actual point P is for angle φ/2:
					</p>
					<!--
\setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
 
                                                                φ                 φ
                                                       P  = cos(─)  ,  \ P  = sin(─)
                                                        x       2         y       2
-->
					<img class="LaTeX SVG" src="./images/chapters/circles/8b4e1d0a62380ed011f27c645ed13b28.svg" width="188px" height="32px" loading="lazy" />
					<p>We compute T, observing that if <em>t=0.5</em>, the polynomial values (1-t)², 2(1-t)t, and t² are 0.25, 0.5, and 0.25 respectively:</p>
					<!--
\setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
 
                                                          1    2    1    1
                                                      T = ─S + ─C + ─E = ─(S + 2C + E)
                                                          4    4    4    4
-->
					<img class="LaTeX SVG" src="./images/chapters/circles/a04bd1558a76e60b8ca6e1fe4fa38c00.svg" width="252px" height="35px" loading="lazy" />
					<p>Which, worked out for the x and y components, gives:</p>
					<!--
\setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
 
                                          ╭     1
                                          │ T = ─(3 + cos(φ))                                    
                                          ╡  x  4                                                 
                                          │     1╭ 2-2cos(φ)          ╮   1╭     ╭ φ ╮          ╮
                                          │ T = ─│ ───────── + sin(φ) │ = ─│ 2tan│ ─ │ + sin(φ) │
                                          ╰  y  4╰  sin(φ)            ╯   4╰     ╰ 2 ╯          ╯
-->
					<img class="LaTeX SVG" src="./images/chapters/circles/986ae9104e0bc52e95689ae7ae4504db.svg" width="408px" height="77px" loading="lazy" />
					<p>And the distance between these two is the standard Euclidean distance:</p>
					<!--
\setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
 
                                                           1                   φ        4╭ φ ╮
                                          d (φ)= T  - P  = ─(3 + cos(φ)) - cos(─) = 2sin │ ─ │  ,
                                           x      x    x   4                   2         ╰ 4 ╯
                                                           1╭     ╭ φ ╮          ╮       φ
                                          d (φ)= T  - P  = ─│ 2tan│ ─ │ + sin(φ) │ - sin(─)  ,   
                                           y      y    y   4╰     ╰ 2 ╯          ╯       2
                                               ⇓                                                 
                                                  ┌───────┐                     ┌───────┐
                                                  │ 2    2                 4 φ  │   1
                                           d(φ)=  │d  + d   =  ...   = 2sin (─) │───────         
                                                 ⟍│ x    y                   4  │   2 φ
                                                                                │cos (─)
                                                                               ⟍│     2
-->
					<img class="LaTeX SVG" src="./images/chapters/circles/942c90bc8311e49d94059b3127fc78d5.svg" width="399px" height="153px" loading="lazy" />
					<p>
						So, what does this distance function look like when we plot it for a number of ranges for the angle φ, such as a half circle, quarter
						circle and eighth circle?
					</p>
					<table>
						<tbody>
							<tr>
								<td>
									<img src="images/arc-q-pi.gif" height="190" />
									plotted for 0 ≤ φ ≤ π:
								</td>
								<td>
									<img src="images/arc-q-pi2.gif" height="187" />
									plotted for 0 ≤ φ ≤ ½π:
								</td>
								<td>
									<a
										href="https://www.wolframalpha.com/input/?i=plot+sqrt%28%281%2F4+*+%28sin%28x%29+%2B+2tan%28x%2F2%29%29+-+sin%28x%2F2%29%29%5E2+%2B+%282sin%5E4%28x%2F4%29%29%5E2%29+for+0+%3C%3D+x+%3C%3D+pi%2F4"
									>
										<img src="images/arc-q-pi4.gif" height="174" />
									</a>
									plotted for 0 ≤ φ ≤ ¼π:
								</td>
							</tr>
						</tbody>
					</table>

					<p>
						We now see why the eighth circle arc looks decent, but the quarter circle arc doesn't: an error of roughly 0.06 at <em>t=0.5</em> means
						we're 6% off the mark... we will already be off by one pixel on a circle with pixel radius 17. Any decent sized quarter circle arc, say
						with radius 100px, will be way off if approximated by a quadratic curve! For the eighth circle arc, however, the error is only roughly
						0.003, or 0.3%, which explains why it looks so close to the actual eighth circle arc. In fact, if we want a truly tiny error, like 0.001,
						we'll have to contend with an angle of (rounded) 0.593667, which equates to roughly 34 degrees. We'd need 11 quadratic curves to form a
						full circle with that precision! (technically, 10 and ten seventeenth, but we can't do partial curves, so we have to round up). That's a
						whole lot of curves just to get a shape that can be drawn using a simple function!
					</p>
					<p>
						In fact, let's flip the function around, so that if we plug in the precision error, labelled ε, we get back the maximum angle for that
						precision:
					</p>
					<!--
\setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
 
                                                                    ╭  ┌─────────────┐ ╮
                                                                    │  │     ┌──────┐  │
                                                                    │ ⟍│2+ε-⟍│ε(2+ε)   │
                                                    φ = 4  · arccos │ ──────────────── │
                                                                    │        ┌─┐       │
                                                                    ╰       ⟍│2        ╯
-->
					<img class="LaTeX SVG" src="./images/chapters/circles/f9d15462df31186feef8c3d53c0f6163.svg" width="247px" height="53px" loading="lazy" />
					<p>
						And frankly, things are starting to look a bit ridiculous at this point, we're doing way more maths than we've ever done, but thankfully
						this is as far as we need the maths to take us: If we plug in the precisions 0.1, 0.01, 0.001 and 0.0001 we get the radians values 1.748,
						1.038, 0.594 and 0.3356; in degrees, that means we can cover roughly 100 degrees (requiring four curves), 59.5 degrees (requiring six
						curves), 34 degrees (requiring 11 curves), and 19.2 degrees (requiring a whopping nineteen curves).
					</p>
					<p>
						The bottom line? <strong>Quadratic curves are kind of lousy</strong> if you want circular (or elliptical, which are circles that have been
						squashed in one dimension) curves. We can do better, even if it's just by raising the order of our curve once. So let's try the same thing
						for cubic curves.
					</p>
				</section>
				<section id="circles_cubic">
					<h1>
						<div class="nav"><a href="ja-JP/index.html#circles">previous</a><a href="ja-JP/index.html#arcapproximation">next</a></div>
						<a href="ja-JP/index.html#circles_cubic">Circles and cubic Bézier curves</a>
					</h1>
					<p>
						In the previous section we tried to approximate a circular arc with a quadratic curve, and it mostly made us unhappy. Cubic curves are
						much better suited to this task, so what do we need to do?
					</p>
					<p>
						For cubic curves, we basically want the curve to pass through three points on the circle: the start point, the mid point at "angle/2", and
						the end point at "angle". We then also need to make sure the control points are such that the start and end tangent lines line up with the
						circle's tangent lines at the start and end point.
					</p>
					<p>
						The first thing we can do is "guess" what the curve should look like, based on the previously outlined curve-through-three-points
						procedure. This will give use a curve with correct start, mid and end points, but possibly incorrect derivatives at the start and end,
						because the control points might not be in the right spot. We can then slide the control points along the lines that connect them to their
						respective end point, until they effect the corrected derivative at the start and end points. However, if you look back at the section on
						fitting curves through three points, the rules used were such that they optimized for a near perfect hemisphere, so using the same guess
						won't be all that useful: guessing the solution based on knowing the solution is not really guessing.
					</p>
					<p>
						So have a graphical look at a "bad" guess versus the true fit, where we'll be using the bad guess and the description in the second
						paragraph to derive the maths for the true fit:
					</p>
					<graphics-element title="Cubic Bézier arc approximation" width="400" height="400" src="./chapters/circles_cubic/arc-approximation.js">
						<fallback-image>
							<span class="view-source">Scripts are disabled. Showing fallback image.</span>
							<img width="400px" height="400px" src="./images/chapters/circles_cubic/ecacec0eb2bbe72e14b9008d854fbb06.png" loading="lazy" />
							<label></label>
						</fallback-image>
						<input type="range" min="-3.1415" max="3.1415" step="0.01" value="-0.7854" class="slide-control" />
					</graphics-element>
					<p>
						We see two curves here; in blue, our "guessed" curve and its control points, and in grey/black, the true curve fit, with proper control
						points that were shifted in, along line between our guessed control points, such that the derivatives at the start and end points are
						correct.
					</p>
					<p>
						We can already see that cubic curves are a lot better than quadratic curves, and don't look all that wrong until we go well past a quarter
						circle; ⅜th starts to hint at problems, and half a circle has an obvious "gap" between the real circle and the cubic approximation.
						Anything past that just looks plain ridiculous... but quarter curves actually look pretty okay!
					</p>
					<p>So, maths time again: how okay is "okay"? Let's apply some more maths to find out.</p>
					<p>
						Unlike for the quadratic curve, we can't use <i>t=0.5</i> as our reference point because by its very nature it's one of the three points
						that are actually guaranteed to lie on the circular curve. Instead, we need a different <i>t</i> value. If we run some analysis on the
						curve we find that the actual <i>t</i> value at which the curve is furthest from what it should be is 0.211325 (rounded), but we don't
						know "why", since finding this value involves root-finding, and is nearly impossible to do symbolically without pages and pages of math
						just to express one of the possible solutions.
					</p>
					<p>
						So instead of walking you through the derivation for that value, let's simply take that <i>t</i> value and see what the error is for
						circular arcs with an angle ranging from 0 to 2π:
					</p>
					<table>
						<tbody>
							<tr>
								<td>
									<img src="images/arc-c-2pi.gif" height="187" />
									plotted for 0 ≤ φ ≤ 2π:
								</td>
								<td>
									<img src="images/arc-c-pi.gif" height="187" />
									plotted for 0 ≤ φ ≤ π:
								</td>
								<td>
									<img src="images/arc-c-pi2.gif" height="187" />
									plotted for 0 ≤ φ ≤ ½π:
								</td>
							</tr>
						</tbody>
					</table>

					<p>
						We see that cubic Bézier curves are much better when it comes to approximating circular arcs, with an error of less than 0.027 at the two
						"bulge" points for a quarter circle (which had an error of 0.06 for quadratic curves at the mid point), and an error near 0.001 for an
						eighth of a circle, so we're getting less than half the error for a quarter circle, or: at a slightly lower error, we're getting twice the
						arc. This makes cubic curves quite useful!
					</p>
					<p>
						In fact, the precision of a cubic curve at a quarter circle is considered "good enough" by so many people that it's generally considered
						"just fine" to use four cubic Bézier curves to fake a full circle when no circle primitives are available; generally, people won't notice
						that it's not a real circle unless you also happen to overlay an actual circle, so that the difference becomes obvious.
					</p>
					<p>
						So with the error analysis out of the way, how do we actually compute the coordinates needed to get that "true fit" cubic curve? The first
						observation is that we already know the start and end points, because they're the same as for the quadratic attempt:
					</p>
					<!--
\setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
 
                                                           S = \begin{pmatrix} 1
                                              0 \end{pmatrix}  ,  \ E = \begin{pmatrix} cos(φ)
                                                            sin(φ) \end{pmatrix}
-->
					<img
						class="LaTeX SVG"
						src="./images/chapters/circles_cubic/eeff3b36af960053cb4eb692abe36cd8.svg"
						width="175px"
						height="40px"
						loading="lazy"
					/>
					<p>
						But we now need to find two control points, rather than one. If we want the derivatives at the start and end point to match the circle,
						then the first control point can only lie somewhere on the vertical line through S, and the second control point can only lie somewhere on
						the line tangent to point E, which means:
					</p>
					<!--
\setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
 
                                                      C  = S + a  · \begin{pmatrix} 0
                                                       1
                                                              1 \end{pmatrix}
-->
					<img
						class="LaTeX SVG"
						src="./images/chapters/circles_cubic/0b4c1e8f1f7a9c1292787f127ddb1624.svg"
						width="113px"
						height="40px"
						loading="lazy"
					/>
					<p>where "a" is some scaling factor we'll need to find the expression for, and:</p>
					<!--
\setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
 
                                                    C  = E + a  · \begin{pmatrix} sin(φ)
                                                     2
                                                            cos(φ) \end{pmatrix}
-->
					<img
						class="LaTeX SVG"
						src="./images/chapters/circles_cubic/d28eb43a1b34befb7659dcdfb3a9e718.svg"
						width="151px"
						height="40px"
						loading="lazy"
					/>
					<p>using the same scaling factor, because circular arcs are symmetrical, so our approximation will need to be symmetrical, too.</p>
					<p>
						Starting with this information, we slowly maths our way to success, but I won't lie: the maths for this is pretty trig-heavy, and it's
						easy to get lost if you remember (or know!) some of the core trigonometric identities, so if you just want to see the final result just
						skip past the next section!
					</p>
					<div class="note">
						<h2>Let's do this thing.</h2>
						<p>
							Unlike for the quadratic case, we need some more information in order to compute <i>a</i> and <i>b</i>, since they're no longer
							dependent variables. First, we observe that the curve is symmetrical, so whatever values we end up finding for C<sub>1</sub> will apply
							to C<sub>2</sub> as well (rotated along its tangent), so we'll focus on finding the location of C<sub>1</sub> only. So here's where we
							do something that you might not expect: we're going to ignore for a moment, because we're going to have a much easier time if we just
							solve this problem with geometry first, then move to calculus to solve a much simpler problem.
						</p>
						<p>
							If we look at the triangle that is formed between our starting point, or initial guess C<sub>1</sub> and our real C<sub>1</sub>, there's
							something funny going on: if we treat the line {start,guess} as our opposite side, the line {guess,real} as our adjacent side, with
							{start,real} our hypotenuse, then the angle for the corner hypotenuse/adjacent is half that of the arc we're covering. Try it: if you
							place the end point at a quarter circle (pi/2, or 90 degrees), the angle in our triangle is half a quarter (pi/4, or 45 degrees). With
							that knowledge, and a knowledge of what the length of any of our lines segments are (as a function), we can determine where our control
							points are, and thus have everything we need to find the error distance function. Of the three lines, the one we can easiest determine
							is {start,guess}, so let's find out what the guessed control point is. Again geometrically, because we have the benefit of an on-curve
							<i>t=0.5</i> value.
						</p>
						<p>
							The distance from our guessed point to the start point is exactly the same as the projection distance we looked at earlier. Using
							<i>t=0.5</i> as our point "B" in the "A,B,C" projection, then we know the length of the line segment {C,A}, since it's d<sub>1</sub> =
							{A,B} + d<sub>2</sub> = {B,C}:
						</p>
						<!--
\setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
 
                                                                              ╭ 1 ╮        1     4
                                        ||A,C|| = d  + d  = d  + d   · ratio  │ ─ │ = d  + ─d  = ─d 
                                                   2    1    2    2         3 ╰ 2 ╯    2   3 2   3 2
-->
						<img
							class="LaTeX SVG"
							src="./images/chapters/circles_cubic/750e2c874fb58237608ebade1589fccc.svg"
							width="397px"
							height="40px"
							loading="lazy"
						/>
						<p>
							So that just leaves us to find the distance from <i>t=0.5</i> to the baseline for an arbitrary angle φ, which is the distance from the
							centre of the circle to our <i>t=0.5</i> point, minus the distance from the centre to the line that runs from start point to end point.
							The first is the same as the point P we found for the quadratic curve:
						</p>
						<!--
\setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
 
                                                                φ                 φ
                                                       P  = cos(─)  ,  \ P  = sin(─)
                                                        x       2         y       2
-->
						<img
							class="LaTeX SVG"
							src="./images/chapters/circles_cubic/8b4e1d0a62380ed011f27c645ed13b28.svg"
							width="188px"
							height="32px"
							loading="lazy"
						/>
						<p>
							And the distance from the origin to the line start/end is another application of angles, since the triangle {origin,start,C} has known
							angles, and two known sides. We can find the length of the line {origin,C}, which lets us trivially compute the coordinate for C:
						</p>
						<!--
\setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
 
                                                       φ
                                               l = cos(─)  ,                                
                                                       2
                                               ╭              ╭ φ ╮      2╭ φ ╮
                                               │ C  = l  · cos│ ─ │ = cos │ ─ │ ,           
                                               ╡  x           ╰ 2 ╯       ╰ 2 ╯             
                                               │              ╭ φ ╮       φ        ╭ φ ╮
                                               │ C  = l  · sin│ ─ │ = cos(─)  · sin│ ─ │ , 
                                               ╰  y           ╰ 2 ╯       2        ╰ 2 ╯
-->
						<img
							class="LaTeX SVG"
							src="./images/chapters/circles_cubic/bc884416145a846cebddc8c5d13f147f.svg"
							width="261px"
							height="67px"
							loading="lazy"
						/>
						<p>
							With the coordinate C, and knowledge of coordinate B, we can determine coordinate A, and get a vector that is identical to the vector
							{start,guess}:
						</p>
						<!--
\setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
 
                                       ╭              ╭ φ ╮      2╭ φ ╮
                                       │ B  - C  = cos│ ─ │ - cos │ ─ │                             
                                       ╡  x    x      ╰ 2 ╯       ╰ 2 ╯                              
                                       │              ╭ φ ╮       φ        ╭ φ ╮      ╭ φ ╮   sin(φ)
                                       │ B  - C  = sin│ ─ │ - cos(─)  · sin│ ─ │ = sin│ ─ │ - ──────
                                       ╰  y    y      ╰ 2 ╯       2        ╰ 2 ╯      ╰ 2 ╯     2
-->
						<img
							class="LaTeX SVG"
							src="./images/chapters/circles_cubic/2ba4e0e2dbbdf3ea7dbd9cff3e049d0d.svg"
							width="397px"
							height="48px"
							loading="lazy"
						/>
						<!--
\setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
 
                                                    ╭                   4
                                                    │ \vecv  = {C,A}  = ─  · (B  - C )
                                                    ╡      x        x   3      x    x  
                                                    │                   4
                                                    │ \vecv  = {C,A}  = ─  · (B  - C )
                                                    ╰      y        y   3      y    y
-->
						<img
							class="LaTeX SVG"
							src="./images/chapters/circles_cubic/046e0bec7cc3d8a502b2f76b4722be2d.svg"
							width="211px"
							height="47px"
							loading="lazy"
						/>
						<p>
							Which means we can now determine the distance {start,guessed}, which is the same as the distance {C,A}, and use that to determine the
							vertical distance from our start point to our C<sub>1</sub>:
						</p>
						<!--
\setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
 
                                            ╭ C   = 1                                          
                                            │  1x
                                            │                   ┌───────────────┐
                                            │                   │     2        2
                                            ╡                   │\vecv  + \vecv                 
                                            │          d       ⟍│     x        y    4     ╭ φ ╮
                                            │ C   = ──────── = ────────────────── = ─ tan │ ─ │
                                            │  1y      ╭ φ ╮           ╭ φ ╮        3     ╰ 4 ╯
                                            │       sin│ ─ │        sin│ ─ │
                                            ╰          ╰ 2 ╯           ╰ 2 ╯
-->
						<img
							class="LaTeX SVG"
							src="./images/chapters/circles_cubic/fa5d308b0b50400fbae1411f390bc7ce.svg"
							width="252px"
							height="56px"
							loading="lazy"
						/>
						<p>
							And after this tedious detour to find the coordinate for C<sub>1</sub>, we can find C<sub>2</sub> fairly simply, since it's lies at
							distance -C<sub>1y</sub> along the end point's tangent:
						</p>
						<!--
\setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
 
                           E'  = -sin(φ)  ,                                                                     
                             x
                           E'  = cos(φ)  ,                                                                      
                             y
                                     ┌────────────────────┐
                                     │         2      2
                           ||E'|| = ⟍│(-sin(φ))  + cos (φ)  = 1  ,                                              
                                                                                                                
                           ╭                    E '
                           │                     x                                        4     ╭ φ ╮
                           │ C x = E  - C    · ────── = cos(φ) + C    · sin(φ) = cos(φ) + ─ tan │ ─ │  · sin(φ)
                           ╡  2     x    1y    ||E'||             1y                      3     ╰ 4 ╯           
                           │                    E '
                           │                     y                                        4     ╭ φ ╮
                           │ C y = E  - C    · ────── = sin(φ) - C    · cos(φ) = sin(φ) - ─ tan │ ─ │  · cos(φ)
                           ╰  2     y    1y    ||E'||             1y                      3     ╰ 4 ╯
-->
						<img
							class="LaTeX SVG"
							src="./images/chapters/circles_cubic/459c037fb92685566d624f81a298e9c8.svg"
							width="524px"
							height="137px"
							loading="lazy"
						/>
						<p>And that's it, we have all four points now for an approximation of an arbitrary circular arc with angle φ.</p>
					</div>

					<p>So, to recap, given an angle φ, the new control coordinates are:</p>
					<!--
\setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
 
                                                                           4     ╭ φ ╮
                                                      C  = ┌ 1 ┐, with f = ─ tan │ ─ │
                                                       1   └ f ┘           3     ╰ 4 ╯
-->
					<img
						class="LaTeX SVG"
						src="./images/chapters/circles_cubic/38b58b3c759b9bf340a3cf3de8bc599e.svg"
						width="205px"
						height="40px"
						loading="lazy"
					/>
					<p>and</p>
					<!--
\setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
 
                                                                                    4     ╭ φ ╮
                                            C  = ┌ cos(φ) + f  · sin(φ) ┐, with f = ─ tan │ ─ │
                                             2   └ sin(φ) - f  · cos(φ) ┘           3     ╰ 4 ╯
-->
					<img
						class="LaTeX SVG"
						src="./images/chapters/circles_cubic/329dc34299d2fdb3c5f17828e3a23da0.svg"
						width="321px"
						height="40px"
						loading="lazy"
					/>
					<p>
						And, because the "quarter curve" special case comes up so incredibly often, let's look at what these new control points mean for the curve
						coordinates of a quarter curve, by simply filling in φ = π/2:
					</p>
					<!--
\setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
 
                                                   ╭       ┌─┐   ╮           ╭    ┌─┐       ╮
                                                   │      ⟍│2 -1 │           │   ⟍│2 -1     │                
                              S = (1, 0)  , \ C  = │ 1, 4 ────── │  , \ C  = │ 4 ────── , 1 │  , \ E = (0, 1)
                                               1   ╰        3    ╯       2   ╰     3        ╯
-->
					<img
						class="LaTeX SVG"
						src="./images/chapters/circles_cubic/6a14e5a71dd9e0cefe158640eabb8696.svg"
						width="412px"
						height="33px"
						loading="lazy"
					/>
					<p>Which, in decimal values, rounded to six significant digits, is:</p>
					<!--
\setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
 
                                 S = (1, 0)  , \ C  = (1, 0.55228)  , \ C  = (0.55228 , 1)  , \ E = (0, 1)
                                                  1                      2
-->
					<img
						class="LaTeX SVG"
						src="./images/chapters/circles_cubic/2d9df7ddd2aa223a951016b93d9620c2.svg"
						width="412px"
						height="16px"
						loading="lazy"
					/>
					<p>
						Of course, this is for a circle with radius 1, so if you have a different radius circle, simply multiply the coordinate by the radius you
						need. And then finally, forming a full curve is now a simple a matter of mirroring these coordinates about the origin:
					</p>
					<graphics-element title="Cubic Bézier circle approximation" width="340" height="300" src="./chapters/circles_cubic/circle.js">
						<fallback-image>
							<span class="view-source">Scripts are disabled. Showing fallback image.</span>
							<img width="340px" height="300px" src="./images/chapters/circles_cubic/63f35fb58d3571200ac6ccea0384b9d7.png" loading="lazy" />
							<label></label> </fallback-image
					></graphics-element>
				</section>
				<section id="arcapproximation">
					<h1>
						<div class="nav"><a href="ja-JP/index.html#circles_cubic">previous</a><a href="ja-JP/index.html#bsplines">next</a></div>
						<a href="ja-JP/index.html#arcapproximation">Approximating Bézier curves with circular arcs</a>
					</h1>
					<p>
						Let's look at doing the exact opposite of the previous section: rather than approximating circular arc using Bézier curves, let's
						approximate Bézier curves using circular arcs.
					</p>
					<p>
						We already saw in the section on circle approximation that this will never yield a perfect equivalent, but sometimes you need circular
						arcs, such as when you're working with fabrication machinery, or simple vector languages that understand lines and circles, but not much
						else.
					</p>
					<p>
						The approach is fairly simple: pick a starting point on the curve, and pick two points that are further along the curve. Determine the
						circle that goes through those three points, and see if it fits the part of the curve we're trying to approximate. Decent fit? Try spacing
						the points further apart. Bad fit? Try spacing the points closer together. Keep doing this until you've found the "good approximation/bad
						approximation" boundary, record the "good" arc, and then move the starting point up to overlap the end point we previously found. Rinse
						and repeat until we've covered the entire curve.
					</p>
					<p>
						We already saw how to fit a circle through three points in the section on <a href="#pointcurves">creating a curve from three points</a>,
						and finding the arc through those points is straight-forward: pick one of the three points as start point, pick another as an end point,
						and the arc has to necessarily go from the start point, to the end point, over the remaining point.
					</p>
					<p>So, how can we convert a Bézier curve into a (sequence of) circular arc(s)?</p>
					<ul>
						<li>Start at <code>t=0</code></li>
						<li>Pick two points further down the curve at some value <code>m = t + n</code> and <code>e = t + 2n</code></li>
						<li>Find the arc that these points define</li>
						<li>
							Determine how close the found arc is to the curve:
							<ul>
								<li>Pick two additional points <code>e1 = t + n/2</code> and <code>e2 = t + n + n/2</code>.</li>
								<li>
									These points, if the arc is a good approximation of the curve interval chosen, should lie <code>on</code> the circle, so their
									distance to the center of the circle should be the same as the distance from any of the three other points to the center.
								</li>
								<li>
									For point points, determine the (absolute) error between the radius of the circle, and the <code>actual</code> distance from the
									center of the circle to the point on the curve.
								</li>
								<li>If this error is too high, we consider the arc bad, and try a smaller interval.</li>
							</ul>
						</li>
					</ul>
					<p>
						The result of this is shown in the next graphic: we start at a guaranteed failure: s=0, e=1. That's the entire curve. The midpoint is
						simply at <code>t=0.5</code>, and then we start performing a
						<a href="https://en.wikipedia.org/wiki/Binary_search_algorithm">binary search</a>.
					</p>
					<ol>
						<li>We start with <code>low=0</code>, <code>mid=0.5</code> and <code>high=1</code></li>
						<li>
							That'll fail, so we retry with the interval halved: <code>{0, 0.25, 0.5}</code>
							<ul>
								<li>If that arc's good, we move back up by half distance: <code>{0, 0.375, 0.75}</code>.</li>
								<li>However, if the arc was still bad, we move <em>down</em> by half the distance: <code>{0, 0.125, 0.25}</code>.</li>
							</ul>
						</li>
						<li>
							We keep doing this over and over until we have two arcs, in sequence, of which the first arc is good, and the second arc is bad. When we
							find that pair, we've found the boundary between a good approximation and a bad approximation, and we pick the good arc.
						</li>
					</ol>
					<p>
						The following graphic shows the result of this approach, with a default error threshold of 0.5, meaning that if an arc is off by a
						<em>combined</em> half pixel over both verification points, then we treat the arc as bad. This is an extremely simple error policy, but
						already works really well. Note that the graphic is still interactive, and you can use your up and down arrow keys keys to increase or
						decrease the error threshold, to see what the effect of a smaller or larger error threshold is.
					</p>
					<graphics-element title="First arc approximation of a Bézier curve" width="275" height="275" src="./chapters/arcapproximation/arc.js">
						<fallback-image>
							<span class="view-source">Scripts are disabled. Showing fallback image.</span>
							<img width="275px" height="275px" src="./images/chapters/arcapproximation/7c9cce8142fa3e85bb124520f40645ff.png" loading="lazy" />
							<label>First arc approximation of a Bézier curve</label>
						</fallback-image>
						<input type="range" min="0.1" max="5" step="0.1" value="0.5" class="slide-control" />
					</graphics-element>
					<p>
						With that in place, all that's left now is to "restart" the procedure by treating the found arc's end point as the new to-be-determined
						arc's starting point, and using points further down the curve. We keep trying this until the found end point is for <em>t=1</em>, at which
						point we are done. Again, the following graphic allows for up and down arrow key input to increase or decrease the error threshold, so you
						can see how picking a different threshold changes the number of arcs that are necessary to reasonably approximate a curve:
					</p>
					<graphics-element title="Arc approximation of a Bézier curve" width="275" height="275" src="./chapters/arcapproximation/arcs.js">
						<fallback-image>
							<span class="view-source">Scripts are disabled. Showing fallback image.</span>
							<img width="275px" height="275px" src="./images/chapters/arcapproximation/da76341b841df1af8a39f797e85dfe3c.png" loading="lazy" />
							<label>Arc approximation of a Bézier curve</label>
						</fallback-image>
						<input type="range" min="0.1" max="5" step="0.1" value="0.5" class="slide-control" />
					</graphics-element>
					<p>
						So... what is this good for? Obviously, if you're working with technologies that can't do curves, but can do lines and circles, then the
						answer is pretty straightforward, but what else? There are some reasons why you might need this technique: using circular arcs means you
						can determine whether a coordinate lies "on" your curve really easily (simply compute the distance to each circular arc center, and if any
						of those are close to the arc radii, at an angle between the arc start and end, bingo, this point can be treated as lying "on the curve").
						Another benefit is that this approximation is "linear": you can almost trivially travel along the arcs at fixed speed. You can also
						trivially compute the arc length of the approximated curve (it's a bit like curve flattening). The only thing to bear in mind is that this
						is a lossy equivalence: things that you compute based on the approximation are guaranteed "off" by some small value, and depending on how
						much precision you need, arc approximation is either going to be super useful, or completely useless. It's up to you to decide which,
						based on your application!
					</p>
				</section>
				<section id="bsplines">
					<h1>
						<div class="nav"><a href="ja-JP/index.html#arcapproximation">previous</a><a href="ja-JP/index.html#comments">next</a></div>
						<a href="ja-JP/index.html#bsplines">B-Splines</a>
					</h1>
					<p>
						No discussion on Bézier curves is complete without also giving mention of that other beast in the curve design space: B-Splines. Easily
						confused to mean Bézier splines, that's not actually what they are; they are "basis function" splines, which makes a lot of difference,
						and we'll be looking at those differences in this section. We're not going to dive as deep into B-Splines as we have for Bézier curves
						(that would be an entire primer on its own) but we'll be looking at how B-Splines work, what kind of maths is involved in computing them,
						and how to draw them based on a number of parameters that you can pick for individual B-Splines.
					</p>
					<p>
						First off: B-Splines are <a href="https://en.wikipedia.org/wiki/Piecewise">piecewise</a>,
						<a href="https://en.wikipedia.org/wiki/Spline_(mathematics)">polynomial interpolation curves</a>, where the "single curve" is built by
						performing polynomial interpolation over a set of points, using a sliding window of a fixed number of points. For instance, a "cubic"
						B-Spline defined by twelve points will have its curve built by evaluating the polynomial interpolation of four points, and the curve can
						be treated as a lot of different sections, each controlled by four points at a time, such that the full curve consists of smoothly
						connected sections defined by points {1,2,3,4}, {2,3,4,5}, ..., {8,9,10,11}, and finally {9,10,11,12}, for eight sections.
					</p>
					<p>
						What do they look like? They look like this! Tap on the graphic to add more points, and move points around to see how they map to the
						spline curve drawn.
					</p>
					<graphics-element title="A B-Spline example" width="600" height="300" src="./chapters/bsplines/basic.js">
						<fallback-image>
							<span class="view-source">Scripts are disabled. Showing fallback image.</span>
							<img width="600px" height="300px" src="./images/chapters/bsplines/fe3a8ca5706f286d916e36699e237e51.png" loading="lazy" />
							<label></label> </fallback-image
					></graphics-element>
					<p>
						The important part to notice here is that we are <strong>not</strong> doing the same thing with B-Splines that we do for poly-Béziers or
						Catmull-Rom curves: both of the latter simply define new sections as literally "new sections based on new points", so a 12 point cubic
						poly-Bézier curve is actually impossible, because we start with a four point curve, and then add three more points for each section that
						follows, so we can only have 4, 7, 10, 13, 16, etc. point Poly-Béziers. Similarly, while Catmull-Rom curves can grow by adding single
						points, this addition of a single point introduces three implicit Bézier points. Cubic B-Splines, on the other hand, are smooth
						interpolations of <em>each possible curve involving four consecutive points</em>, such that at any point along the curve except for our
						start and end points, our on-curve coordinate is defined by four control points.
					</p>
					<p>Consider the difference to be this:</p>
					<ul>
						<li>for Bézier curves, the curve is defined as an interpolation of points, but:</li>
						<li>for B-Splines, the curve is defined as an interpolation of <em>curves</em>.</li>
					</ul>
					<p>In fact, let's look at that again, but this time with the base curves shown, too. Each consecutive four points define one curve:</p>
					<graphics-element title="The components of a B-Spline " width="600" height="300" src="./chapters/bsplines/basic.js" data-show-curves="true">
						<fallback-image>
							<span class="view-source">Scripts are disabled. Showing fallback image.</span>
							<img width="600px" height="300px" src="./images/chapters/bsplines/41167c64c51386414c6e62f0b45e6295.png" loading="lazy" />
							<label></label>
						</fallback-image>
						<!-- basis curve highlighter goes here -->
					</graphics-element>
					<p>
						In order to make this interpolation of curves work, the maths is necessarily more complex than the maths for Bézier curves, so let's have
						a look at how things work.
					</p>
					<h2>How to compute a B-Spline curve: some maths</h2>
					<p>
						Given a B-Spline of degree <code>d</code> and thus order <code>k=d+1</code> (so a quadratic B-Spline is degree 2 and order 3, a cubic
						B-Spline is degree 3 and order 4, etc) and <code>n</code> control points <code>P<sub>0</sub></code> through <code>P<sub>n-1</sub></code
						>, we can compute a point on the curve for some value <code>t</code> in the interval [0,1] (where 0 is the start of the curve, and 1 the
						end, just like for Bézier curves), by evaluating the following function:
					</p>
					<!--
\setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
 
                                                                 __ n
                                                      Point(t) = ❯      P   · N   (t)
                                                                 ‾‾ i=0  i     i,k
-->
					<img class="LaTeX SVG" src="./images/chapters/bsplines/89f8e37237d066fa70ccf6d37b3a4922.svg" width="169px" height="41px" loading="lazy" />
					<p>
						Which, honestly, doesn't tell us all that much. All we can see is that a point on a B-Spline curve is defined as "a mix of all the control
						points, weighted somehow", where the weighting is achieved through the <em>N(...)</em> function, subscripted with an obvious parameter
						<code>i</code>, which comes from our summation, and some magical parameter <code>k</code>. So we need to know two things: 1. what does
						N(t) do, and 2. what is that <code>k</code>? Let's cover both, in reverse order.
					</p>
					<p>
						The parameter <code>k</code> represents the "knot interval" over which a section of curve is defined. As we learned earlier, a B-Spline
						curve is itself an interpolation of curves, and we can treat each transition where a control point starts or stops influencing the total
						curvature as a "knot on the curve". Doing so for a degree <code>d</code> B-Spline with <code>n</code> control point gives us
						<code>d + n + 1</code> knots, defining <code>d + n</code> intervals along the curve, and it is these intervals that the above
						<code>k</code> subscript to the N() function applies to.
					</p>
					<p>Then the N() function itself. What does it look like?</p>
					<!--
\setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
 
                                   ╭       t-knot        ╮                ╭      knot     -t      ╮
                                   │             i       │                │          (i+k)        │
                         N   (t) = │ ─────────────────── │  · N     (t) + │ ───────────────────── │  · N       (t)
                          i,k      │ knot        - knot  │     i,k-1      │ knot      - knot      │     i+1,k-1
                                   ╰     (i+k-1)       i ╯                ╰     (i+k)       (i+1) ╯
-->
					<img class="LaTeX SVG" src="./images/chapters/bsplines/cbdf5a61de10eeb6f23be077cf047ab5.svg" width="559px" height="43px" loading="lazy" />
					<p>
						So this is where we see the interpolation: N(t) for an <code>(i,k)</code> pair (that is, for a step in the above summation, on a specific
						knot interval) is a mix between N(t) for <code>(i,k-1)</code> and N(t) for <code>(i+1,k-1)</code>, so we see that this is a recursive
						iteration where <code>i</code> goes up, and <code>k</code> goes down, so it seem reasonable to expect that this recursion has to stop at
						some point; obviously, it does, and specifically it does so for the following <code>i</code>/<code>k</code> values:
					</p>
					<!--
\setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
 
                                                             ╭ 1 if  t ∈[knot ,knot   )
                                                   N   (t) = ╡               i     i+1  
                                                    i,1      ╰ 0       otherwise
-->
					<img class="LaTeX SVG" src="./images/chapters/bsplines/ee203de6e554936588eb93adead0a3e5.svg" width="240px" height="40px" loading="lazy" />
					<p>
						And this function finally has a straight up evaluation: if a <code>t</code> value lies within a knot-specific interval once we reach a
						<code>k=1</code> value, it "counts", otherwise it doesn't. We did cheat a little, though, because for all these values we need to scale
						our <code>t</code> value first, so that it lies in the interval bounded by <code>knots[d]</code> and <code>knots[n]</code>, which are the
						start point and end point where curvature is controlled by exactly <code>order</code> control points. For instance, for degree 3 (=order
						4) and 7 control points, with knot vector [1,2,3,4,5,6,7,8,9,10,11], we map <code>t</code> from [the interval 0,1] to the interval [4,8],
						and then use that value in the functions above, instead.
					</p>
					<h2>Can we simplify that?</h2>
					<p>We can, yes.</p>
					<p>
						People far smarter than us have looked at this work, and two in particular —
						<a href="https://www.npl.co.uk/people/maurice-cox">Maurice Cox</a> and
						<a href="https://en.wikipedia.org/wiki/Carl_R._de_Boor">Carl de Boor</a> — came to a mathematically pleasing solution: to compute a point
						P(t), we can compute this point by evaluating <em>d(t)</em> on a curve section between knots <code>i</code> and <code>i+1</code>:
					</p>
					<!--
\setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
 
                                                k               k-1                   k-1
                                               d (t) = α     · d   (t) + (1-α   )  · d   (t)
                                                i       i,k     i            i,k      i-1
-->
					<img class="LaTeX SVG" src="./images/chapters/bsplines/f0bf7d0f1931060cd801ff707f482c16.svg" width="281px" height="21px" loading="lazy" />
					<p>
						This is another recursive function, with <em>k</em> values decreasing from the curve order to 1, and the value <em>α</em> (alpha) defined
						by:
					</p>
					<!--
\setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
 
                                                                   t - knots[i]
                                                      α    = ─────────────────────────
                                                       i,k   knots[i+1+n-k] - knots[i]
-->
					<img class="LaTeX SVG" src="./images/chapters/bsplines/c7af721e5e201fc3742bce67ff6cd560.svg" width="255px" height="39px" loading="lazy" />
					<p>
						That looks complicated, but it's not. Computing alpha is just a fraction involving known, plain numbers. And, once we have our alpha
						value, we also have <code>(1-alpha)</code> because it's a trivial subtraction. Computing the <code>d()</code> function is thus mostly a
						matter of computing pretty simple arithmetical statements, with some caching of results so we can refer to them as we recurve. While the
						recursion might see computationally expensive, the total algorithm is cheap, as each step only involves very simple maths.
					</p>
					<p>Of course, the recursion does need a stop condition:</p>
					<!--
\setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
 
                                          k           0                ╭ 1 if  t ∈[knot ,knot   )
                                         d (t) = 0,  d (t) = N   (t) = ╡               i     i+1  
                                          0           i       i,1      ╰ 0       otherwise
-->
					<img class="LaTeX SVG" src="./images/chapters/bsplines/a88566be442b67fb71f727de6bdb66df.svg" width="368px" height="40px" loading="lazy" />
					<p>
						So, we actually see two stopping conditions: either <code>i</code> becomes 0, in which case <code>d()</code> is zero, or
						<code>k</code> becomes zero, in which case we get the same "either 1 or 0" that we saw in the N() function above.
					</p>
					<p>
						Thanks to Cox and de Boor, we can compute points on a B-Spline pretty easily using the same kind of linear interpolation we saw in de
						Casteljau's algorithm. For instance, if we write out <code>d()</code> for <code>i=3</code> and <code>k=3</code>, we get the following
						recursion diagram:
					</p>
					<!--
\setmainfont[Ligatures=TeX]TeX Gyre Pagella \setmathfontTeX Gyre Pagella Math
 
              ╭                                ╭                                ╭          1     0           0
              │                                │                                │         α   × d ,   with  d    either 0 or 1 
              │                                │          2     1           1   │          3     3           3
              │                                │         α   × d ,   with  d  = ╡                 +                              
              │                                │          3     3           3   │ ╭      1 ╮     0           0
              │                                │                                │ │ 1 - α  │  × d ,   with  d    either 0 or 1 
              │          3     2           2   │                                ╰ ╰      3 ╯     2           2
              │         α   × d ,   with  d  = ╡                 +                                                                
              │          3     3           3   │                                ╭           1     0
              │                                │                                │          α   × d                             
              │                                │ ╭      2 ╮     1           1   │           2     2
              │                                │ │ 1 - α  │  × d ,   with  d  = ╡                 +                              
          3   │                                │ ╰      3 ╯     2           2   │ ╭      1 ╮     0           0
         d  = ╡                                │                                │ │ 1 - α  │  × d ,   with  d    either 0 or 1     
          3   │                                ╰                                ╰ ╰      2 ╯     1           1
              │                 +                                                                                                 
              │                                ╭           2     1
              │                                │          α   × d                                                                
              │                                │           2     2
              │                                │                                                                                 
              │ ╭      3 ╮     2           2   │                 +                                                               
              │ │ 1 - α  │  × d ,   with  d  = ╡                                ╭           1     0                               
              │ ╰      3 ╯     2           2   │                                │          α   × d 
              │                                │ ╭      2 ╮     1           1   │           1     1
              │                                │ │ 1 - α  │  × d ,   with  d  = ╡                 +                              
              │                                │ ╰      2 ╯     1           1   │ ╭      1 ╮     0           0
              │                                │                                │ │ 1 - α  │  × d ,   with  d    either 0 or 1 
              ╰                                ╰                                ╰ ╰      1 ╯     0           0
-->
					<img class="LaTeX SVG" src="./images/chapters/bsplines/20e910bbea2e6eff511cb13cef18ef3b.svg" width="641px" height="336px" loading="lazy" />
					<p>
						That is, we compute <code>d(3,3)</code> as a mixture of <code>d(2,3)</code> and <code>d(2,2)</code>, where those two are themselves a
						mixture of <code>d(1,3)</code> and <code>d(1,2)</code>, and <code>d(1,2)</code> and <code>d(1,1)</code>, respectively, which are
						themselves a mixture of etc. etc. We simply keep expanding our terms until we reach the stop conditions, and then sum everything back up.
						It's really quite elegant.
					</p>
					<p>
						One thing we need to keep in mind is that we're working with a spline that is constrained by its control points, so even though the
						<code>d(..., k)</code> values are zero or one at the lowest level, they are really "zero or one, times their respective control point", so
						in the next section you'll see the algorithm for running through the computation in a way that starts with a copy of the control point
						vector and then works its way up to that single point, rather than first starting "on the left", working our way "to the right" and then
						summing back up "to the left". We can just start on the right and work our way left immediately.
					</p>
					<h2>Running the computation</h2>
					<p>
						Unlike the de Casteljau algorithm, where the <code>t</code> value stays the same at every iteration, for B-Splines that is not the case,
						and so we end having to (for each point we evaluate) run a fairly involving bit of recursive computation. The algorithm is discussed on
						<a href="https://pages.mtu.edu/~shene/COURSES/cs3621/NOTES/spline/de-Boor.html">this Michigan Tech</a> page, but an easier to read version
						is implemented by <a href="https://github.com/thibauts/b-spline/blob/master/index.js#L59-L71">b-spline.js</a>, so we'll look at its code.
					</p>
					<p>
						Given an input value <code>t</code>, we first map the input to a value from the domain <code>[0,1]</code> to the domain
						<code>[knots[degree], knots[knots.length - 1 - degree]</code>. Then, we find the section number <code>s</code> that this mapped
						<code>t</code> value lies on:
					</p>

					<table class="code">
						<tr>
							<td>1</td>
							<td rowspan="3">
								<textarea disabled rows="3" role="doc-example">
for(s=domain[0]; s < domain[1]; s++) {
  if(knots[s] <= t && t <= knots[s+1]) break;
}</textarea
								>
							</td>
						</tr>
						<tr>
							<td>2</td>
						</tr>
						<tr>
							<td>3</td>
						</tr>
					</table>

					<p>
						after running this code, <code>s</code> is the index for the section the point will lie on. We then run the algorithm mentioned on the MU
						page (updated to use this description's variable names):
					</p>

					<table class="code">
						<tr>
							<td>1</td>
							<td rowspan="10">
								<textarea disabled rows="10" role="doc-example">
let v = copy of control points

for(let L = 1; L <= order; L++) {
  for(let i=s; i > s + L - order; i--) {
    let numerator = t - knots[i]
    let denominator = knots[i - L + order] - knots[i]
    let alpha = numerator / denominator
    let v[i] = alpha * v[i] + (1-alpha) * v[i-1]
  }
}</textarea
								>
							</td>
						</tr>
						<tr>
							<td>2</td>
						</tr>
						<tr>
							<td>3</td>
						</tr>
						<tr>
							<td>4</td>
						</tr>
						<tr>
							<td>5</td>
						</tr>
						<tr>
							<td>6</td>
						</tr>
						<tr>
							<td>7</td>
						</tr>
						<tr>
							<td>8</td>
						</tr>
						<tr>
							<td>9</td>
						</tr>
						<tr>
							<td>10</td>
						</tr>
					</table>

					<p>
						(A nice bit of behaviour in this code is that we work the interpolation "backwards", starting at <code>i=s</code> at each level of the
						interpolation, and we stop when <code>i = s - order + level</code>, so we always end up with a value for <code>i</code> such that those
						<code>v[i-1]</code> don't try to use an array index that doesn't exist)
					</p>
					<h2>Open vs. closed paths</h2>
					<p>
						Much like poly-Béziers, B-Splines can be either open, running from the first point to the last point, or closed, where the first and last
						point are the same coordinate. However, because B-Splines are an interpolation of curves, not just points, we can't simply make the first
						and last point the same, we need to link as many points as are necessary to form "a curve" that the spline performs interpolation with. As
						such, for an order <code>d</code> B-Spline, we need to make the first and last <code>d</code> points the same. This is of course hardly
						more work than before (simply append <code>points.splice(0,d)</code> to <code>points</code>) but it's important to remember that you need
						more than just a single point.
					</p>
					<p>
						Of course if we want to manipulate these kind of curves we need to make sure to mark them as "closed" so that we know the coordinate for
						<code>points[0]</code> and <code>points[n-k]</code> etc. don't just happen to have the same x/y values, but really are the same
						coordinate, so that manipulating one will equally manipulate the other, but programming generally makes this really easy by storing
						references to points, rather than copies (or other linked values such as coordinate weights, discussed in the NURBS section) rather than
						separate coordinate objects.
					</p>
					<h2>Manipulating the curve through the knot vector</h2>
					<p>
						The most important thing to understand when it comes to B-Splines is that they work <em>because</em> of the concept of a knot vector. As
						mentioned above, knots represent "where individual control points start/stop influencing the curve", but we never looked at the
						<em>values</em> that go in the knot vector. If you look back at the N() and a() functions, you see that interpolations are based on
						intervals in the knot vector, rather than the actual values in the knot vector, and we can exploit this to do some pretty interesting
						things with clever manipulation of the knot vector. Specifically there are four things we can do that are worth looking at:
					</p>
					<ol>
						<li>we can use a uniform knot vector, with equally spaced intervals,</li>
						<li>we can use a non-uniform knot vector, without enforcing equally spaced intervals,</li>
						<li>we can collapse sequential knots to the same value, locally lowering curve complexity using "null" intervals, and</li>
						<li>
							we can form a special case non-uniform vector, by combining (1) and (3) to for a vector with collapsed start and end knots, with a
							uniform vector in between.
						</li>
					</ol>
					<h3>Uniform B-Splines</h3>
					<p>
						The most straightforward type of B-Spline is the uniform spline. In a uniform spline, the knots are distributed uniformly over the entire
						curve interval. For instance, if we have a knot vector of length twelve, then a uniform knot vector would be [0,1,2,3,...,9,10,11]. Or
						[4,5,6,...,13,14,15], which defines <em>the same intervals</em>, or even [0,2,3,...,18,20,22], which also defines
						<em>the same intervals</em>, just scaled by a constant factor, which becomes normalised during interpolation and so does not contribute to
						the curvature.
					</p>
					<graphics-element title="A uniform B-Spline" width="400" height="400" src="./chapters/bsplines/uniform.js">
						<fallback-image>
							<span class="view-source">Scripts are disabled. Showing fallback image.</span>
							<img width="400px" height="400px" src="./images/chapters/bsplines/48a30189e74658737b3a8b28bb816f8a.png" loading="lazy" />
							<label></label>
						</fallback-image>
						<!-- knot sliders go here -->
					</graphics-element>
					<p>
						This is an important point: the intervals that the knot vector defines are <em>relative</em> intervals, so it doesn't matter if every
						interval is size 1, or size 100 - the relative differences between the intervals is what shapes any particular curve.
					</p>
					<p>
						The problem with uniform knot vectors is that, as we need <code>order</code> control points before we have any curve with which we can
						perform interpolation, the curve does not "start" at the first point, nor "ends" at the last point. Instead there are "gaps". We can get
						rid of these, by being clever about how we apply the following uniformity-breaking approach instead...
					</p>
					<h3>Reducing local curve complexity by collapsing intervals</h3>
					<p>
						Collapsing knot intervals, by making two or more consecutive knots have the same value, allows us to reduce the curve complexity in the
						sections that are affected by the knots involved. This can have drastic effects: for every interval collapse, the curve order goes down,
						and curve continuity goes down, to the point where collapsing <code>order</code> knots creates a situation where all continuity is lost
						and the curve "kinks".
					</p>
					<graphics-element title="A reduced uniform B-Spline" width="400" height="400" src="./chapters/bsplines/reduced.js">
						<fallback-image>
							<span class="view-source">Scripts are disabled. Showing fallback image.</span>
							<img width="400px" height="400px" src="./images/chapters/bsplines/ceaef2fbee05a58aa11835925403b4cd.png" loading="lazy" />
							<label></label>
						</fallback-image>
						<!-- knot sliders go here -->
					</graphics-element>
					<h3>Open-Uniform B-Splines</h3>
					<p>
						By combining knot interval collapsing at the start and end of the curve, with uniform knots in between, we can overcome the problem of the
						curve not starting and ending where we'd kind of like it to:
					</p>
					<p>
						For any curve of degree <code>D</code> with control points <code>N</code>, we can define a knot vector of length <code>N+D+1</code> in
						which the values <code>0 ... D+1</code> are the same, the values <code>D+1 ... N+1</code> follow the "uniform" pattern, and the values
						<code>N+1 ... N+D+1</code> are the same again. For example, a cubic B-Spline with 7 control points can have a knot vector
						[0,0,0,0,1,2,3,4,4,4,4], or it might have the "identical" knot vector [0,0,0,0,2,4,6,8,8,8,8], etc. Again, it is the relative differences
						that determine the curve shape.
					</p>
					<graphics-element title="An open, uniform B-Spline" width="400" height="400" src="./chapters/bsplines/uniform.js" data-open="true">
						<fallback-image>
							<span class="view-source">Scripts are disabled. Showing fallback image.</span>
							<img width="400px" height="400px" src="./images/chapters/bsplines/0215dc106e4ad51afe043c0176a595f6.png" loading="lazy" />
							<label></label>
						</fallback-image>
						<!-- knot sliders go here -->
					</graphics-element>
					<h3>Non-uniform B-Splines</h3>
					<p>
						This is essentially the "free form" version of a B-Spline, and also the least interesting to look at, as without any specific reason to
						pick specific knot intervals, there is nothing particularly interesting going on. There is one constraint to the knot vector, other than
						that any value <code>knots[k+1]</code> should be greater than or equal to <code>knots[k]</code>.
					</p>
					<h2>One last thing: Rational B-Splines</h2>
					<p>
						While it is true that this section on B-Splines is running quite long already, there is one more thing we need to talk about, and that's
						"Rational" splines, where the rationality applies to the "ratio", or relative weights, of the control points themselves. By introducing a
						ratio vector with weights to apply to each control point, we greatly increase our influence over the final curve shape: the more weight a
						control point carries, the closer to that point the spline curve will lie, a bit like turning up the gravity of a control point, just like
						for rational Bézier curves.
					</p>
					<graphics-element title="A (closed) rational, uniform B-Spline" width="400" height="400" src="./chapters/bsplines/rational-uniform.js">
						<fallback-image>
							<span class="view-source">Scripts are disabled. Showing fallback image.</span>
							<img width="400px" height="400px" src="./images/chapters/bsplines/0d9c2186423466a32bb8fbd187409f82.png" loading="lazy" />
							<label></label>
						</fallback-image>
						<!-- knot sliders go here -->
					</graphics-element>
					<p>
						Of course this brings us to the final topic that any text on B-Splines must touch on before calling it a day: the
						<a href="https://en.wikipedia.org/wiki/Non-uniform_rational_B-spline">NURBS</a>, or Non-Uniform Rational B-Spline (NURBS is not a plural,
						the capital S actually just stands for "spline", but a lot of people mistakenly treat it as if it is, so now you know better). NURBS is an
						important type of curve in computer-facilitated design, used a lot in 3D modelling (typically as NURBS surfaces) as well as in
						arbitrary-precision 2D design due to the level of control a NURBS curve offers designers.
					</p>
					<p>
						While a true non-uniform rational B-Spline would be hard to work with, when we talk about NURBS we typically mean the Open-Uniform
						Rational B-Spline, or OURBS, but that doesn't roll off the tongue nearly as nicely, and so remember that when people talk about NURBS,
						they typically mean open-uniform, which has the useful property of starting the curve at the first control point, and ending it at the
						last.
					</p>
					<h2>Extending our implementation to cover rational splines</h2>
					<p>
						The algorithm for working with Rational B-Splines is virtually identical to the regular algorithm, and the extension to work in the
						control point weights is fairly simple: we extend each control point from a point in its original number of dimensions (2D, 3D, etc.) to
						one dimension higher, scaling the original dimensions by the control point's weight, and then assigning that weight as its value for the
						extended dimension.
					</p>
					<p>For example, a 2D point <code>(x,y)</code> with weight <code>w</code> becomes a 3D point <code>(w * x, w * y, w)</code>.</p>
					<p>
						We then run the same algorithm as before, which will automatically perform weight interpolation in addition to regular coordinate
						interpolation, because all we've done is pretended we have coordinates in a higher dimension. The algorithm doesn't really care about how
						many dimensions it needs to interpolate.
					</p>
					<p>
						In order to recover our "real" curve point, we take the final result of the point generation algorithm, and "unweigh" it: we take the
						final point's derived weight <code>w'</code> and divide all the regular coordinate dimensions by it, then throw away the weight
						information.
					</p>
					<p>
						Based on our previous example, we take the final 3D point <code>(x', y', w')</code>, which we then turn back into a 2D point by computing
						<code>(x'/w', y'/w')</code>. And that's it, we're done!
					</p>
				</section>
				<section id="comments">
					<script src="./js/site/disqus.js" async defer>
						/* ----------------------------------------------------------------------------- *
						 *
						 *                    PLEASE DO NOT LOCALISE THIS FILE
						 *
						 * I can't respond to questions that aren't asked in English, so this is one of
						 * the few cases where there is a content.en-GB.md but you should not localize it.
						 *
						 * ----------------------------------------------------------------------------- */
					</script>

					<h1>
						<div class="nav"><a href="ja-JP/index.html#bsplines">previous</a></div>
						<a href="ja-JP/index.html#comments">Comments and questions</a>
					</h1>
					<p>
						First off, if you enjoyed this book, or you simply found it useful for something you were trying to get done, and you were wondering how
						to let me know you appreciated this book, you have two options: you can either head on over to the
						<a href="https://www.patreon.com/bezierinfo">Patreon page</a> for this book, or if you prefer to make a one-time donation, head on over to
						the <a href="https://www.paypal.com/donate/?cmd=_s-xclick&hosted_button_id=3BNHGHZAS3DP6&locale.x=en_CA">buy Pomax a coffee</a> page. This
						work has grown from a small primer to a 70-plus print-page-equivalent reader on the subject of Bézier curves over the years, and a lot of
						coffee went into the making of it. I don't regret a minute I spent on writing it, but I can always do with some more coffee to keep on
						writing.
					</p>
					<p>With that said, on to the comments!</p>
					<div id="disqus_thread" />
				</section>
			</section>
		</main>

		<hr />

		<footer class="copyright">
			This article is © 2011-2020 to me, Mike "Pomax" Kamermans, but the text, code, and images are
			<a href="https://github.com/Pomax/bezierinfo/blob/master/LICENSE.md">almost no rights reserved</a>. Go do something cool with it!
		</footer>

		<script>
			if (window.location.hash.includes(`#comment-`)) {
				const baseHash = window.location.hash;
				document.addEventListener(`disqus:ready`, () => {
					console.log(`setting location`);
					window.location.hash = ``;
					window.location.hash = baseHash;
				});
				document.getElementById(`disqus_thread`).scrollIntoView();
			}
		</script>
	</body>
</html>
